// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace BaseDefine {

void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto() {
  delete IpAddr::default_instance_;
  delete UserInfo::default_instance_;
  delete RecentContactInfo::default_instance_;
  delete RecentFixTop::default_instance_;
  delete FrequentContactInfo::default_instance_;
  delete UserStat::default_instance_;
  delete UserIdItem::default_instance_;
  delete ServerUserStat::default_instance_;
  delete MsgFont::default_instance_;
  delete MsgItem::default_instance_;
  delete MsgData::default_instance_;
  delete OfflineMsgCntInfo::default_instance_;
  delete GroupListItem::default_instance_;
  delete GroupMemberItem::default_instance_;
  delete GroupInfo::default_instance_;
  delete UserTokenInfo::default_instance_;
  delete PushResult::default_instance_;
  delete ShieldStatus::default_instance_;
  delete OfflineFileInfo::default_instance_;
  delete PushShieldStatus::default_instance_;
  delete IMBuddyReqInfo::default_instance_;
  delete IMSinglePullNotify::default_instance_;
  delete IMGroupPullNotify::default_instance_;
  delete IMUserAuthority::default_instance_;
  delete IMUserRole::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eBaseDefine_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  IpAddr::default_instance_ = new IpAddr();
  UserInfo::default_instance_ = new UserInfo();
  RecentContactInfo::default_instance_ = new RecentContactInfo();
  RecentFixTop::default_instance_ = new RecentFixTop();
  FrequentContactInfo::default_instance_ = new FrequentContactInfo();
  UserStat::default_instance_ = new UserStat();
  UserIdItem::default_instance_ = new UserIdItem();
  ServerUserStat::default_instance_ = new ServerUserStat();
  MsgFont::default_instance_ = new MsgFont();
  MsgItem::default_instance_ = new MsgItem();
  MsgData::default_instance_ = new MsgData();
  OfflineMsgCntInfo::default_instance_ = new OfflineMsgCntInfo();
  GroupListItem::default_instance_ = new GroupListItem();
  GroupMemberItem::default_instance_ = new GroupMemberItem();
  GroupInfo::default_instance_ = new GroupInfo();
  UserTokenInfo::default_instance_ = new UserTokenInfo();
  PushResult::default_instance_ = new PushResult();
  ShieldStatus::default_instance_ = new ShieldStatus();
  OfflineFileInfo::default_instance_ = new OfflineFileInfo();
  PushShieldStatus::default_instance_ = new PushShieldStatus();
  IMBuddyReqInfo::default_instance_ = new IMBuddyReqInfo();
  IMSinglePullNotify::default_instance_ = new IMSinglePullNotify();
  IMGroupPullNotify::default_instance_ = new IMGroupPullNotify();
  IMUserAuthority::default_instance_ = new IMUserAuthority();
  IMUserRole::default_instance_ = new IMUserRole();
  IpAddr::default_instance_->InitAsDefaultInstance();
  UserInfo::default_instance_->InitAsDefaultInstance();
  RecentContactInfo::default_instance_->InitAsDefaultInstance();
  RecentFixTop::default_instance_->InitAsDefaultInstance();
  FrequentContactInfo::default_instance_->InitAsDefaultInstance();
  UserStat::default_instance_->InitAsDefaultInstance();
  UserIdItem::default_instance_->InitAsDefaultInstance();
  ServerUserStat::default_instance_->InitAsDefaultInstance();
  MsgFont::default_instance_->InitAsDefaultInstance();
  MsgItem::default_instance_->InitAsDefaultInstance();
  MsgData::default_instance_->InitAsDefaultInstance();
  OfflineMsgCntInfo::default_instance_->InitAsDefaultInstance();
  GroupListItem::default_instance_->InitAsDefaultInstance();
  GroupMemberItem::default_instance_->InitAsDefaultInstance();
  GroupInfo::default_instance_->InitAsDefaultInstance();
  UserTokenInfo::default_instance_->InitAsDefaultInstance();
  PushResult::default_instance_->InitAsDefaultInstance();
  ShieldStatus::default_instance_->InitAsDefaultInstance();
  OfflineFileInfo::default_instance_->InitAsDefaultInstance();
  PushShieldStatus::default_instance_->InitAsDefaultInstance();
  IMBuddyReqInfo::default_instance_->InitAsDefaultInstance();
  IMSinglePullNotify::default_instance_->InitAsDefaultInstance();
  IMGroupPullNotify::default_instance_->InitAsDefaultInstance();
  IMUserAuthority::default_instance_->InitAsDefaultInstance();
  IMUserRole::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eBaseDefine_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eBaseDefine_2eproto_once_);
void protobuf_AddDesc_IM_2eBaseDefine_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eBaseDefine_2eproto_once_,
                 &protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eBaseDefine_2eproto {
  StaticDescriptorInitializer_IM_2eBaseDefine_2eproto() {
    protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  }
} static_descriptor_initializer_IM_2eBaseDefine_2eproto_;
#endif
bool ServiceID_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 65:
    case 66:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
      return true;
    default:
      return false;
  }
}

bool LoginCmdID_IsValid(int value) {
  switch(value) {
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
    case 268:
    case 269:
    case 270:
    case 271:
    case 272:
    case 273:
    case 274:
    case 275:
    case 276:
    case 277:
    case 278:
      return true;
    default:
      return false;
  }
}

bool BuddyListCmdID_IsValid(int value) {
  switch(value) {
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
    case 536:
    case 537:
    case 538:
    case 539:
    case 541:
    case 542:
    case 544:
    case 545:
    case 546:
    case 547:
      return true;
    default:
      return false;
  }
}

bool MessageCmdID_IsValid(int value) {
  switch(value) {
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
    case 783:
    case 784:
    case 785:
    case 786:
    case 787:
    case 788:
    case 789:
    case 790:
    case 791:
    case 792:
    case 793:
    case 794:
    case 795:
      return true;
    default:
      return false;
  }
}

bool GroupCmdID_IsValid(int value) {
  switch(value) {
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
    case 1036:
    case 1037:
    case 1038:
    case 1041:
    case 1042:
    case 1043:
    case 1044:
    case 1045:
    case 1046:
    case 1047:
    case 1048:
    case 1049:
    case 1050:
    case 1051:
    case 1052:
    case 1053:
    case 1056:
    case 1057:
    case 1058:
    case 16675:
    case 16676:
    case 16677:
    case 16678:
    case 16679:
      return true;
    default:
      return false;
  }
}

bool FileCmdID_IsValid(int value) {
  switch(value) {
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

bool RouterCmdID_IsValid(int value) {
  switch(value) {
    case 8705:
    case 8706:
    case 8707:
    case 8708:
    case 8709:
    case 8710:
    case 8711:
    case 8712:
    case 8713:
    case 8714:
    case 8715:
    case 8716:
    case 8717:
    case 8718:
    case 8719:
      return true;
    default:
      return false;
  }
}

bool SwitchServiceCmdID_IsValid(int value) {
  switch(value) {
    case 1537:
      return true;
    default:
      return false;
  }
}

bool OtherCmdID_IsValid(int value) {
  switch(value) {
    case 1793:
    case 1794:
    case 1795:
    case 1796:
    case 1797:
    case 1798:
    case 1799:
    case 1800:
    case 1801:
    case 1802:
    case 1803:
    case 1805:
    case 1806:
    case 1807:
    case 1808:
    case 1809:
    case 1810:
    case 1817:
    case 1818:
    case 1819:
    case 1820:
    case 1821:
    case 1822:
    case 1823:
    case 1825:
    case 1826:
    case 1827:
    case 1828:
    case 1829:
    case 1830:
    case 1831:
    case 1832:
    case 1833:
    case 1834:
    case 1835:
    case 1836:
    case 1837:
    case 1838:
    case 1841:
    case 1842:
    case 1843:
    case 1844:
      return true;
    default:
      return false;
  }
}

bool UserStateCmdID_IsValid(int value) {
  switch(value) {
    case 2049:
    case 2050:
    case 2051:
    case 2052:
    case 2053:
    case 2054:
    case 2064:
    case 2065:
    case 2066:
    case 2080:
    case 2082:
    case 2096:
    case 2098:
    case 2112:
      return true;
    default:
      return false;
  }
}

bool DBProxyCmdID_IsValid(int value) {
  switch(value) {
    case 2305:
    case 2306:
    case 2307:
    case 2308:
    case 2309:
    case 2310:
    case 2311:
    case 2312:
    case 2313:
    case 2314:
    case 2315:
    case 2316:
    case 2317:
    case 2318:
    case 2321:
    case 2322:
    case 2323:
    case 2324:
      return true;
    default:
      return false;
  }
}

bool OptResultCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ResultType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

bool LoginResultCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool KickReasonType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool OnlineListType_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

bool UserStatType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool SessionType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool BuddyOptType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool MsgType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 80:
      return true;
    default:
      return false;
  }
}

bool MsgProperty_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool P2PMsgCmdType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ClientType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 5:
    case 6:
    case 9:
    case 16:
    case 20:
      return true;
    default:
      return false;
  }
}

bool GroupType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool GroupMemberOptType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool ListItemOptType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool TransferFileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ClientFileState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool ClientFileRole_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool FileServerError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

bool ServerNotifyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int IpAddr::kIpFieldNumber;
const int IpAddr::kPortFieldNumber;
#endif  // !_MSC_VER

IpAddr::IpAddr()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IpAddr)
}

void IpAddr::InitAsDefaultInstance() {
}

IpAddr::IpAddr(const IpAddr& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IpAddr)
}

void IpAddr::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IpAddr)
  SharedDtor();
}

void IpAddr::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IpAddr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IpAddr& IpAddr::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IpAddr* IpAddr::default_instance_ = NULL;

IpAddr* IpAddr::New() const {
  return new IpAddr;
}

void IpAddr::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IpAddr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IpAddr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IpAddr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IpAddr)
  return false;
#undef DO_
}

void IpAddr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IpAddr)
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IpAddr)
}

int IpAddr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpAddr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IpAddr*>(&from));
}

void IpAddr::MergeFrom(const IpAddr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IpAddr::CopyFrom(const IpAddr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IpAddr::Swap(IpAddr* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IpAddr::GetTypeName() const {
  return "IM.BaseDefine.IpAddr";
}


// ===================================================================

#ifndef _MSC_VER
const int UserInfo::kCompanyIdFieldNumber;
const int UserInfo::kUserIdFieldNumber;
const int UserInfo::kUserGenderFieldNumber;
const int UserInfo::kUserNickNameFieldNumber;
const int UserInfo::kAvatarUrlFieldNumber;
const int UserInfo::kAvatarUpdateTimeFieldNumber;
const int UserInfo::kEmailFieldNumber;
const int UserInfo::kUserRealNameFieldNumber;
const int UserInfo::kUserMobileFieldNumber;
const int UserInfo::kUserTelFieldNumber;
const int UserInfo::kUserEnglishNameFieldNumber;
const int UserInfo::kStatusFieldNumber;
const int UserInfo::kUserBorndateFieldNumber;
const int UserInfo::kUpdateTimeFieldNumber;
const int UserInfo::kWorkIdFieldNumber;
const int UserInfo::kPosJsonFieldNumber;
const int UserInfo::kSignInfoFieldNumber;
#endif  // !_MSC_VER

UserInfo::UserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserInfo)
}

void UserInfo::InitAsDefaultInstance() {
}

UserInfo::UserInfo(const UserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserInfo)
}

void UserInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  user_gender_ = 0u;
  user_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avatar_update_time_ = GOOGLE_ULONGLONG(0);
  email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_ = 0u;
  user_borndate_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  work_id_ = 0u;
  pos_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserInfo)
  SharedDtor();
}

void UserInfo::SharedDtor() {
  if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nick_name_;
  }
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_real_name_;
  }
  if (user_mobile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_mobile_;
  }
  if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_tel_;
  }
  if (user_english_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_english_name_;
  }
  if (pos_json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pos_json_;
  }
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserInfo& UserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserInfo* UserInfo::default_instance_ = NULL;

UserInfo* UserInfo::New() const {
  return new UserInfo;
}

void UserInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(company_id_, user_id_);
    user_gender_ = 0u;
    if (has_user_nick_name()) {
      if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_nick_name_->clear();
      }
    }
    if (has_avatar_url()) {
      if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        avatar_url_->clear();
      }
    }
    avatar_update_time_ = GOOGLE_ULONGLONG(0);
    if (has_email()) {
      if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        email_->clear();
      }
    }
    if (has_user_real_name()) {
      if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_real_name_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(update_time_, work_id_);
    if (has_user_mobile()) {
      if (user_mobile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_mobile_->clear();
      }
    }
    if (has_user_tel()) {
      if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_tel_->clear();
      }
    }
    if (has_user_english_name()) {
      if (user_english_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_english_name_->clear();
      }
    }
    status_ = 0u;
    if (has_pos_json()) {
      if (pos_json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        pos_json_->clear();
      }
    }
  }
  if (has_sign_info()) {
    if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      sign_info_->clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_user_gender;
        break;
      }

      // required uint32 user_gender = 3;
      case 3: {
        if (tag == 24) {
         parse_user_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_gender_)));
          set_has_user_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_nick_name;
        break;
      }

      // required string user_nick_name = 4;
      case 4: {
        if (tag == 34) {
         parse_user_nick_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_nick_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_avatar_url;
        break;
      }

      // required string avatar_url = 5;
      case 5: {
        if (tag == 42) {
         parse_avatar_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avatar_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_avatar_update_time;
        break;
      }

      // required uint64 avatar_update_time = 6;
      case 6: {
        if (tag == 48) {
         parse_avatar_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &avatar_update_time_)));
          set_has_avatar_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_email;
        break;
      }

      // required string email = 7;
      case 7: {
        if (tag == 58) {
         parse_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_email()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_user_real_name;
        break;
      }

      // required string user_real_name = 8;
      case 8: {
        if (tag == 66) {
         parse_user_real_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_real_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_user_mobile;
        break;
      }

      // required string user_mobile = 9;
      case 9: {
        if (tag == 74) {
         parse_user_mobile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_mobile()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_user_tel;
        break;
      }

      // required string user_tel = 10;
      case 10: {
        if (tag == 82) {
         parse_user_tel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_tel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_user_english_name;
        break;
      }

      // required string user_english_name = 11;
      case 11: {
        if (tag == 90) {
         parse_user_english_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_english_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_status;
        break;
      }

      // required uint32 status = 12;
      case 12: {
        if (tag == 96) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_user_borndate;
        break;
      }

      // required uint32 user_borndate = 13;
      case 13: {
        if (tag == 104) {
         parse_user_borndate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_borndate_)));
          set_has_user_borndate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 14;
      case 14: {
        if (tag == 112) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_work_id;
        break;
      }

      // required uint32 work_id = 15;
      case 15: {
        if (tag == 120) {
         parse_work_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &work_id_)));
          set_has_work_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_pos_json;
        break;
      }

      // required string pos_json = 16;
      case 16: {
        if (tag == 130) {
         parse_pos_json:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pos_json()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_sign_info;
        break;
      }

      // optional string sign_info = 17;
      case 17: {
        if (tag == 138) {
         parse_sign_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sign_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserInfo)
  return false;
#undef DO_
}

void UserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint32 user_gender = 3;
  if (has_user_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->user_gender(), output);
  }

  // required string user_nick_name = 4;
  if (has_user_nick_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->user_nick_name(), output);
  }

  // required string avatar_url = 5;
  if (has_avatar_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->avatar_url(), output);
  }

  // required uint64 avatar_update_time = 6;
  if (has_avatar_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->avatar_update_time(), output);
  }

  // required string email = 7;
  if (has_email()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->email(), output);
  }

  // required string user_real_name = 8;
  if (has_user_real_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->user_real_name(), output);
  }

  // required string user_mobile = 9;
  if (has_user_mobile()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->user_mobile(), output);
  }

  // required string user_tel = 10;
  if (has_user_tel()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->user_tel(), output);
  }

  // required string user_english_name = 11;
  if (has_user_english_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->user_english_name(), output);
  }

  // required uint32 status = 12;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->status(), output);
  }

  // required uint32 user_borndate = 13;
  if (has_user_borndate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->user_borndate(), output);
  }

  // required uint64 update_time = 14;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->update_time(), output);
  }

  // required uint32 work_id = 15;
  if (has_work_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->work_id(), output);
  }

  // required string pos_json = 16;
  if (has_pos_json()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      16, this->pos_json(), output);
  }

  // optional string sign_info = 17;
  if (has_sign_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->sign_info(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserInfo)
}

int UserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 user_gender = 3;
    if (has_user_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_gender());
    }

    // required string user_nick_name = 4;
    if (has_user_nick_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_nick_name());
    }

    // required string avatar_url = 5;
    if (has_avatar_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avatar_url());
    }

    // required uint64 avatar_update_time = 6;
    if (has_avatar_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->avatar_update_time());
    }

    // required string email = 7;
    if (has_email()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->email());
    }

    // required string user_real_name = 8;
    if (has_user_real_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_real_name());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required string user_mobile = 9;
    if (has_user_mobile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_mobile());
    }

    // required string user_tel = 10;
    if (has_user_tel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_tel());
    }

    // required string user_english_name = 11;
    if (has_user_english_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_english_name());
    }

    // required uint32 status = 12;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // required uint32 user_borndate = 13;
    if (has_user_borndate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_borndate());
    }

    // required uint64 update_time = 14;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // required uint32 work_id = 15;
    if (has_work_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->work_id());
    }

    // required string pos_json = 16;
    if (has_pos_json()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pos_json());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string sign_info = 17;
    if (has_sign_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sign_info());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserInfo*>(&from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_gender()) {
      set_user_gender(from.user_gender());
    }
    if (from.has_user_nick_name()) {
      set_user_nick_name(from.user_nick_name());
    }
    if (from.has_avatar_url()) {
      set_avatar_url(from.avatar_url());
    }
    if (from.has_avatar_update_time()) {
      set_avatar_update_time(from.avatar_update_time());
    }
    if (from.has_email()) {
      set_email(from.email());
    }
    if (from.has_user_real_name()) {
      set_user_real_name(from.user_real_name());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_user_mobile()) {
      set_user_mobile(from.user_mobile());
    }
    if (from.has_user_tel()) {
      set_user_tel(from.user_tel());
    }
    if (from.has_user_english_name()) {
      set_user_english_name(from.user_english_name());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_user_borndate()) {
      set_user_borndate(from.user_borndate());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_work_id()) {
      set_work_id(from.work_id());
    }
    if (from.has_pos_json()) {
      set_pos_json(from.pos_json());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_sign_info()) {
      set_sign_info(from.sign_info());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserInfo::CopyFrom(const UserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000ffff) != 0x0000ffff) return false;

  return true;
}

void UserInfo::Swap(UserInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(user_gender_, other->user_gender_);
    std::swap(user_nick_name_, other->user_nick_name_);
    std::swap(avatar_url_, other->avatar_url_);
    std::swap(avatar_update_time_, other->avatar_update_time_);
    std::swap(email_, other->email_);
    std::swap(user_real_name_, other->user_real_name_);
    std::swap(user_mobile_, other->user_mobile_);
    std::swap(user_tel_, other->user_tel_);
    std::swap(user_english_name_, other->user_english_name_);
    std::swap(status_, other->status_);
    std::swap(user_borndate_, other->user_borndate_);
    std::swap(update_time_, other->update_time_);
    std::swap(work_id_, other->work_id_);
    std::swap(pos_json_, other->pos_json_);
    std::swap(sign_info_, other->sign_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserInfo::GetTypeName() const {
  return "IM.BaseDefine.UserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RecentContactInfo::kCompanyIdFieldNumber;
const int RecentContactInfo::kContactIdFieldNumber;
const int RecentContactInfo::kSessionTypeFieldNumber;
const int RecentContactInfo::kContactInfoUpdateTimeFieldNumber;
const int RecentContactInfo::kContactNameFieldNumber;
const int RecentContactInfo::kContactRemarkFieldNumber;
const int RecentContactInfo::kUserGenderFieldNumber;
const int RecentContactInfo::kIsFixtopFieldNumber;
const int RecentContactInfo::kTopOrderFieldNumber;
#endif  // !_MSC_VER

RecentContactInfo::RecentContactInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.RecentContactInfo)
}

void RecentContactInfo::InitAsDefaultInstance() {
}

RecentContactInfo::RecentContactInfo(const RecentContactInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.RecentContactInfo)
}

void RecentContactInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  contact_id_ = 0u;
  session_type_ = 1;
  contact_info_update_time_ = GOOGLE_ULONGLONG(0);
  contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_gender_ = 0u;
  is_fixtop_ = false;
  top_order_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecentContactInfo::~RecentContactInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.RecentContactInfo)
  SharedDtor();
}

void RecentContactInfo::SharedDtor() {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_name_;
  }
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RecentContactInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RecentContactInfo& RecentContactInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

RecentContactInfo* RecentContactInfo::default_instance_ = NULL;

RecentContactInfo* RecentContactInfo::New() const {
  return new RecentContactInfo;
}

void RecentContactInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RecentContactInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(company_id_, contact_info_update_time_);
    session_type_ = 1;
    if (has_contact_name()) {
      if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contact_name_->clear();
      }
    }
    if (has_contact_remark()) {
      if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contact_remark_->clear();
      }
    }
    user_gender_ = 0u;
    is_fixtop_ = false;
  }
  top_order_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RecentContactInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.RecentContactInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_contact_id;
        break;
      }

      // required uint32 contact_id = 2;
      case 2: {
        if (tag == 16) {
         parse_contact_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contact_id_)));
          set_has_contact_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 3;
      case 3: {
        if (tag == 24) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_contact_info_update_time;
        break;
      }

      // required uint64 contact_info_update_time = 4;
      case 4: {
        if (tag == 32) {
         parse_contact_info_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &contact_info_update_time_)));
          set_has_contact_info_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_contact_name;
        break;
      }

      // required string contact_name = 5;
      case 5: {
        if (tag == 42) {
         parse_contact_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contact_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_contact_remark;
        break;
      }

      // required string contact_remark = 6;
      case 6: {
        if (tag == 50) {
         parse_contact_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contact_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_user_gender;
        break;
      }

      // required uint32 user_gender = 7;
      case 7: {
        if (tag == 56) {
         parse_user_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_gender_)));
          set_has_user_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_is_fixtop;
        break;
      }

      // required bool is_fixtop = 8;
      case 8: {
        if (tag == 64) {
         parse_is_fixtop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_fixtop_)));
          set_has_is_fixtop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_top_order;
        break;
      }

      // required uint32 top_order = 9;
      case 9: {
        if (tag == 72) {
         parse_top_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &top_order_)));
          set_has_top_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.RecentContactInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.RecentContactInfo)
  return false;
#undef DO_
}

void RecentContactInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.RecentContactInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 contact_id = 2;
  if (has_contact_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->contact_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 3;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->session_type(), output);
  }

  // required uint64 contact_info_update_time = 4;
  if (has_contact_info_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->contact_info_update_time(), output);
  }

  // required string contact_name = 5;
  if (has_contact_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->contact_name(), output);
  }

  // required string contact_remark = 6;
  if (has_contact_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->contact_remark(), output);
  }

  // required uint32 user_gender = 7;
  if (has_user_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->user_gender(), output);
  }

  // required bool is_fixtop = 8;
  if (has_is_fixtop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_fixtop(), output);
  }

  // required uint32 top_order = 9;
  if (has_top_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->top_order(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.RecentContactInfo)
}

int RecentContactInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 contact_id = 2;
    if (has_contact_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->contact_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 3;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint64 contact_info_update_time = 4;
    if (has_contact_info_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->contact_info_update_time());
    }

    // required string contact_name = 5;
    if (has_contact_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contact_name());
    }

    // required string contact_remark = 6;
    if (has_contact_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contact_remark());
    }

    // required uint32 user_gender = 7;
    if (has_user_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_gender());
    }

    // required bool is_fixtop = 8;
    if (has_is_fixtop()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 top_order = 9;
    if (has_top_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->top_order());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecentContactInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RecentContactInfo*>(&from));
}

void RecentContactInfo::MergeFrom(const RecentContactInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_contact_id()) {
      set_contact_id(from.contact_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_contact_info_update_time()) {
      set_contact_info_update_time(from.contact_info_update_time());
    }
    if (from.has_contact_name()) {
      set_contact_name(from.contact_name());
    }
    if (from.has_contact_remark()) {
      set_contact_remark(from.contact_remark());
    }
    if (from.has_user_gender()) {
      set_user_gender(from.user_gender());
    }
    if (from.has_is_fixtop()) {
      set_is_fixtop(from.is_fixtop());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_top_order()) {
      set_top_order(from.top_order());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RecentContactInfo::CopyFrom(const RecentContactInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecentContactInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void RecentContactInfo::Swap(RecentContactInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(contact_id_, other->contact_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(contact_info_update_time_, other->contact_info_update_time_);
    std::swap(contact_name_, other->contact_name_);
    std::swap(contact_remark_, other->contact_remark_);
    std::swap(user_gender_, other->user_gender_);
    std::swap(is_fixtop_, other->is_fixtop_);
    std::swap(top_order_, other->top_order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RecentContactInfo::GetTypeName() const {
  return "IM.BaseDefine.RecentContactInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RecentFixTop::kCompanyIdFieldNumber;
const int RecentFixTop::kUserIdFieldNumber;
const int RecentFixTop::kUpdateTimeFieldNumber;
const int RecentFixTop::kContactRemarkFieldNumber;
const int RecentFixTop::kUserGenderFieldNumber;
const int RecentFixTop::kTopOrderFieldNumber;
#endif  // !_MSC_VER

RecentFixTop::RecentFixTop()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.RecentFixTop)
}

void RecentFixTop::InitAsDefaultInstance() {
}

RecentFixTop::RecentFixTop(const RecentFixTop& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.RecentFixTop)
}

void RecentFixTop::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_gender_ = 0u;
  top_order_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecentFixTop::~RecentFixTop() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.RecentFixTop)
  SharedDtor();
}

void RecentFixTop::SharedDtor() {
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RecentFixTop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RecentFixTop& RecentFixTop::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

RecentFixTop* RecentFixTop::default_instance_ = NULL;

RecentFixTop* RecentFixTop::New() const {
  return new RecentFixTop;
}

void RecentFixTop::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RecentFixTop*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(company_id_, update_time_);
    ZR_(user_gender_, top_order_);
    if (has_contact_remark()) {
      if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contact_remark_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RecentFixTop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.RecentFixTop)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 3;
      case 3: {
        if (tag == 24) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_contact_remark;
        break;
      }

      // required string contact_remark = 4;
      case 4: {
        if (tag == 34) {
         parse_contact_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contact_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_user_gender;
        break;
      }

      // required uint32 user_gender = 5;
      case 5: {
        if (tag == 40) {
         parse_user_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_gender_)));
          set_has_user_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_top_order;
        break;
      }

      // required uint32 top_order = 6;
      case 6: {
        if (tag == 48) {
         parse_top_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &top_order_)));
          set_has_top_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.RecentFixTop)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.RecentFixTop)
  return false;
#undef DO_
}

void RecentFixTop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.RecentFixTop)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint64 update_time = 3;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->update_time(), output);
  }

  // required string contact_remark = 4;
  if (has_contact_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->contact_remark(), output);
  }

  // required uint32 user_gender = 5;
  if (has_user_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->user_gender(), output);
  }

  // required uint32 top_order = 6;
  if (has_top_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->top_order(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.RecentFixTop)
}

int RecentFixTop::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint64 update_time = 3;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // required string contact_remark = 4;
    if (has_contact_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contact_remark());
    }

    // required uint32 user_gender = 5;
    if (has_user_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_gender());
    }

    // required uint32 top_order = 6;
    if (has_top_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->top_order());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecentFixTop::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RecentFixTop*>(&from));
}

void RecentFixTop::MergeFrom(const RecentFixTop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_contact_remark()) {
      set_contact_remark(from.contact_remark());
    }
    if (from.has_user_gender()) {
      set_user_gender(from.user_gender());
    }
    if (from.has_top_order()) {
      set_top_order(from.top_order());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RecentFixTop::CopyFrom(const RecentFixTop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecentFixTop::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RecentFixTop::Swap(RecentFixTop* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(update_time_, other->update_time_);
    std::swap(contact_remark_, other->contact_remark_);
    std::swap(user_gender_, other->user_gender_);
    std::swap(top_order_, other->top_order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RecentFixTop::GetTypeName() const {
  return "IM.BaseDefine.RecentFixTop";
}


// ===================================================================

#ifndef _MSC_VER
const int FrequentContactInfo::kCompanyIdFieldNumber;
const int FrequentContactInfo::kContactIdFieldNumber;
const int FrequentContactInfo::kContactNameFieldNumber;
const int FrequentContactInfo::kContactNickNameFieldNumber;
const int FrequentContactInfo::kAvatarUrlFieldNumber;
const int FrequentContactInfo::kUserGenderFieldNumber;
const int FrequentContactInfo::kLastUpdateTimeFieldNumber;
const int FrequentContactInfo::kIsDeleteFieldNumber;
#endif  // !_MSC_VER

FrequentContactInfo::FrequentContactInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.FrequentContactInfo)
}

void FrequentContactInfo::InitAsDefaultInstance() {
}

FrequentContactInfo::FrequentContactInfo(const FrequentContactInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.FrequentContactInfo)
}

void FrequentContactInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  contact_id_ = 0u;
  contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  contact_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_gender_ = 0u;
  last_update_time_ = GOOGLE_ULONGLONG(0);
  is_delete_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrequentContactInfo::~FrequentContactInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.FrequentContactInfo)
  SharedDtor();
}

void FrequentContactInfo::SharedDtor() {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_name_;
  }
  if (contact_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_nick_name_;
  }
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FrequentContactInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FrequentContactInfo& FrequentContactInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

FrequentContactInfo* FrequentContactInfo::default_instance_ = NULL;

FrequentContactInfo* FrequentContactInfo::New() const {
  return new FrequentContactInfo;
}

void FrequentContactInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FrequentContactInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(company_id_, contact_id_);
    ZR_(last_update_time_, is_delete_);
    if (has_contact_name()) {
      if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contact_name_->clear();
      }
    }
    if (has_contact_nick_name()) {
      if (contact_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        contact_nick_name_->clear();
      }
    }
    if (has_avatar_url()) {
      if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        avatar_url_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool FrequentContactInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.FrequentContactInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_contact_id;
        break;
      }

      // required uint32 contact_id = 2;
      case 2: {
        if (tag == 16) {
         parse_contact_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contact_id_)));
          set_has_contact_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_contact_name;
        break;
      }

      // required string contact_name = 3;
      case 3: {
        if (tag == 26) {
         parse_contact_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contact_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_contact_nick_name;
        break;
      }

      // required string contact_nick_name = 4;
      case 4: {
        if (tag == 34) {
         parse_contact_nick_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_contact_nick_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_avatar_url;
        break;
      }

      // required string avatar_url = 5;
      case 5: {
        if (tag == 42) {
         parse_avatar_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_avatar_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_user_gender;
        break;
      }

      // required uint32 user_gender = 6;
      case 6: {
        if (tag == 48) {
         parse_user_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_gender_)));
          set_has_user_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_last_update_time;
        break;
      }

      // required uint64 last_update_time = 7;
      case 7: {
        if (tag == 56) {
         parse_last_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &last_update_time_)));
          set_has_last_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_is_delete;
        break;
      }

      // required bool is_delete = 8;
      case 8: {
        if (tag == 64) {
         parse_is_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_delete_)));
          set_has_is_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.FrequentContactInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.FrequentContactInfo)
  return false;
#undef DO_
}

void FrequentContactInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.FrequentContactInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 contact_id = 2;
  if (has_contact_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->contact_id(), output);
  }

  // required string contact_name = 3;
  if (has_contact_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->contact_name(), output);
  }

  // required string contact_nick_name = 4;
  if (has_contact_nick_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->contact_nick_name(), output);
  }

  // required string avatar_url = 5;
  if (has_avatar_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->avatar_url(), output);
  }

  // required uint32 user_gender = 6;
  if (has_user_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->user_gender(), output);
  }

  // required uint64 last_update_time = 7;
  if (has_last_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->last_update_time(), output);
  }

  // required bool is_delete = 8;
  if (has_is_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_delete(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.FrequentContactInfo)
}

int FrequentContactInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 contact_id = 2;
    if (has_contact_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->contact_id());
    }

    // required string contact_name = 3;
    if (has_contact_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contact_name());
    }

    // required string contact_nick_name = 4;
    if (has_contact_nick_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->contact_nick_name());
    }

    // required string avatar_url = 5;
    if (has_avatar_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->avatar_url());
    }

    // required uint32 user_gender = 6;
    if (has_user_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_gender());
    }

    // required uint64 last_update_time = 7;
    if (has_last_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->last_update_time());
    }

    // required bool is_delete = 8;
    if (has_is_delete()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrequentContactInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FrequentContactInfo*>(&from));
}

void FrequentContactInfo::MergeFrom(const FrequentContactInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_contact_id()) {
      set_contact_id(from.contact_id());
    }
    if (from.has_contact_name()) {
      set_contact_name(from.contact_name());
    }
    if (from.has_contact_nick_name()) {
      set_contact_nick_name(from.contact_nick_name());
    }
    if (from.has_avatar_url()) {
      set_avatar_url(from.avatar_url());
    }
    if (from.has_user_gender()) {
      set_user_gender(from.user_gender());
    }
    if (from.has_last_update_time()) {
      set_last_update_time(from.last_update_time());
    }
    if (from.has_is_delete()) {
      set_is_delete(from.is_delete());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void FrequentContactInfo::CopyFrom(const FrequentContactInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrequentContactInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void FrequentContactInfo::Swap(FrequentContactInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(contact_id_, other->contact_id_);
    std::swap(contact_name_, other->contact_name_);
    std::swap(contact_nick_name_, other->contact_nick_name_);
    std::swap(avatar_url_, other->avatar_url_);
    std::swap(user_gender_, other->user_gender_);
    std::swap(last_update_time_, other->last_update_time_);
    std::swap(is_delete_, other->is_delete_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FrequentContactInfo::GetTypeName() const {
  return "IM.BaseDefine.FrequentContactInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UserStat::kCompanyIdFieldNumber;
const int UserStat::kUserIdFieldNumber;
const int UserStat::kStatusFieldNumber;
const int UserStat::kCustomStatusFieldNumber;
#endif  // !_MSC_VER

UserStat::UserStat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserStat)
}

void UserStat::InitAsDefaultInstance() {
}

UserStat::UserStat(const UserStat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserStat)
}

void UserStat::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  status_ = 1;
  custom_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserStat)
  SharedDtor();
}

void UserStat::SharedDtor() {
  if (custom_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete custom_status_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserStat& UserStat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserStat* UserStat::default_instance_ = NULL;

UserStat* UserStat::New() const {
  return new UserStat;
}

void UserStat::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserStat*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(company_id_, user_id_);
    status_ = 1;
    if (has_custom_status()) {
      if (custom_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        custom_status_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserStat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required .IM.BaseDefine.UserStatType status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_status(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_custom_status;
        break;
      }

      // optional string custom_status = 20;
      case 20: {
        if (tag == 162) {
         parse_custom_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_custom_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserStat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserStat)
  return false;
#undef DO_
}

void UserStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserStat)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.UserStatType status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  // optional string custom_status = 20;
  if (has_custom_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      20, this->custom_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserStat)
}

int UserStat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.UserStatType status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional string custom_status = 20;
    if (has_custom_status()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->custom_status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserStat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserStat*>(&from));
}

void UserStat::MergeFrom(const UserStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_custom_status()) {
      set_custom_status(from.custom_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserStat::CopyFrom(const UserStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void UserStat::Swap(UserStat* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(status_, other->status_);
    std::swap(custom_status_, other->custom_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserStat::GetTypeName() const {
  return "IM.BaseDefine.UserStat";
}


// ===================================================================

#ifndef _MSC_VER
const int UserIdItem::kCompanyIdFieldNumber;
const int UserIdItem::kUserIdFieldNumber;
#endif  // !_MSC_VER

UserIdItem::UserIdItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserIdItem)
}

void UserIdItem::InitAsDefaultInstance() {
}

UserIdItem::UserIdItem(const UserIdItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserIdItem)
}

void UserIdItem::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserIdItem::~UserIdItem() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserIdItem)
  SharedDtor();
}

void UserIdItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserIdItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserIdItem& UserIdItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserIdItem* UserIdItem::default_instance_ = NULL;

UserIdItem* UserIdItem::New() const {
  return new UserIdItem;
}

void UserIdItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserIdItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, user_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserIdItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserIdItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserIdItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserIdItem)
  return false;
#undef DO_
}

void UserIdItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserIdItem)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserIdItem)
}

int UserIdItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserIdItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserIdItem*>(&from));
}

void UserIdItem::MergeFrom(const UserIdItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserIdItem::CopyFrom(const UserIdItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserIdItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UserIdItem::Swap(UserIdItem* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserIdItem::GetTypeName() const {
  return "IM.BaseDefine.UserIdItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerUserStat::kCompanyIdFieldNumber;
const int ServerUserStat::kUserIdFieldNumber;
const int ServerUserStat::kStatusFieldNumber;
const int ServerUserStat::kClientTypeFieldNumber;
#endif  // !_MSC_VER

ServerUserStat::ServerUserStat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.ServerUserStat)
}

void ServerUserStat::InitAsDefaultInstance() {
}

ServerUserStat::ServerUserStat(const ServerUserStat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ServerUserStat)
}

void ServerUserStat::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  status_ = 1;
  client_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerUserStat::~ServerUserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ServerUserStat)
  SharedDtor();
}

void ServerUserStat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerUserStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerUserStat& ServerUserStat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

ServerUserStat* ServerUserStat::default_instance_ = NULL;

ServerUserStat* ServerUserStat::New() const {
  return new ServerUserStat;
}

void ServerUserStat::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ServerUserStat*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(company_id_, user_id_);
    status_ = 1;
    client_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerUserStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.ServerUserStat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required .IM.BaseDefine.UserStatType status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_status(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 4;
      case 4: {
        if (tag == 32) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.ServerUserStat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.ServerUserStat)
  return false;
#undef DO_
}

void ServerUserStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.ServerUserStat)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.UserStatType status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 4;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->client_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.ServerUserStat)
}

int ServerUserStat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.UserStatType status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // required .IM.BaseDefine.ClientType client_type = 4;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerUserStat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerUserStat*>(&from));
}

void ServerUserStat::MergeFrom(const ServerUserStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerUserStat::CopyFrom(const ServerUserStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerUserStat::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void ServerUserStat::Swap(ServerUserStat* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(status_, other->status_);
    std::swap(client_type_, other->client_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerUserStat::GetTypeName() const {
  return "IM.BaseDefine.ServerUserStat";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgFont::kFontNameFieldNumber;
const int MsgFont::kFontSizeFieldNumber;
const int MsgFont::kFontColorFieldNumber;
const int MsgFont::kFontStyleFieldNumber;
#endif  // !_MSC_VER

MsgFont::MsgFont()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.MsgFont)
}

void MsgFont::InitAsDefaultInstance() {
}

MsgFont::MsgFont(const MsgFont& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgFont)
}

void MsgFont::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  font_size_ = 0u;
  font_color_ = 0u;
  font_style_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgFont::~MsgFont() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgFont)
  SharedDtor();
}

void MsgFont::SharedDtor() {
  if (font_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete font_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgFont::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgFont& MsgFont::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

MsgFont* MsgFont::default_instance_ = NULL;

MsgFont* MsgFont::New() const {
  return new MsgFont;
}

void MsgFont::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgFont*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(font_size_, font_style_);
    if (has_font_name()) {
      if (font_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        font_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgFont::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.MsgFont)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string font_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_font_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_font_size;
        break;
      }

      // required uint32 font_size = 2;
      case 2: {
        if (tag == 16) {
         parse_font_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &font_size_)));
          set_has_font_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_font_color;
        break;
      }

      // required uint32 font_color = 3;
      case 3: {
        if (tag == 24) {
         parse_font_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &font_color_)));
          set_has_font_color();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_font_style;
        break;
      }

      // required uint32 font_style = 4;
      case 4: {
        if (tag == 32) {
         parse_font_style:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &font_style_)));
          set_has_font_style();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.MsgFont)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.MsgFont)
  return false;
#undef DO_
}

void MsgFont::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.MsgFont)
  // required string font_name = 1;
  if (has_font_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->font_name(), output);
  }

  // required uint32 font_size = 2;
  if (has_font_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->font_size(), output);
  }

  // required uint32 font_color = 3;
  if (has_font_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->font_color(), output);
  }

  // required uint32 font_style = 4;
  if (has_font_style()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->font_style(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.MsgFont)
}

int MsgFont::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string font_name = 1;
    if (has_font_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->font_name());
    }

    // required uint32 font_size = 2;
    if (has_font_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->font_size());
    }

    // required uint32 font_color = 3;
    if (has_font_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->font_color());
    }

    // required uint32 font_style = 4;
    if (has_font_style()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->font_style());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgFont::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgFont*>(&from));
}

void MsgFont::MergeFrom(const MsgFont& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_font_name()) {
      set_font_name(from.font_name());
    }
    if (from.has_font_size()) {
      set_font_size(from.font_size());
    }
    if (from.has_font_color()) {
      set_font_color(from.font_color());
    }
    if (from.has_font_style()) {
      set_font_style(from.font_style());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgFont::CopyFrom(const MsgFont& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgFont::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void MsgFont::Swap(MsgFont* other) {
  if (other != this) {
    std::swap(font_name_, other->font_name_);
    std::swap(font_size_, other->font_size_);
    std::swap(font_color_, other->font_color_);
    std::swap(font_style_, other->font_style_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgFont::GetTypeName() const {
  return "IM.BaseDefine.MsgFont";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgItem::kMsgTypeFieldNumber;
const int MsgItem::kMsgDataFieldNumber;
#endif  // !_MSC_VER

MsgItem::MsgItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.MsgItem)
}

void MsgItem::InitAsDefaultInstance() {
}

MsgItem::MsgItem(const MsgItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgItem)
}

void MsgItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  msg_type_ = 1;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgItem::~MsgItem() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgItem)
  SharedDtor();
}

void MsgItem::SharedDtor() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgItem& MsgItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

MsgItem* MsgItem::default_instance_ = NULL;

MsgItem* MsgItem::New() const {
  return new MsgItem;
}

void MsgItem::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    msg_type_ = 1;
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.MsgItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.MsgType msg_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgType_IsValid(value)) {
            set_msg_type(static_cast< ::IM::BaseDefine::MsgType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg_data;
        break;
      }

      // required string msg_data = 2;
      case 2: {
        if (tag == 18) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.MsgItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.MsgItem)
  return false;
#undef DO_
}

void MsgItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.MsgItem)
  // required .IM.BaseDefine.MsgType msg_type = 1;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->msg_type(), output);
  }

  // required string msg_data = 2;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->msg_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.MsgItem)
}

int MsgItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.MsgType msg_type = 1;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_type());
    }

    // required string msg_data = 2;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgItem*>(&from));
}

void MsgItem::MergeFrom(const MsgItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgItem::CopyFrom(const MsgItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MsgItem::Swap(MsgItem* other) {
  if (other != this) {
    std::swap(msg_type_, other->msg_type_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgItem::GetTypeName() const {
  return "IM.BaseDefine.MsgItem";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgData::kMsgIdFieldNumber;
const int MsgData::kFromCompanyIdFieldNumber;
const int MsgData::kFromUserIdFieldNumber;
const int MsgData::kToCompanyIdFieldNumber;
const int MsgData::kToUserIdFieldNumber;
const int MsgData::kSessionTypeFieldNumber;
const int MsgData::kCreateTimeFieldNumber;
const int MsgData::kMsgContentFieldNumber;
const int MsgData::kMsgFontFieldNumber;
const int MsgData::kMsgStatusFieldNumber;
const int MsgData::kMsgPropertyFieldNumber;
const int MsgData::kForcePushIdsListFieldNumber;
#endif  // !_MSC_VER

MsgData::MsgData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.MsgData)
}

void MsgData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  msg_font_ = const_cast< ::IM::BaseDefine::MsgFont*>(
      ::IM::BaseDefine::MsgFont::internal_default_instance());
#else
  msg_font_ = const_cast< ::IM::BaseDefine::MsgFont*>(&::IM::BaseDefine::MsgFont::default_instance());
#endif
}

MsgData::MsgData(const MsgData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgData)
}

void MsgData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  session_type_ = 1;
  create_time_ = GOOGLE_ULONGLONG(0);
  msg_font_ = NULL;
  msg_status_ = 0u;
  msg_property_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgData::~MsgData() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgData)
  SharedDtor();
}

void MsgData::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete msg_font_;
  }
}

void MsgData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgData& MsgData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

MsgData* MsgData::default_instance_ = NULL;

MsgData* MsgData::New() const {
  return new MsgData;
}

void MsgData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(from_company_id_, create_time_);
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_id_->clear();
      }
    }
    session_type_ = 1;
  }
  if (_has_bits_[8 / 32] & 1792) {
    if (has_msg_font()) {
      if (msg_font_ != NULL) msg_font_->::IM::BaseDefine::MsgFont::Clear();
    }
    msg_status_ = 0u;
    msg_property_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  msg_content_.Clear();
  force_push_ids_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.MsgData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string msg_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_company_id;
        break;
      }

      // required uint32 from_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 5;
      case 5: {
        if (tag == 40) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 6;
      case 6: {
        if (tag == 48) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_create_time;
        break;
      }

      // required uint64 create_time = 7;
      case 7: {
        if (tag == 56) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_msg_content;
        break;
      }

      // repeated .IM.BaseDefine.MsgItem msg_content = 8;
      case 8: {
        if (tag == 66) {
         parse_msg_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_msg_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_msg_content;
        if (input->ExpectTag(74)) goto parse_msg_font;
        break;
      }

      // required .IM.BaseDefine.MsgFont msg_font = 9;
      case 9: {
        if (tag == 74) {
         parse_msg_font:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_font()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_msg_status;
        break;
      }

      // required uint32 msg_status = 10;
      case 10: {
        if (tag == 80) {
         parse_msg_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_status_)));
          set_has_msg_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_msg_property;
        break;
      }

      // optional .IM.BaseDefine.MsgProperty msg_property = 11;
      case 11: {
        if (tag == 88) {
         parse_msg_property:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgProperty_IsValid(value)) {
            set_msg_property(static_cast< ::IM::BaseDefine::MsgProperty >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_force_push_ids_list;
        break;
      }

      // repeated .IM.BaseDefine.UserIdItem force_push_ids_list = 15;
      case 15: {
        if (tag == 122) {
         parse_force_push_ids_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_force_push_ids_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_force_push_ids_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.MsgData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.MsgData)
  return false;
#undef DO_
}

void MsgData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.MsgData)
  // required string msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->msg_id(), output);
  }

  // required uint32 from_company_id = 2;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 3;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 4;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 5;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 6;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->session_type(), output);
  }

  // required uint64 create_time = 7;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->create_time(), output);
  }

  // repeated .IM.BaseDefine.MsgItem msg_content = 8;
  for (int i = 0; i < this->msg_content_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->msg_content(i), output);
  }

  // required .IM.BaseDefine.MsgFont msg_font = 9;
  if (has_msg_font()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->msg_font(), output);
  }

  // required uint32 msg_status = 10;
  if (has_msg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->msg_status(), output);
  }

  // optional .IM.BaseDefine.MsgProperty msg_property = 11;
  if (has_msg_property()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->msg_property(), output);
  }

  // repeated .IM.BaseDefine.UserIdItem force_push_ids_list = 15;
  for (int i = 0; i < this->force_push_ids_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->force_push_ids_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.MsgData)
}

int MsgData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_id());
    }

    // required uint32 from_company_id = 2;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 3;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 4;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 5;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 6;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint64 create_time = 7;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->create_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required .IM.BaseDefine.MsgFont msg_font = 9;
    if (has_msg_font()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_font());
    }

    // required uint32 msg_status = 10;
    if (has_msg_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_status());
    }

    // optional .IM.BaseDefine.MsgProperty msg_property = 11;
    if (has_msg_property()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_property());
    }

  }
  // repeated .IM.BaseDefine.MsgItem msg_content = 8;
  total_size += 1 * this->msg_content_size();
  for (int i = 0; i < this->msg_content_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->msg_content(i));
  }

  // repeated .IM.BaseDefine.UserIdItem force_push_ids_list = 15;
  total_size += 1 * this->force_push_ids_list_size();
  for (int i = 0; i < this->force_push_ids_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->force_push_ids_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgData*>(&from));
}

void MsgData::MergeFrom(const MsgData& from) {
  GOOGLE_CHECK_NE(&from, this);
  msg_content_.MergeFrom(from.msg_content_);
  force_push_ids_list_.MergeFrom(from.force_push_ids_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_msg_font()) {
      mutable_msg_font()->::IM::BaseDefine::MsgFont::MergeFrom(from.msg_font());
    }
    if (from.has_msg_status()) {
      set_msg_status(from.msg_status());
    }
    if (from.has_msg_property()) {
      set_msg_property(from.msg_property());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgData::CopyFrom(const MsgData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000037f) != 0x0000037f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->msg_content())) return false;
  if (has_msg_font()) {
    if (!this->msg_font().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->force_push_ids_list())) return false;
  return true;
}

void MsgData::Swap(MsgData* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(create_time_, other->create_time_);
    msg_content_.Swap(&other->msg_content_);
    std::swap(msg_font_, other->msg_font_);
    std::swap(msg_status_, other->msg_status_);
    std::swap(msg_property_, other->msg_property_);
    force_push_ids_list_.Swap(&other->force_push_ids_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgData::GetTypeName() const {
  return "IM.BaseDefine.MsgData";
}


// ===================================================================

#ifndef _MSC_VER
const int OfflineMsgCntInfo::kMsgCntFieldNumber;
const int OfflineMsgCntInfo::kLastestMsgDataFieldNumber;
#endif  // !_MSC_VER

OfflineMsgCntInfo::OfflineMsgCntInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.OfflineMsgCntInfo)
}

void OfflineMsgCntInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  lastest_msg_data_ = const_cast< ::IM::BaseDefine::MsgData*>(
      ::IM::BaseDefine::MsgData::internal_default_instance());
#else
  lastest_msg_data_ = const_cast< ::IM::BaseDefine::MsgData*>(&::IM::BaseDefine::MsgData::default_instance());
#endif
}

OfflineMsgCntInfo::OfflineMsgCntInfo(const OfflineMsgCntInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineMsgCntInfo)
}

void OfflineMsgCntInfo::SharedCtor() {
  _cached_size_ = 0;
  msg_cnt_ = 0u;
  lastest_msg_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfflineMsgCntInfo::~OfflineMsgCntInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineMsgCntInfo)
  SharedDtor();
}

void OfflineMsgCntInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete lastest_msg_data_;
  }
}

void OfflineMsgCntInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OfflineMsgCntInfo& OfflineMsgCntInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

OfflineMsgCntInfo* OfflineMsgCntInfo::default_instance_ = NULL;

OfflineMsgCntInfo* OfflineMsgCntInfo::New() const {
  return new OfflineMsgCntInfo;
}

void OfflineMsgCntInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    msg_cnt_ = 0u;
    if (has_lastest_msg_data()) {
      if (lastest_msg_data_ != NULL) lastest_msg_data_->::IM::BaseDefine::MsgData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OfflineMsgCntInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.OfflineMsgCntInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 msg_cnt = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_cnt_)));
          set_has_msg_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lastest_msg_data;
        break;
      }

      // required .IM.BaseDefine.MsgData lastest_msg_data = 2;
      case 2: {
        if (tag == 18) {
         parse_lastest_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lastest_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.OfflineMsgCntInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.OfflineMsgCntInfo)
  return false;
#undef DO_
}

void OfflineMsgCntInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.OfflineMsgCntInfo)
  // required uint32 msg_cnt = 1;
  if (has_msg_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->msg_cnt(), output);
  }

  // required .IM.BaseDefine.MsgData lastest_msg_data = 2;
  if (has_lastest_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->lastest_msg_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.OfflineMsgCntInfo)
}

int OfflineMsgCntInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 msg_cnt = 1;
    if (has_msg_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_cnt());
    }

    // required .IM.BaseDefine.MsgData lastest_msg_data = 2;
    if (has_lastest_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lastest_msg_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfflineMsgCntInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OfflineMsgCntInfo*>(&from));
}

void OfflineMsgCntInfo::MergeFrom(const OfflineMsgCntInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_cnt()) {
      set_msg_cnt(from.msg_cnt());
    }
    if (from.has_lastest_msg_data()) {
      mutable_lastest_msg_data()->::IM::BaseDefine::MsgData::MergeFrom(from.lastest_msg_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OfflineMsgCntInfo::CopyFrom(const OfflineMsgCntInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineMsgCntInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_lastest_msg_data()) {
    if (!this->lastest_msg_data().IsInitialized()) return false;
  }
  return true;
}

void OfflineMsgCntInfo::Swap(OfflineMsgCntInfo* other) {
  if (other != this) {
    std::swap(msg_cnt_, other->msg_cnt_);
    std::swap(lastest_msg_data_, other->lastest_msg_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OfflineMsgCntInfo::GetTypeName() const {
  return "IM.BaseDefine.OfflineMsgCntInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupListItem::kCompanyIdFieldNumber;
const int GroupListItem::kGroupIdFieldNumber;
const int GroupListItem::kGroupTypeFieldNumber;
const int GroupListItem::kUpdateTimeFieldNumber;
#endif  // !_MSC_VER

GroupListItem::GroupListItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.GroupListItem)
}

void GroupListItem::InitAsDefaultInstance() {
}

GroupListItem::GroupListItem(const GroupListItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupListItem)
}

void GroupListItem::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  group_id_ = 0u;
  group_type_ = 1;
  update_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupListItem::~GroupListItem() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupListItem)
  SharedDtor();
}

void GroupListItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupListItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupListItem& GroupListItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

GroupListItem* GroupListItem::default_instance_ = NULL;

GroupListItem* GroupListItem::New() const {
  return new GroupListItem;
}

void GroupListItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupListItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(company_id_, update_time_);
    group_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupListItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.GroupListItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 2;
      case 2: {
        if (tag == 16) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_group_type;
        break;
      }

      // required .IM.BaseDefine.GroupType group_type = 3;
      case 3: {
        if (tag == 24) {
         parse_group_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::GroupType_IsValid(value)) {
            set_group_type(static_cast< ::IM::BaseDefine::GroupType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 4;
      case 4: {
        if (tag == 32) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.GroupListItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.GroupListItem)
  return false;
#undef DO_
}

void GroupListItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.GroupListItem)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 group_id = 2;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group_id(), output);
  }

  // required .IM.BaseDefine.GroupType group_type = 3;
  if (has_group_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->group_type(), output);
  }

  // required uint64 update_time = 4;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->update_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.GroupListItem)
}

int GroupListItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 group_id = 2;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required .IM.BaseDefine.GroupType group_type = 3;
    if (has_group_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->group_type());
    }

    // required uint64 update_time = 4;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupListItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupListItem*>(&from));
}

void GroupListItem::MergeFrom(const GroupListItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_group_type()) {
      set_group_type(from.group_type());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupListItem::CopyFrom(const GroupListItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupListItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void GroupListItem::Swap(GroupListItem* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(group_type_, other->group_type_);
    std::swap(update_time_, other->update_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupListItem::GetTypeName() const {
  return "IM.BaseDefine.GroupListItem";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupMemberItem::kCompanyIdFieldNumber;
const int GroupMemberItem::kMemberIdFieldNumber;
const int GroupMemberItem::kMemberNameFieldNumber;
const int GroupMemberItem::kMemberRoleFieldNumber;
const int GroupMemberItem::kIsDeleteFieldNumber;
#endif  // !_MSC_VER

GroupMemberItem::GroupMemberItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.GroupMemberItem)
}

void GroupMemberItem::InitAsDefaultInstance() {
}

GroupMemberItem::GroupMemberItem(const GroupMemberItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupMemberItem)
}

void GroupMemberItem::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  member_id_ = 0u;
  member_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  member_role_ = 0u;
  is_delete_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupMemberItem::~GroupMemberItem() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupMemberItem)
  SharedDtor();
}

void GroupMemberItem::SharedDtor() {
  if (member_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete member_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupMemberItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupMemberItem& GroupMemberItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

GroupMemberItem* GroupMemberItem::default_instance_ = NULL;

GroupMemberItem* GroupMemberItem::New() const {
  return new GroupMemberItem;
}

void GroupMemberItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupMemberItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(company_id_, member_id_);
    ZR_(member_role_, is_delete_);
    if (has_member_name()) {
      if (member_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        member_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupMemberItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.GroupMemberItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_member_id;
        break;
      }

      // required uint32 member_id = 2;
      case 2: {
        if (tag == 16) {
         parse_member_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &member_id_)));
          set_has_member_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_member_name;
        break;
      }

      // required string member_name = 3;
      case 3: {
        if (tag == 26) {
         parse_member_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_member_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_member_role;
        break;
      }

      // required uint32 member_role = 4;
      case 4: {
        if (tag == 32) {
         parse_member_role:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &member_role_)));
          set_has_member_role();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_is_delete;
        break;
      }

      // required bool is_delete = 5;
      case 5: {
        if (tag == 40) {
         parse_is_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_delete_)));
          set_has_is_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.GroupMemberItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.GroupMemberItem)
  return false;
#undef DO_
}

void GroupMemberItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.GroupMemberItem)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 member_id = 2;
  if (has_member_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->member_id(), output);
  }

  // required string member_name = 3;
  if (has_member_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->member_name(), output);
  }

  // required uint32 member_role = 4;
  if (has_member_role()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->member_role(), output);
  }

  // required bool is_delete = 5;
  if (has_is_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->is_delete(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.GroupMemberItem)
}

int GroupMemberItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 member_id = 2;
    if (has_member_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->member_id());
    }

    // required string member_name = 3;
    if (has_member_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->member_name());
    }

    // required uint32 member_role = 4;
    if (has_member_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->member_role());
    }

    // required bool is_delete = 5;
    if (has_is_delete()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupMemberItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupMemberItem*>(&from));
}

void GroupMemberItem::MergeFrom(const GroupMemberItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_member_id()) {
      set_member_id(from.member_id());
    }
    if (from.has_member_name()) {
      set_member_name(from.member_name());
    }
    if (from.has_member_role()) {
      set_member_role(from.member_role());
    }
    if (from.has_is_delete()) {
      set_is_delete(from.is_delete());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupMemberItem::CopyFrom(const GroupMemberItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupMemberItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void GroupMemberItem::Swap(GroupMemberItem* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(member_id_, other->member_id_);
    std::swap(member_name_, other->member_name_);
    std::swap(member_role_, other->member_role_);
    std::swap(is_delete_, other->is_delete_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupMemberItem::GetTypeName() const {
  return "IM.BaseDefine.GroupMemberItem";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupInfo::kCompanyIdFieldNumber;
const int GroupInfo::kGroupIdFieldNumber;
const int GroupInfo::kUpdateTimeFieldNumber;
const int GroupInfo::kGroupNameFieldNumber;
const int GroupInfo::kGroupAvatarFieldNumber;
const int GroupInfo::kGroupCreatorIdFieldNumber;
const int GroupInfo::kGroupTypeFieldNumber;
const int GroupInfo::kShieldStatusFieldNumber;
const int GroupInfo::kGroupMemberCountFieldNumber;
const int GroupInfo::kIsDeleteFieldNumber;
const int GroupInfo::kFixtopPriorityFieldNumber;
const int GroupInfo::kShowFieldNumber;
const int GroupInfo::kTopicFieldNumber;
const int GroupInfo::kNotDisturbFieldNumber;
#endif  // !_MSC_VER

GroupInfo::GroupInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.GroupInfo)
}

void GroupInfo::InitAsDefaultInstance() {
}

GroupInfo::GroupInfo(const GroupInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupInfo)
}

void GroupInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  group_id_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_creator_id_ = 0u;
  group_type_ = 1;
  shield_status_ = 0u;
  group_member_count_ = 0u;
  is_delete_ = false;
  fixtop_priority_ = 0u;
  show_ = 0u;
  topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  not_disturb_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupInfo)
  SharedDtor();
}

void GroupInfo::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupInfo& GroupInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

GroupInfo* GroupInfo::default_instance_ = NULL;

GroupInfo* GroupInfo::New() const {
  return new GroupInfo;
}

void GroupInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(company_id_, update_time_);
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_name_->clear();
      }
    }
    if (has_group_avatar()) {
      if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_avatar_->clear();
      }
    }
    group_creator_id_ = 0u;
    group_type_ = 1;
    shield_status_ = 0u;
  }
  if (_has_bits_[8 / 32] & 16128) {
    ZR_(group_member_count_, show_);
    ZR_(is_delete_, not_disturb_);
    if (has_topic()) {
      if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        topic_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.GroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 2;
      case 2: {
        if (tag == 16) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 3;
      case 3: {
        if (tag == 24) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_group_name;
        break;
      }

      // required string group_name = 4;
      case 4: {
        if (tag == 34) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_group_avatar;
        break;
      }

      // optional string group_avatar = 5;
      case 5: {
        if (tag == 42) {
         parse_group_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_avatar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_group_creator_id;
        break;
      }

      // required uint32 group_creator_id = 6;
      case 6: {
        if (tag == 48) {
         parse_group_creator_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_creator_id_)));
          set_has_group_creator_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_group_type;
        break;
      }

      // required .IM.BaseDefine.GroupType group_type = 7;
      case 7: {
        if (tag == 56) {
         parse_group_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::GroupType_IsValid(value)) {
            set_group_type(static_cast< ::IM::BaseDefine::GroupType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_shield_status;
        break;
      }

      // optional uint32 shield_status = 8;
      case 8: {
        if (tag == 64) {
         parse_shield_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shield_status_)));
          set_has_shield_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_group_member_count;
        break;
      }

      // required uint32 group_member_count = 9;
      case 9: {
        if (tag == 72) {
         parse_group_member_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_member_count_)));
          set_has_group_member_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_is_delete;
        break;
      }

      // optional bool is_delete = 10;
      case 10: {
        if (tag == 80) {
         parse_is_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_delete_)));
          set_has_is_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_fixtop_priority;
        break;
      }

      // optional uint32 fixtop_priority = 11;
      case 11: {
        if (tag == 88) {
         parse_fixtop_priority:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fixtop_priority_)));
          set_has_fixtop_priority();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_show;
        break;
      }

      // optional uint32 show = 12;
      case 12: {
        if (tag == 96) {
         parse_show:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &show_)));
          set_has_show();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_topic;
        break;
      }

      // optional string topic = 13;
      case 13: {
        if (tag == 106) {
         parse_topic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_topic()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_not_disturb;
        break;
      }

      // optional bool not_disturb = 14;
      case 14: {
        if (tag == 112) {
         parse_not_disturb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &not_disturb_)));
          set_has_not_disturb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.GroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.GroupInfo)
  return false;
#undef DO_
}

void GroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.GroupInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 group_id = 2;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group_id(), output);
  }

  // required uint64 update_time = 3;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->update_time(), output);
  }

  // required string group_name = 4;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->group_name(), output);
  }

  // optional string group_avatar = 5;
  if (has_group_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->group_avatar(), output);
  }

  // required uint32 group_creator_id = 6;
  if (has_group_creator_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->group_creator_id(), output);
  }

  // required .IM.BaseDefine.GroupType group_type = 7;
  if (has_group_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->group_type(), output);
  }

  // optional uint32 shield_status = 8;
  if (has_shield_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->shield_status(), output);
  }

  // required uint32 group_member_count = 9;
  if (has_group_member_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->group_member_count(), output);
  }

  // optional bool is_delete = 10;
  if (has_is_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->is_delete(), output);
  }

  // optional uint32 fixtop_priority = 11;
  if (has_fixtop_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->fixtop_priority(), output);
  }

  // optional uint32 show = 12;
  if (has_show()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->show(), output);
  }

  // optional string topic = 13;
  if (has_topic()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->topic(), output);
  }

  // optional bool not_disturb = 14;
  if (has_not_disturb()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->not_disturb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.GroupInfo)
}

int GroupInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 group_id = 2;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint64 update_time = 3;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // required string group_name = 4;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

    // optional string group_avatar = 5;
    if (has_group_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_avatar());
    }

    // required uint32 group_creator_id = 6;
    if (has_group_creator_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_creator_id());
    }

    // required .IM.BaseDefine.GroupType group_type = 7;
    if (has_group_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->group_type());
    }

    // optional uint32 shield_status = 8;
    if (has_shield_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shield_status());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 group_member_count = 9;
    if (has_group_member_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_member_count());
    }

    // optional bool is_delete = 10;
    if (has_is_delete()) {
      total_size += 1 + 1;
    }

    // optional uint32 fixtop_priority = 11;
    if (has_fixtop_priority()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fixtop_priority());
    }

    // optional uint32 show = 12;
    if (has_show()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->show());
    }

    // optional string topic = 13;
    if (has_topic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->topic());
    }

    // optional bool not_disturb = 14;
    if (has_not_disturb()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupInfo*>(&from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
    if (from.has_group_avatar()) {
      set_group_avatar(from.group_avatar());
    }
    if (from.has_group_creator_id()) {
      set_group_creator_id(from.group_creator_id());
    }
    if (from.has_group_type()) {
      set_group_type(from.group_type());
    }
    if (from.has_shield_status()) {
      set_shield_status(from.shield_status());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_group_member_count()) {
      set_group_member_count(from.group_member_count());
    }
    if (from.has_is_delete()) {
      set_is_delete(from.is_delete());
    }
    if (from.has_fixtop_priority()) {
      set_fixtop_priority(from.fixtop_priority());
    }
    if (from.has_show()) {
      set_show(from.show());
    }
    if (from.has_topic()) {
      set_topic(from.topic());
    }
    if (from.has_not_disturb()) {
      set_not_disturb(from.not_disturb());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000016f) != 0x0000016f) return false;

  return true;
}

void GroupInfo::Swap(GroupInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(update_time_, other->update_time_);
    std::swap(group_name_, other->group_name_);
    std::swap(group_avatar_, other->group_avatar_);
    std::swap(group_creator_id_, other->group_creator_id_);
    std::swap(group_type_, other->group_type_);
    std::swap(shield_status_, other->shield_status_);
    std::swap(group_member_count_, other->group_member_count_);
    std::swap(is_delete_, other->is_delete_);
    std::swap(fixtop_priority_, other->fixtop_priority_);
    std::swap(show_, other->show_);
    std::swap(topic_, other->topic_);
    std::swap(not_disturb_, other->not_disturb_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UserTokenInfo::kCompanyIdFieldNumber;
const int UserTokenInfo::kUserIdFieldNumber;
const int UserTokenInfo::kUserTypeFieldNumber;
const int UserTokenInfo::kTokenFieldNumber;
const int UserTokenInfo::kPushCountFieldNumber;
const int UserTokenInfo::kPushTypeFieldNumber;
#endif  // !_MSC_VER

UserTokenInfo::UserTokenInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserTokenInfo)
}

void UserTokenInfo::InitAsDefaultInstance() {
}

UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserTokenInfo)
}

void UserTokenInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  user_type_ = 1;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  push_count_ = 0u;
  push_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserTokenInfo)
  SharedDtor();
}

void UserTokenInfo::SharedDtor() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserTokenInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserTokenInfo& UserTokenInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserTokenInfo* UserTokenInfo::default_instance_ = NULL;

UserTokenInfo* UserTokenInfo::New() const {
  return new UserTokenInfo;
}

void UserTokenInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserTokenInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(company_id_, user_id_);
    ZR_(push_count_, push_type_);
    user_type_ = 1;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        token_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserTokenInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserTokenInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_user_type;
        break;
      }

      // required .IM.BaseDefine.ClientType user_type = 3;
      case 3: {
        if (tag == 24) {
         parse_user_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_user_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_token;
        break;
      }

      // required string token = 4;
      case 4: {
        if (tag == 34) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_push_count;
        break;
      }

      // required uint32 push_count = 5;
      case 5: {
        if (tag == 40) {
         parse_push_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &push_count_)));
          set_has_push_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_push_type;
        break;
      }

      // required uint32 push_type = 6;
      case 6: {
        if (tag == 48) {
         parse_push_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &push_type_)));
          set_has_push_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserTokenInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserTokenInfo)
  return false;
#undef DO_
}

void UserTokenInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserTokenInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType user_type = 3;
  if (has_user_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->user_type(), output);
  }

  // required string token = 4;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->token(), output);
  }

  // required uint32 push_count = 5;
  if (has_push_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->push_count(), output);
  }

  // required uint32 push_type = 6;
  if (has_push_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->push_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserTokenInfo)
}

int UserTokenInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType user_type = 3;
    if (has_user_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->user_type());
    }

    // required string token = 4;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required uint32 push_count = 5;
    if (has_push_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->push_count());
    }

    // required uint32 push_type = 6;
    if (has_push_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->push_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserTokenInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserTokenInfo*>(&from));
}

void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_type()) {
      set_user_type(from.user_type());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_push_count()) {
      set_push_count(from.push_count());
    }
    if (from.has_push_type()) {
      set_push_type(from.push_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void UserTokenInfo::Swap(UserTokenInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(user_type_, other->user_type_);
    std::swap(token_, other->token_);
    std::swap(push_count_, other->push_count_);
    std::swap(push_type_, other->push_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserTokenInfo::GetTypeName() const {
  return "IM.BaseDefine.UserTokenInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int PushResult::kUserTokenFieldNumber;
const int PushResult::kResultCodeFieldNumber;
#endif  // !_MSC_VER

PushResult::PushResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.PushResult)
}

void PushResult::InitAsDefaultInstance() {
}

PushResult::PushResult(const PushResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushResult)
}

void PushResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushResult)
  SharedDtor();
}

void PushResult::SharedDtor() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushResult& PushResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

PushResult* PushResult::default_instance_ = NULL;

PushResult* PushResult::New() const {
  return new PushResult;
}

void PushResult::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_user_token()) {
      if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_token_->clear();
      }
    }
    result_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.PushResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_token = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (tag == 16) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.PushResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.PushResult)
  return false;
#undef DO_
}

void PushResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.PushResult)
  // required string user_token = 1;
  if (has_user_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_token(), output);
  }

  // required uint32 result_code = 2;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.PushResult)
}

int PushResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_token = 1;
    if (has_user_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_token());
    }

    // required uint32 result_code = 2;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushResult*>(&from));
}

void PushResult::MergeFrom(const PushResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_token()) {
      set_user_token(from.user_token());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushResult::CopyFrom(const PushResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PushResult::Swap(PushResult* other) {
  if (other != this) {
    std::swap(user_token_, other->user_token_);
    std::swap(result_code_, other->result_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushResult::GetTypeName() const {
  return "IM.BaseDefine.PushResult";
}


// ===================================================================

#ifndef _MSC_VER
const int ShieldStatus::kCompanyIdFieldNumber;
const int ShieldStatus::kUserIdFieldNumber;
const int ShieldStatus::kGroupIdFieldNumber;
const int ShieldStatus::kShieldStatusFieldNumber;
#endif  // !_MSC_VER

ShieldStatus::ShieldStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.ShieldStatus)
}

void ShieldStatus::InitAsDefaultInstance() {
}

ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ShieldStatus)
}

void ShieldStatus::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  group_id_ = 0u;
  shield_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ShieldStatus)
  SharedDtor();
}

void ShieldStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShieldStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShieldStatus& ShieldStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

ShieldStatus* ShieldStatus::default_instance_ = NULL;

ShieldStatus* ShieldStatus::New() const {
  return new ShieldStatus;
}

void ShieldStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ShieldStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, shield_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ShieldStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.ShieldStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 3;
      case 3: {
        if (tag == 24) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_shield_status;
        break;
      }

      // required uint32 shield_status = 4;
      case 4: {
        if (tag == 32) {
         parse_shield_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shield_status_)));
          set_has_shield_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.ShieldStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.ShieldStatus)
  return false;
#undef DO_
}

void ShieldStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.ShieldStatus)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint32 group_id = 3;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->group_id(), output);
  }

  // required uint32 shield_status = 4;
  if (has_shield_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->shield_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.ShieldStatus)
}

int ShieldStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 group_id = 3;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 shield_status = 4;
    if (has_shield_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shield_status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShieldStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShieldStatus*>(&from));
}

void ShieldStatus::MergeFrom(const ShieldStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_shield_status()) {
      set_shield_status(from.shield_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void ShieldStatus::Swap(ShieldStatus* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(shield_status_, other->shield_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.ShieldStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int OfflineFileInfo::kCompanyIdFieldNumber;
const int OfflineFileInfo::kFromUserIdFieldNumber;
const int OfflineFileInfo::kTaskIdFieldNumber;
const int OfflineFileInfo::kFileNameFieldNumber;
const int OfflineFileInfo::kFileSizeFieldNumber;
#endif  // !_MSC_VER

OfflineFileInfo::OfflineFileInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.OfflineFileInfo)
}

void OfflineFileInfo::InitAsDefaultInstance() {
}

OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineFileInfo)
}

void OfflineFileInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  from_user_id_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineFileInfo)
  SharedDtor();
}

void OfflineFileInfo::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OfflineFileInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OfflineFileInfo& OfflineFileInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

OfflineFileInfo* OfflineFileInfo::default_instance_ = NULL;

OfflineFileInfo* OfflineFileInfo::New() const {
  return new OfflineFileInfo;
}

void OfflineFileInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OfflineFileInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(company_id_, from_user_id_);
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        task_id_->clear();
      }
    }
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OfflineFileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.OfflineFileInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_task_id;
        break;
      }

      // required string task_id = 3;
      case 3: {
        if (tag == 26) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }

      // required string file_name = 4;
      case 4: {
        if (tag == 34) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_file_size;
        break;
      }

      // required uint32 file_size = 5;
      case 5: {
        if (tag == 40) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.OfflineFileInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.OfflineFileInfo)
  return false;
#undef DO_
}

void OfflineFileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.OfflineFileInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required string task_id = 3;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->task_id(), output);
  }

  // required string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->file_name(), output);
  }

  // required uint32 file_size = 5;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.OfflineFileInfo)
}

int OfflineFileInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required string task_id = 3;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // required string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // required uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfflineFileInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OfflineFileInfo*>(&from));
}

void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void OfflineFileInfo::Swap(OfflineFileInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OfflineFileInfo::GetTypeName() const {
  return "IM.BaseDefine.OfflineFileInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int PushShieldStatus::kCompanyIdFieldNumber;
const int PushShieldStatus::kUserIdFieldNumber;
const int PushShieldStatus::kShieldStatusFieldNumber;
#endif  // !_MSC_VER

PushShieldStatus::PushShieldStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.PushShieldStatus)
}

void PushShieldStatus::InitAsDefaultInstance() {
}

PushShieldStatus::PushShieldStatus(const PushShieldStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushShieldStatus)
}

void PushShieldStatus::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  shield_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushShieldStatus::~PushShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushShieldStatus)
  SharedDtor();
}

void PushShieldStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushShieldStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushShieldStatus& PushShieldStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

PushShieldStatus* PushShieldStatus::default_instance_ = NULL;

PushShieldStatus* PushShieldStatus::New() const {
  return new PushShieldStatus;
}

void PushShieldStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PushShieldStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, shield_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushShieldStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.PushShieldStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shield_status;
        break;
      }

      // required uint32 shield_status = 3;
      case 3: {
        if (tag == 24) {
         parse_shield_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shield_status_)));
          set_has_shield_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.PushShieldStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.PushShieldStatus)
  return false;
#undef DO_
}

void PushShieldStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.PushShieldStatus)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint32 shield_status = 3;
  if (has_shield_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->shield_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.PushShieldStatus)
}

int PushShieldStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 shield_status = 3;
    if (has_shield_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shield_status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushShieldStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushShieldStatus*>(&from));
}

void PushShieldStatus::MergeFrom(const PushShieldStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_shield_status()) {
      set_shield_status(from.shield_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushShieldStatus::CopyFrom(const PushShieldStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushShieldStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void PushShieldStatus::Swap(PushShieldStatus* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(shield_status_, other->shield_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.PushShieldStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int IMBuddyReqInfo::kUserIdFieldNumber;
const int IMBuddyReqInfo::kCompanyIdFieldNumber;
const int IMBuddyReqInfo::kDestUserIdFieldNumber;
const int IMBuddyReqInfo::kDestCompanyIdFieldNumber;
const int IMBuddyReqInfo::kReqStatFieldNumber;
const int IMBuddyReqInfo::kReqTimeFieldNumber;
const int IMBuddyReqInfo::kRemarkFieldNumber;
#endif  // !_MSC_VER

IMBuddyReqInfo::IMBuddyReqInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IMBuddyReqInfo)
}

void IMBuddyReqInfo::InitAsDefaultInstance() {
}

IMBuddyReqInfo::IMBuddyReqInfo(const IMBuddyReqInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IMBuddyReqInfo)
}

void IMBuddyReqInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  req_stat_ = 0u;
  req_time_ = GOOGLE_ULONGLONG(0);
  remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMBuddyReqInfo::~IMBuddyReqInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IMBuddyReqInfo)
  SharedDtor();
}

void IMBuddyReqInfo::SharedDtor() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMBuddyReqInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMBuddyReqInfo& IMBuddyReqInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IMBuddyReqInfo* IMBuddyReqInfo::default_instance_ = NULL;

IMBuddyReqInfo* IMBuddyReqInfo::New() const {
  return new IMBuddyReqInfo;
}

void IMBuddyReqInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMBuddyReqInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(user_id_, req_time_);
    req_stat_ = 0u;
    if (has_remark()) {
      if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remark_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMBuddyReqInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IMBuddyReqInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_company_id;
        break;
      }

      // required uint32 company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_req_stat;
        break;
      }

      // required uint32 req_stat = 5;
      case 5: {
        if (tag == 40) {
         parse_req_stat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_stat_)));
          set_has_req_stat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_req_time;
        break;
      }

      // required uint64 req_time = 6;
      case 6: {
        if (tag == 48) {
         parse_req_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_time_)));
          set_has_req_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_remark;
        break;
      }

      // required string remark = 7;
      case 7: {
        if (tag == 58) {
         parse_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IMBuddyReqInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IMBuddyReqInfo)
  return false;
#undef DO_
}

void IMBuddyReqInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IMBuddyReqInfo)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 company_id = 2;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required uint32 req_stat = 5;
  if (has_req_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->req_stat(), output);
  }

  // required uint64 req_time = 6;
  if (has_req_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->req_time(), output);
  }

  // required string remark = 7;
  if (has_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->remark(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IMBuddyReqInfo)
}

int IMBuddyReqInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 company_id = 2;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required uint32 req_stat = 5;
    if (has_req_stat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_stat());
    }

    // required uint64 req_time = 6;
    if (has_req_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_time());
    }

    // required string remark = 7;
    if (has_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remark());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMBuddyReqInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMBuddyReqInfo*>(&from));
}

void IMBuddyReqInfo::MergeFrom(const IMBuddyReqInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_req_stat()) {
      set_req_stat(from.req_stat());
    }
    if (from.has_req_time()) {
      set_req_time(from.req_time());
    }
    if (from.has_remark()) {
      set_remark(from.remark());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMBuddyReqInfo::CopyFrom(const IMBuddyReqInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMBuddyReqInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMBuddyReqInfo::Swap(IMBuddyReqInfo* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(company_id_, other->company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(req_stat_, other->req_stat_);
    std::swap(req_time_, other->req_time_);
    std::swap(remark_, other->remark_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMBuddyReqInfo::GetTypeName() const {
  return "IM.BaseDefine.IMBuddyReqInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMSinglePullNotify::kTypeFieldNumber;
#endif  // !_MSC_VER

IMSinglePullNotify::IMSinglePullNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IMSinglePullNotify)
}

void IMSinglePullNotify::InitAsDefaultInstance() {
}

IMSinglePullNotify::IMSinglePullNotify(const IMSinglePullNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IMSinglePullNotify)
}

void IMSinglePullNotify::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMSinglePullNotify::~IMSinglePullNotify() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IMSinglePullNotify)
  SharedDtor();
}

void IMSinglePullNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMSinglePullNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMSinglePullNotify& IMSinglePullNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IMSinglePullNotify* IMSinglePullNotify::default_instance_ = NULL;

IMSinglePullNotify* IMSinglePullNotify::New() const {
  return new IMSinglePullNotify;
}

void IMSinglePullNotify::Clear() {
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMSinglePullNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IMSinglePullNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IMSinglePullNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IMSinglePullNotify)
  return false;
#undef DO_
}

void IMSinglePullNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IMSinglePullNotify)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IMSinglePullNotify)
}

int IMSinglePullNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMSinglePullNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMSinglePullNotify*>(&from));
}

void IMSinglePullNotify::MergeFrom(const IMSinglePullNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMSinglePullNotify::CopyFrom(const IMSinglePullNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMSinglePullNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMSinglePullNotify::Swap(IMSinglePullNotify* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMSinglePullNotify::GetTypeName() const {
  return "IM.BaseDefine.IMSinglePullNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGroupPullNotify::kTypeFieldNumber;
const int IMGroupPullNotify::kCompanyIdFieldNumber;
const int IMGroupPullNotify::kGroupIdFieldNumber;
#endif  // !_MSC_VER

IMGroupPullNotify::IMGroupPullNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IMGroupPullNotify)
}

void IMGroupPullNotify::InitAsDefaultInstance() {
}

IMGroupPullNotify::IMGroupPullNotify(const IMGroupPullNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IMGroupPullNotify)
}

void IMGroupPullNotify::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  company_id_ = 0u;
  group_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupPullNotify::~IMGroupPullNotify() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IMGroupPullNotify)
  SharedDtor();
}

void IMGroupPullNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupPullNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupPullNotify& IMGroupPullNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IMGroupPullNotify* IMGroupPullNotify::default_instance_ = NULL;

IMGroupPullNotify* IMGroupPullNotify::New() const {
  return new IMGroupPullNotify;
}

void IMGroupPullNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGroupPullNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(type_, group_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGroupPullNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IMGroupPullNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_company_id;
        break;
      }

      // required uint32 company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 3;
      case 3: {
        if (tag == 24) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IMGroupPullNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IMGroupPullNotify)
  return false;
#undef DO_
}

void IMGroupPullNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IMGroupPullNotify)
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint32 company_id = 2;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->company_id(), output);
  }

  // required uint32 group_id = 3;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->group_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IMGroupPullNotify)
}

int IMGroupPullNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 company_id = 2;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 group_id = 3;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupPullNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupPullNotify*>(&from));
}

void IMGroupPullNotify::MergeFrom(const IMGroupPullNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGroupPullNotify::CopyFrom(const IMGroupPullNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupPullNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMGroupPullNotify::Swap(IMGroupPullNotify* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(company_id_, other->company_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGroupPullNotify::GetTypeName() const {
  return "IM.BaseDefine.IMGroupPullNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserAuthority::kAuthIdFieldNumber;
const int IMUserAuthority::kAuthValueFieldNumber;
const int IMUserAuthority::kExtValue1FieldNumber;
const int IMUserAuthority::kExtValue2FieldNumber;
const int IMUserAuthority::kExtValue3FieldNumber;
const int IMUserAuthority::kExtValue4FieldNumber;
#endif  // !_MSC_VER

IMUserAuthority::IMUserAuthority()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IMUserAuthority)
}

void IMUserAuthority::InitAsDefaultInstance() {
}

IMUserAuthority::IMUserAuthority(const IMUserAuthority& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IMUserAuthority)
}

void IMUserAuthority::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  auth_id_ = 0u;
  auth_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ext_value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ext_value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ext_value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ext_value4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserAuthority::~IMUserAuthority() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IMUserAuthority)
  SharedDtor();
}

void IMUserAuthority::SharedDtor() {
  if (auth_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_value_;
  }
  if (ext_value1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value1_;
  }
  if (ext_value2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value2_;
  }
  if (ext_value3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value3_;
  }
  if (ext_value4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value4_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserAuthority::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserAuthority& IMUserAuthority::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IMUserAuthority* IMUserAuthority::default_instance_ = NULL;

IMUserAuthority* IMUserAuthority::New() const {
  return new IMUserAuthority;
}

void IMUserAuthority::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    auth_id_ = 0u;
    if (has_auth_value()) {
      if (auth_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        auth_value_->clear();
      }
    }
    if (has_ext_value1()) {
      if (ext_value1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ext_value1_->clear();
      }
    }
    if (has_ext_value2()) {
      if (ext_value2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ext_value2_->clear();
      }
    }
    if (has_ext_value3()) {
      if (ext_value3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ext_value3_->clear();
      }
    }
    if (has_ext_value4()) {
      if (ext_value4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ext_value4_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUserAuthority::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IMUserAuthority)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 auth_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &auth_id_)));
          set_has_auth_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_auth_value;
        break;
      }

      // required string auth_value = 2;
      case 2: {
        if (tag == 18) {
         parse_auth_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_auth_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ext_value1;
        break;
      }

      // optional string ext_value1 = 3;
      case 3: {
        if (tag == 26) {
         parse_ext_value1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ext_value1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ext_value2;
        break;
      }

      // optional string ext_value2 = 4;
      case 4: {
        if (tag == 34) {
         parse_ext_value2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ext_value2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ext_value3;
        break;
      }

      // optional string ext_value3 = 5;
      case 5: {
        if (tag == 42) {
         parse_ext_value3:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ext_value3()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ext_value4;
        break;
      }

      // optional string ext_value4 = 6;
      case 6: {
        if (tag == 50) {
         parse_ext_value4:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ext_value4()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IMUserAuthority)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IMUserAuthority)
  return false;
#undef DO_
}

void IMUserAuthority::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IMUserAuthority)
  // required uint32 auth_id = 1;
  if (has_auth_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->auth_id(), output);
  }

  // required string auth_value = 2;
  if (has_auth_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->auth_value(), output);
  }

  // optional string ext_value1 = 3;
  if (has_ext_value1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->ext_value1(), output);
  }

  // optional string ext_value2 = 4;
  if (has_ext_value2()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->ext_value2(), output);
  }

  // optional string ext_value3 = 5;
  if (has_ext_value3()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->ext_value3(), output);
  }

  // optional string ext_value4 = 6;
  if (has_ext_value4()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->ext_value4(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IMUserAuthority)
}

int IMUserAuthority::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 auth_id = 1;
    if (has_auth_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->auth_id());
    }

    // required string auth_value = 2;
    if (has_auth_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->auth_value());
    }

    // optional string ext_value1 = 3;
    if (has_ext_value1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ext_value1());
    }

    // optional string ext_value2 = 4;
    if (has_ext_value2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ext_value2());
    }

    // optional string ext_value3 = 5;
    if (has_ext_value3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ext_value3());
    }

    // optional string ext_value4 = 6;
    if (has_ext_value4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ext_value4());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserAuthority::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserAuthority*>(&from));
}

void IMUserAuthority::MergeFrom(const IMUserAuthority& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auth_id()) {
      set_auth_id(from.auth_id());
    }
    if (from.has_auth_value()) {
      set_auth_value(from.auth_value());
    }
    if (from.has_ext_value1()) {
      set_ext_value1(from.ext_value1());
    }
    if (from.has_ext_value2()) {
      set_ext_value2(from.ext_value2());
    }
    if (from.has_ext_value3()) {
      set_ext_value3(from.ext_value3());
    }
    if (from.has_ext_value4()) {
      set_ext_value4(from.ext_value4());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUserAuthority::CopyFrom(const IMUserAuthority& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserAuthority::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMUserAuthority::Swap(IMUserAuthority* other) {
  if (other != this) {
    std::swap(auth_id_, other->auth_id_);
    std::swap(auth_value_, other->auth_value_);
    std::swap(ext_value1_, other->ext_value1_);
    std::swap(ext_value2_, other->ext_value2_);
    std::swap(ext_value3_, other->ext_value3_);
    std::swap(ext_value4_, other->ext_value4_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserAuthority::GetTypeName() const {
  return "IM.BaseDefine.IMUserAuthority";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserRole::kRoleIdFieldNumber;
const int IMUserRole::kRoleNameFieldNumber;
const int IMUserRole::kAuthorityFieldNumber;
#endif  // !_MSC_VER

IMUserRole::IMUserRole()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IMUserRole)
}

void IMUserRole::InitAsDefaultInstance() {
}

IMUserRole::IMUserRole(const IMUserRole& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IMUserRole)
}

void IMUserRole::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  role_id_ = 0u;
  role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserRole::~IMUserRole() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IMUserRole)
  SharedDtor();
}

void IMUserRole::SharedDtor() {
  if (role_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserRole::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserRole& IMUserRole::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IMUserRole* IMUserRole::default_instance_ = NULL;

IMUserRole* IMUserRole::New() const {
  return new IMUserRole;
}

void IMUserRole::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    role_id_ = 0u;
    if (has_role_name()) {
      if (role_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        role_name_->clear();
      }
    }
  }
  authority_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUserRole::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IMUserRole)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 role_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &role_id_)));
          set_has_role_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_role_name;
        break;
      }

      // required string role_name = 2;
      case 2: {
        if (tag == 18) {
         parse_role_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_authority;
        break;
      }

      // repeated .IM.BaseDefine.IMUserAuthority authority = 3;
      case 3: {
        if (tag == 26) {
         parse_authority:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_authority()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_authority;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IMUserRole)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IMUserRole)
  return false;
#undef DO_
}

void IMUserRole::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IMUserRole)
  // required uint32 role_id = 1;
  if (has_role_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->role_id(), output);
  }

  // required string role_name = 2;
  if (has_role_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->role_name(), output);
  }

  // repeated .IM.BaseDefine.IMUserAuthority authority = 3;
  for (int i = 0; i < this->authority_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->authority(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IMUserRole)
}

int IMUserRole::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 role_id = 1;
    if (has_role_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->role_id());
    }

    // required string role_name = 2;
    if (has_role_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role_name());
    }

  }
  // repeated .IM.BaseDefine.IMUserAuthority authority = 3;
  total_size += 1 * this->authority_size();
  for (int i = 0; i < this->authority_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->authority(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserRole::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserRole*>(&from));
}

void IMUserRole::MergeFrom(const IMUserRole& from) {
  GOOGLE_CHECK_NE(&from, this);
  authority_.MergeFrom(from.authority_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_role_id()) {
      set_role_id(from.role_id());
    }
    if (from.has_role_name()) {
      set_role_name(from.role_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUserRole::CopyFrom(const IMUserRole& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserRole::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->authority())) return false;
  return true;
}

void IMUserRole::Swap(IMUserRole* other) {
  if (other != this) {
    std::swap(role_id_, other->role_id_);
    std::swap(role_name_, other->role_name_);
    authority_.Swap(&other->authority_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserRole::GetTypeName() const {
  return "IM.BaseDefine.IMUserRole";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

// @@protoc_insertion_point(global_scope)
