// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Router.proto

#ifndef PROTOBUF_IM_2eRouter_2eproto__INCLUDED
#define PROTOBUF_IM_2eRouter_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Server {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eRouter_2eproto();
void protobuf_AssignDesc_IM_2eRouter_2eproto();
void protobuf_ShutdownFile_IM_2eRouter_2eproto();

class PayloadInfo;
class ServerStatus;
class RegisterServerReq;
class RegisterServerRsp;
class GetAllServerStatusReq;
class GetAllServerStatusRsp;
class ServerStatusUpdateReq;
class ServerStatusUpdateRsp;
class ServerStatusPush;
class MessageHeader;
class BroadcastMessageReq;
class BroadcastMessageRsp;
class BroadcastPush;
class ConnNode;
class SrvAddrNode;
class ConnSrvStatusReport;
class ConnSrvListStatusReq;
class ConnSrvListStatusPush;
class ServerStopPush;
class ServerLocalCacheRefreshNotify;

// ===================================================================

class PayloadInfo : public ::google::protobuf::MessageLite {
 public:
  PayloadInfo();
  virtual ~PayloadInfo();

  PayloadInfo(const PayloadInfo& from);

  inline PayloadInfo& operator=(const PayloadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PayloadInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PayloadInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PayloadInfo* other);

  // implements Message ----------------------------------------------

  PayloadInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PayloadInfo& from);
  void MergeFrom(const PayloadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 resource_payload = 1;
  inline bool has_resource_payload() const;
  inline void clear_resource_payload();
  static const int kResourcePayloadFieldNumber = 1;
  inline ::google::protobuf::uint32 resource_payload() const;
  inline void set_resource_payload(::google::protobuf::uint32 value);

  // optional uint32 max_resource_num = 2;
  inline bool has_max_resource_num() const;
  inline void clear_max_resource_num();
  static const int kMaxResourceNumFieldNumber = 2;
  inline ::google::protobuf::uint32 max_resource_num() const;
  inline void set_max_resource_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.PayloadInfo)
 private:
  inline void set_has_resource_payload();
  inline void clear_has_resource_payload();
  inline void set_has_max_resource_num();
  inline void clear_has_max_resource_num();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 resource_payload_;
  ::google::protobuf::uint32 max_resource_num_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static PayloadInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatus : public ::google::protobuf::MessageLite {
 public:
  ServerStatus();
  virtual ~ServerStatus();

  ServerStatus(const ServerStatus& from);

  inline ServerStatus& operator=(const ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerStatus* other);

  // implements Message ----------------------------------------------

  ServerStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerStatus& from);
  void MergeFrom(const ServerStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 node_id() const;
  inline void set_node_id(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.ServiceID service_type = 2;
  inline int service_type_size() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 2;
  inline ::IM::BaseDefine::ServiceID service_type(int index) const;
  inline void set_service_type(int index, ::IM::BaseDefine::ServiceID value);
  inline void add_service_type(::IM::BaseDefine::ServiceID value);
  inline const ::google::protobuf::RepeatedField<int>& service_type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_service_type();

  // required string server_ip = 3;
  inline bool has_server_ip() const;
  inline void clear_server_ip();
  static const int kServerIpFieldNumber = 3;
  inline const ::std::string& server_ip() const;
  inline void set_server_ip(const ::std::string& value);
  inline void set_server_ip(const char* value);
  inline void set_server_ip(const char* value, size_t size);
  inline ::std::string* mutable_server_ip();
  inline ::std::string* release_server_ip();
  inline void set_allocated_server_ip(::std::string* server_ip);

  // required uint32 server_port = 4;
  inline bool has_server_port() const;
  inline void clear_server_port();
  static const int kServerPortFieldNumber = 4;
  inline ::google::protobuf::uint32 server_port() const;
  inline void set_server_port(::google::protobuf::uint32 value);

  // required bool is_enable = 5;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 5;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // optional .IM.Server.PayloadInfo payload = 6;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 6;
  inline const ::IM::Server::PayloadInfo& payload() const;
  inline ::IM::Server::PayloadInfo* mutable_payload();
  inline ::IM::Server::PayloadInfo* release_payload();
  inline void set_allocated_payload(::IM::Server::PayloadInfo* payload);

  // @@protoc_insertion_point(class_scope:IM.Server.ServerStatus)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_server_ip();
  inline void clear_has_server_ip();
  inline void set_has_server_port();
  inline void clear_has_server_port();
  inline void set_has_is_enable();
  inline void clear_has_is_enable();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> service_type_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 server_port_;
  ::std::string* server_ip_;
  ::IM::Server::PayloadInfo* payload_;
  bool is_enable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerStatus* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServerReq : public ::google::protobuf::MessageLite {
 public:
  RegisterServerReq();
  virtual ~RegisterServerReq();

  RegisterServerReq(const RegisterServerReq& from);

  inline RegisterServerReq& operator=(const RegisterServerReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegisterServerReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterServerReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterServerReq* other);

  // implements Message ----------------------------------------------

  RegisterServerReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterServerReq& from);
  void MergeFrom(const RegisterServerReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Server.ServerStatus current_server = 1;
  inline bool has_current_server() const;
  inline void clear_current_server();
  static const int kCurrentServerFieldNumber = 1;
  inline const ::IM::Server::ServerStatus& current_server() const;
  inline ::IM::Server::ServerStatus* mutable_current_server();
  inline ::IM::Server::ServerStatus* release_current_server();
  inline void set_allocated_current_server(::IM::Server::ServerStatus* current_server);

  // @@protoc_insertion_point(class_scope:IM.Server.RegisterServerReq)
 private:
  inline void set_has_current_server();
  inline void clear_has_current_server();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Server::ServerStatus* current_server_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static RegisterServerReq* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServerRsp : public ::google::protobuf::MessageLite {
 public:
  RegisterServerRsp();
  virtual ~RegisterServerRsp();

  RegisterServerRsp(const RegisterServerRsp& from);

  inline RegisterServerRsp& operator=(const RegisterServerRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RegisterServerRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterServerRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterServerRsp* other);

  // implements Message ----------------------------------------------

  RegisterServerRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterServerRsp& from);
  void MergeFrom(const RegisterServerRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.ResultType result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::IM::BaseDefine::ResultType result_code() const;
  inline void set_result_code(::IM::BaseDefine::ResultType value);

  // required uint32 node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline ::google::protobuf::uint32 node_id() const;
  inline void set_node_id(::google::protobuf::uint32 value);

  // required bool is_enable = 3;
  inline bool has_is_enable() const;
  inline void clear_is_enable();
  static const int kIsEnableFieldNumber = 3;
  inline bool is_enable() const;
  inline void set_is_enable(bool value);

  // @@protoc_insertion_point(class_scope:IM.Server.RegisterServerRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_is_enable();
  inline void clear_has_is_enable();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_code_;
  ::google::protobuf::uint32 node_id_;
  bool is_enable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static RegisterServerRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetAllServerStatusReq : public ::google::protobuf::MessageLite {
 public:
  GetAllServerStatusReq();
  virtual ~GetAllServerStatusReq();

  GetAllServerStatusReq(const GetAllServerStatusReq& from);

  inline GetAllServerStatusReq& operator=(const GetAllServerStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllServerStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllServerStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllServerStatusReq* other);

  // implements Message ----------------------------------------------

  GetAllServerStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllServerStatusReq& from);
  void MergeFrom(const GetAllServerStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IM.Server.GetAllServerStatusReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static GetAllServerStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class GetAllServerStatusRsp : public ::google::protobuf::MessageLite {
 public:
  GetAllServerStatusRsp();
  virtual ~GetAllServerStatusRsp();

  GetAllServerStatusRsp(const GetAllServerStatusRsp& from);

  inline GetAllServerStatusRsp& operator=(const GetAllServerStatusRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetAllServerStatusRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAllServerStatusRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAllServerStatusRsp* other);

  // implements Message ----------------------------------------------

  GetAllServerStatusRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAllServerStatusRsp& from);
  void MergeFrom(const GetAllServerStatusRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.ResultType result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::IM::BaseDefine::ResultType result_code() const;
  inline void set_result_code(::IM::BaseDefine::ResultType value);

  // repeated .IM.Server.ServerStatus server_list = 2;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 2;
  inline const ::IM::Server::ServerStatus& server_list(int index) const;
  inline ::IM::Server::ServerStatus* mutable_server_list(int index);
  inline ::IM::Server::ServerStatus* add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
      server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
      mutable_server_list();

  // @@protoc_insertion_point(class_scope:IM.Server.GetAllServerStatusRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus > server_list_;
  int result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static GetAllServerStatusRsp* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatusUpdateReq : public ::google::protobuf::MessageLite {
 public:
  ServerStatusUpdateReq();
  virtual ~ServerStatusUpdateReq();

  ServerStatusUpdateReq(const ServerStatusUpdateReq& from);

  inline ServerStatusUpdateReq& operator=(const ServerStatusUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerStatusUpdateReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerStatusUpdateReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerStatusUpdateReq* other);

  // implements Message ----------------------------------------------

  ServerStatusUpdateReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerStatusUpdateReq& from);
  void MergeFrom(const ServerStatusUpdateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 node_id() const;
  inline void set_node_id(::google::protobuf::uint32 value);

  // required uint32 resource_payload = 2;
  inline bool has_resource_payload() const;
  inline void clear_resource_payload();
  static const int kResourcePayloadFieldNumber = 2;
  inline ::google::protobuf::uint32 resource_payload() const;
  inline void set_resource_payload(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.ServerStatusUpdateReq)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_resource_payload();
  inline void clear_has_resource_payload();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 resource_payload_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerStatusUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatusUpdateRsp : public ::google::protobuf::MessageLite {
 public:
  ServerStatusUpdateRsp();
  virtual ~ServerStatusUpdateRsp();

  ServerStatusUpdateRsp(const ServerStatusUpdateRsp& from);

  inline ServerStatusUpdateRsp& operator=(const ServerStatusUpdateRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerStatusUpdateRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerStatusUpdateRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerStatusUpdateRsp* other);

  // implements Message ----------------------------------------------

  ServerStatusUpdateRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerStatusUpdateRsp& from);
  void MergeFrom(const ServerStatusUpdateRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.ResultType result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::IM::BaseDefine::ResultType result_code() const;
  inline void set_result_code(::IM::BaseDefine::ResultType value);

  // @@protoc_insertion_point(class_scope:IM.Server.ServerStatusUpdateRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerStatusUpdateRsp* default_instance_;
};
// -------------------------------------------------------------------

class ServerStatusPush : public ::google::protobuf::MessageLite {
 public:
  ServerStatusPush();
  virtual ~ServerStatusPush();

  ServerStatusPush(const ServerStatusPush& from);

  inline ServerStatusPush& operator=(const ServerStatusPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerStatusPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerStatusPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerStatusPush* other);

  // implements Message ----------------------------------------------

  ServerStatusPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerStatusPush& from);
  void MergeFrom(const ServerStatusPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.Server.ServerStatus server_list = 1;
  inline int server_list_size() const;
  inline void clear_server_list();
  static const int kServerListFieldNumber = 1;
  inline const ::IM::Server::ServerStatus& server_list(int index) const;
  inline ::IM::Server::ServerStatus* mutable_server_list(int index);
  inline ::IM::Server::ServerStatus* add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
      server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
      mutable_server_list();

  // repeated .IM.Server.ServerStatus add_server_list = 2;
  inline int add_server_list_size() const;
  inline void clear_add_server_list();
  static const int kAddServerListFieldNumber = 2;
  inline const ::IM::Server::ServerStatus& add_server_list(int index) const;
  inline ::IM::Server::ServerStatus* mutable_add_server_list(int index);
  inline ::IM::Server::ServerStatus* add_add_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
      add_server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
      mutable_add_server_list();

  // repeated .IM.Server.ServerStatus del_server_list = 3;
  inline int del_server_list_size() const;
  inline void clear_del_server_list();
  static const int kDelServerListFieldNumber = 3;
  inline const ::IM::Server::ServerStatus& del_server_list(int index) const;
  inline ::IM::Server::ServerStatus* mutable_del_server_list(int index);
  inline ::IM::Server::ServerStatus* add_del_server_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
      del_server_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
      mutable_del_server_list();

  // @@protoc_insertion_point(class_scope:IM.Server.ServerStatusPush)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus > server_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus > add_server_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus > del_server_list_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerStatusPush* default_instance_;
};
// -------------------------------------------------------------------

class MessageHeader : public ::google::protobuf::MessageLite {
 public:
  MessageHeader();
  virtual ~MessageHeader();

  MessageHeader(const MessageHeader& from);

  inline MessageHeader& operator=(const MessageHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MessageHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MessageHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MessageHeader* other);

  // implements Message ----------------------------------------------

  MessageHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MessageHeader& from);
  void MergeFrom(const MessageHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 service_type = 1;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 service_type() const;
  inline void set_service_type(::google::protobuf::uint32 value);

  // required uint32 cmd_id = 2;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd_id() const;
  inline void set_cmd_id(::google::protobuf::uint32 value);

  // required uint32 message_size = 3;
  inline bool has_message_size() const;
  inline void clear_message_size();
  static const int kMessageSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 message_size() const;
  inline void set_message_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.MessageHeader)
 private:
  inline void set_has_service_type();
  inline void clear_has_service_type();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_message_size();
  inline void clear_has_message_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 service_type_;
  ::google::protobuf::uint32 cmd_id_;
  ::google::protobuf::uint32 message_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static MessageHeader* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastMessageReq : public ::google::protobuf::MessageLite {
 public:
  BroadcastMessageReq();
  virtual ~BroadcastMessageReq();

  BroadcastMessageReq(const BroadcastMessageReq& from);

  inline BroadcastMessageReq& operator=(const BroadcastMessageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BroadcastMessageReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BroadcastMessageReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BroadcastMessageReq* other);

  // implements Message ----------------------------------------------

  BroadcastMessageReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BroadcastMessageReq& from);
  void MergeFrom(const BroadcastMessageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Server.MessageHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::IM::Server::MessageHeader& header() const;
  inline ::IM::Server::MessageHeader* mutable_header();
  inline ::IM::Server::MessageHeader* release_header();
  inline void set_allocated_header(::IM::Server::MessageHeader* header);

  // optional bytes message_serialize = 2;
  inline bool has_message_serialize() const;
  inline void clear_message_serialize();
  static const int kMessageSerializeFieldNumber = 2;
  inline const ::std::string& message_serialize() const;
  inline void set_message_serialize(const ::std::string& value);
  inline void set_message_serialize(const char* value);
  inline void set_message_serialize(const void* value, size_t size);
  inline ::std::string* mutable_message_serialize();
  inline ::std::string* release_message_serialize();
  inline void set_allocated_message_serialize(::std::string* message_serialize);

  // repeated uint32 target_services = 3;
  inline int target_services_size() const;
  inline void clear_target_services();
  static const int kTargetServicesFieldNumber = 3;
  inline ::google::protobuf::uint32 target_services(int index) const;
  inline void set_target_services(int index, ::google::protobuf::uint32 value);
  inline void add_target_services(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      target_services() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_target_services();

  // @@protoc_insertion_point(class_scope:IM.Server.BroadcastMessageReq)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_message_serialize();
  inline void clear_has_message_serialize();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Server::MessageHeader* header_;
  ::std::string* message_serialize_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > target_services_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static BroadcastMessageReq* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastMessageRsp : public ::google::protobuf::MessageLite {
 public:
  BroadcastMessageRsp();
  virtual ~BroadcastMessageRsp();

  BroadcastMessageRsp(const BroadcastMessageRsp& from);

  inline BroadcastMessageRsp& operator=(const BroadcastMessageRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BroadcastMessageRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BroadcastMessageRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BroadcastMessageRsp* other);

  // implements Message ----------------------------------------------

  BroadcastMessageRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BroadcastMessageRsp& from);
  void MergeFrom(const BroadcastMessageRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.ResultType result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::IM::BaseDefine::ResultType result_code() const;
  inline void set_result_code(::IM::BaseDefine::ResultType value);

  // @@protoc_insertion_point(class_scope:IM.Server.BroadcastMessageRsp)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static BroadcastMessageRsp* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastPush : public ::google::protobuf::MessageLite {
 public:
  BroadcastPush();
  virtual ~BroadcastPush();

  BroadcastPush(const BroadcastPush& from);

  inline BroadcastPush& operator=(const BroadcastPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const BroadcastPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BroadcastPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BroadcastPush* other);

  // implements Message ----------------------------------------------

  BroadcastPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BroadcastPush& from);
  void MergeFrom(const BroadcastPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.Server.MessageHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::IM::Server::MessageHeader& header() const;
  inline ::IM::Server::MessageHeader* mutable_header();
  inline ::IM::Server::MessageHeader* release_header();
  inline void set_allocated_header(::IM::Server::MessageHeader* header);

  // optional bytes message_serialize = 2;
  inline bool has_message_serialize() const;
  inline void clear_message_serialize();
  static const int kMessageSerializeFieldNumber = 2;
  inline const ::std::string& message_serialize() const;
  inline void set_message_serialize(const ::std::string& value);
  inline void set_message_serialize(const char* value);
  inline void set_message_serialize(const void* value, size_t size);
  inline ::std::string* mutable_message_serialize();
  inline ::std::string* release_message_serialize();
  inline void set_allocated_message_serialize(::std::string* message_serialize);

  // @@protoc_insertion_point(class_scope:IM.Server.BroadcastPush)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_message_serialize();
  inline void clear_has_message_serialize();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::Server::MessageHeader* header_;
  ::std::string* message_serialize_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static BroadcastPush* default_instance_;
};
// -------------------------------------------------------------------

class ConnNode : public ::google::protobuf::MessageLite {
 public:
  ConnNode();
  virtual ~ConnNode();

  ConnNode(const ConnNode& from);

  inline ConnNode& operator=(const ConnNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConnNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnNode* other);

  // implements Message ----------------------------------------------

  ConnNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnNode& from);
  void MergeFrom(const ConnNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint32 max_load = 3;
  inline bool has_max_load() const;
  inline void clear_max_load();
  static const int kMaxLoadFieldNumber = 3;
  inline ::google::protobuf::uint32 max_load() const;
  inline void set_max_load(::google::protobuf::uint32 value);

  // required uint32 cur_load = 4;
  inline bool has_cur_load() const;
  inline void clear_cur_load();
  static const int kCurLoadFieldNumber = 4;
  inline ::google::protobuf::uint32 cur_load() const;
  inline void set_cur_load(::google::protobuf::uint32 value);

  // required uint32 is_ssl = 5;
  inline bool has_is_ssl() const;
  inline void clear_is_ssl();
  static const int kIsSslFieldNumber = 5;
  inline ::google::protobuf::uint32 is_ssl() const;
  inline void set_is_ssl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.ConnNode)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_max_load();
  inline void clear_has_max_load();
  inline void set_has_cur_load();
  inline void clear_has_cur_load();
  inline void set_has_is_ssl();
  inline void clear_has_is_ssl();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 max_load_;
  ::google::protobuf::uint32 cur_load_;
  ::google::protobuf::uint32 is_ssl_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ConnNode* default_instance_;
};
// -------------------------------------------------------------------

class SrvAddrNode : public ::google::protobuf::MessageLite {
 public:
  SrvAddrNode();
  virtual ~SrvAddrNode();

  SrvAddrNode(const SrvAddrNode& from);

  inline SrvAddrNode& operator=(const SrvAddrNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SrvAddrNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SrvAddrNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SrvAddrNode* other);

  // implements Message ----------------------------------------------

  SrvAddrNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrvAddrNode& from);
  void MergeFrom(const SrvAddrNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint32 is_ssl = 3;
  inline bool has_is_ssl() const;
  inline void clear_is_ssl();
  static const int kIsSslFieldNumber = 3;
  inline ::google::protobuf::uint32 is_ssl() const;
  inline void set_is_ssl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.SrvAddrNode)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_is_ssl();
  inline void clear_has_is_ssl();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 is_ssl_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static SrvAddrNode* default_instance_;
};
// -------------------------------------------------------------------

class ConnSrvStatusReport : public ::google::protobuf::MessageLite {
 public:
  ConnSrvStatusReport();
  virtual ~ConnSrvStatusReport();

  ConnSrvStatusReport(const ConnSrvStatusReport& from);

  inline ConnSrvStatusReport& operator=(const ConnSrvStatusReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConnSrvStatusReport& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnSrvStatusReport* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnSrvStatusReport* other);

  // implements Message ----------------------------------------------

  ConnSrvStatusReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnSrvStatusReport& from);
  void MergeFrom(const ConnSrvStatusReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  inline int connnodelist_size() const;
  inline void clear_connnodelist();
  static const int kConnNodeListFieldNumber = 1;
  inline const ::IM::Server::ConnNode& connnodelist(int index) const;
  inline ::IM::Server::ConnNode* mutable_connnodelist(int index);
  inline ::IM::Server::ConnNode* add_connnodelist();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >&
      connnodelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >*
      mutable_connnodelist();

  // @@protoc_insertion_point(class_scope:IM.Server.ConnSrvStatusReport)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode > connnodelist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ConnSrvStatusReport* default_instance_;
};
// -------------------------------------------------------------------

class ConnSrvListStatusReq : public ::google::protobuf::MessageLite {
 public:
  ConnSrvListStatusReq();
  virtual ~ConnSrvListStatusReq();

  ConnSrvListStatusReq(const ConnSrvListStatusReq& from);

  inline ConnSrvListStatusReq& operator=(const ConnSrvListStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConnSrvListStatusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnSrvListStatusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnSrvListStatusReq* other);

  // implements Message ----------------------------------------------

  ConnSrvListStatusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnSrvListStatusReq& from);
  void MergeFrom(const ConnSrvListStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IM.Server.ConnSrvListStatusReq)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ConnSrvListStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class ConnSrvListStatusPush : public ::google::protobuf::MessageLite {
 public:
  ConnSrvListStatusPush();
  virtual ~ConnSrvListStatusPush();

  ConnSrvListStatusPush(const ConnSrvListStatusPush& from);

  inline ConnSrvListStatusPush& operator=(const ConnSrvListStatusPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ConnSrvListStatusPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnSrvListStatusPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnSrvListStatusPush* other);

  // implements Message ----------------------------------------------

  ConnSrvListStatusPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnSrvListStatusPush& from);
  void MergeFrom(const ConnSrvListStatusPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  inline int connnodelist_size() const;
  inline void clear_connnodelist();
  static const int kConnNodeListFieldNumber = 1;
  inline const ::IM::Server::ConnNode& connnodelist(int index) const;
  inline ::IM::Server::ConnNode* mutable_connnodelist(int index);
  inline ::IM::Server::ConnNode* add_connnodelist();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >&
      connnodelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >*
      mutable_connnodelist();

  // repeated .IM.Server.SrvAddrNode FileSrvList = 2;
  inline int filesrvlist_size() const;
  inline void clear_filesrvlist();
  static const int kFileSrvListFieldNumber = 2;
  inline const ::IM::Server::SrvAddrNode& filesrvlist(int index) const;
  inline ::IM::Server::SrvAddrNode* mutable_filesrvlist(int index);
  inline ::IM::Server::SrvAddrNode* add_filesrvlist();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >&
      filesrvlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >*
      mutable_filesrvlist();

  // repeated .IM.Server.SrvAddrNode CommentSrvList = 4;
  inline int commentsrvlist_size() const;
  inline void clear_commentsrvlist();
  static const int kCommentSrvListFieldNumber = 4;
  inline const ::IM::Server::SrvAddrNode& commentsrvlist(int index) const;
  inline ::IM::Server::SrvAddrNode* mutable_commentsrvlist(int index);
  inline ::IM::Server::SrvAddrNode* add_commentsrvlist();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >&
      commentsrvlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >*
      mutable_commentsrvlist();

  // @@protoc_insertion_point(class_scope:IM.Server.ConnSrvListStatusPush)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode > connnodelist_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode > filesrvlist_;
  ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode > commentsrvlist_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ConnSrvListStatusPush* default_instance_;
};
// -------------------------------------------------------------------

class ServerStopPush : public ::google::protobuf::MessageLite {
 public:
  ServerStopPush();
  virtual ~ServerStopPush();

  ServerStopPush(const ServerStopPush& from);

  inline ServerStopPush& operator=(const ServerStopPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerStopPush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerStopPush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerStopPush* other);

  // implements Message ----------------------------------------------

  ServerStopPush* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerStopPush& from);
  void MergeFrom(const ServerStopPush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IM.Server.ServerStopPush)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerStopPush* default_instance_;
};
// -------------------------------------------------------------------

class ServerLocalCacheRefreshNotify : public ::google::protobuf::MessageLite {
 public:
  ServerLocalCacheRefreshNotify();
  virtual ~ServerLocalCacheRefreshNotify();

  ServerLocalCacheRefreshNotify(const ServerLocalCacheRefreshNotify& from);

  inline ServerLocalCacheRefreshNotify& operator=(const ServerLocalCacheRefreshNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerLocalCacheRefreshNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerLocalCacheRefreshNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerLocalCacheRefreshNotify* other);

  // implements Message ----------------------------------------------

  ServerLocalCacheRefreshNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerLocalCacheRefreshNotify& from);
  void MergeFrom(const ServerLocalCacheRefreshNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 param = 1;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.Server.ServerLocalCacheRefreshNotify)
 private:
  inline void set_has_param();
  inline void clear_has_param();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 param_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eRouter_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eRouter_2eproto();
  friend void protobuf_ShutdownFile_IM_2eRouter_2eproto();

  void InitAsDefaultInstance();
  static ServerLocalCacheRefreshNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// PayloadInfo

// optional uint32 resource_payload = 1;
inline bool PayloadInfo::has_resource_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayloadInfo::set_has_resource_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayloadInfo::clear_has_resource_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayloadInfo::clear_resource_payload() {
  resource_payload_ = 0u;
  clear_has_resource_payload();
}
inline ::google::protobuf::uint32 PayloadInfo::resource_payload() const {
  // @@protoc_insertion_point(field_get:IM.Server.PayloadInfo.resource_payload)
  return resource_payload_;
}
inline void PayloadInfo::set_resource_payload(::google::protobuf::uint32 value) {
  set_has_resource_payload();
  resource_payload_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.PayloadInfo.resource_payload)
}

// optional uint32 max_resource_num = 2;
inline bool PayloadInfo::has_max_resource_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayloadInfo::set_has_max_resource_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayloadInfo::clear_has_max_resource_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayloadInfo::clear_max_resource_num() {
  max_resource_num_ = 0u;
  clear_has_max_resource_num();
}
inline ::google::protobuf::uint32 PayloadInfo::max_resource_num() const {
  // @@protoc_insertion_point(field_get:IM.Server.PayloadInfo.max_resource_num)
  return max_resource_num_;
}
inline void PayloadInfo::set_max_resource_num(::google::protobuf::uint32 value) {
  set_has_max_resource_num();
  max_resource_num_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.PayloadInfo.max_resource_num)
}

// -------------------------------------------------------------------

// ServerStatus

// required uint32 node_id = 1;
inline bool ServerStatus::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStatus::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStatus::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStatus::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 ServerStatus::node_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.node_id)
  return node_id_;
}
inline void ServerStatus::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatus.node_id)
}

// repeated .IM.BaseDefine.ServiceID service_type = 2;
inline int ServerStatus::service_type_size() const {
  return service_type_.size();
}
inline void ServerStatus::clear_service_type() {
  service_type_.Clear();
}
inline ::IM::BaseDefine::ServiceID ServerStatus::service_type(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.service_type)
  return static_cast< ::IM::BaseDefine::ServiceID >(service_type_.Get(index));
}
inline void ServerStatus::set_service_type(int index, ::IM::BaseDefine::ServiceID value) {
  assert(::IM::BaseDefine::ServiceID_IsValid(value));
  service_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatus.service_type)
}
inline void ServerStatus::add_service_type(::IM::BaseDefine::ServiceID value) {
  assert(::IM::BaseDefine::ServiceID_IsValid(value));
  service_type_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Server.ServerStatus.service_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ServerStatus::service_type() const {
  // @@protoc_insertion_point(field_list:IM.Server.ServerStatus.service_type)
  return service_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ServerStatus::mutable_service_type() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ServerStatus.service_type)
  return &service_type_;
}

// required string server_ip = 3;
inline bool ServerStatus::has_server_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerStatus::set_has_server_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerStatus::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerStatus::clear_server_ip() {
  if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ip_->clear();
  }
  clear_has_server_ip();
}
inline const ::std::string& ServerStatus::server_ip() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.server_ip)
  return *server_ip_;
}
inline void ServerStatus::set_server_ip(const ::std::string& value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatus.server_ip)
}
inline void ServerStatus::set_server_ip(const char* value) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Server.ServerStatus.server_ip)
}
inline void ServerStatus::set_server_ip(const char* value, size_t size) {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ip_ = new ::std::string;
  }
  server_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Server.ServerStatus.server_ip)
}
inline ::std::string* ServerStatus::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.ServerStatus.server_ip)
  return server_ip_;
}
inline ::std::string* ServerStatus::release_server_ip() {
  clear_has_server_ip();
  if (server_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_ip_;
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerStatus::set_allocated_server_ip(::std::string* server_ip) {
  if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_ip_;
  }
  if (server_ip) {
    set_has_server_ip();
    server_ip_ = server_ip;
  } else {
    clear_has_server_ip();
    server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.ServerStatus.server_ip)
}

// required uint32 server_port = 4;
inline bool ServerStatus::has_server_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerStatus::set_has_server_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerStatus::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerStatus::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 ServerStatus::server_port() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.server_port)
  return server_port_;
}
inline void ServerStatus::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatus.server_port)
}

// required bool is_enable = 5;
inline bool ServerStatus::has_is_enable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerStatus::set_has_is_enable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerStatus::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerStatus::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool ServerStatus::is_enable() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.is_enable)
  return is_enable_;
}
inline void ServerStatus::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatus.is_enable)
}

// optional .IM.Server.PayloadInfo payload = 6;
inline bool ServerStatus::has_payload() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerStatus::set_has_payload() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerStatus::clear_has_payload() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerStatus::clear_payload() {
  if (payload_ != NULL) payload_->::IM::Server::PayloadInfo::Clear();
  clear_has_payload();
}
inline const ::IM::Server::PayloadInfo& ServerStatus::payload() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatus.payload)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return payload_ != NULL ? *payload_ : *default_instance().payload_;
#else
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
#endif
}
inline ::IM::Server::PayloadInfo* ServerStatus::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) payload_ = new ::IM::Server::PayloadInfo;
  // @@protoc_insertion_point(field_mutable:IM.Server.ServerStatus.payload)
  return payload_;
}
inline ::IM::Server::PayloadInfo* ServerStatus::release_payload() {
  clear_has_payload();
  ::IM::Server::PayloadInfo* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void ServerStatus::set_allocated_payload(::IM::Server::PayloadInfo* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.ServerStatus.payload)
}

// -------------------------------------------------------------------

// RegisterServerReq

// required .IM.Server.ServerStatus current_server = 1;
inline bool RegisterServerReq::has_current_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterServerReq::set_has_current_server() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterServerReq::clear_has_current_server() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterServerReq::clear_current_server() {
  if (current_server_ != NULL) current_server_->::IM::Server::ServerStatus::Clear();
  clear_has_current_server();
}
inline const ::IM::Server::ServerStatus& RegisterServerReq::current_server() const {
  // @@protoc_insertion_point(field_get:IM.Server.RegisterServerReq.current_server)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return current_server_ != NULL ? *current_server_ : *default_instance().current_server_;
#else
  return current_server_ != NULL ? *current_server_ : *default_instance_->current_server_;
#endif
}
inline ::IM::Server::ServerStatus* RegisterServerReq::mutable_current_server() {
  set_has_current_server();
  if (current_server_ == NULL) current_server_ = new ::IM::Server::ServerStatus;
  // @@protoc_insertion_point(field_mutable:IM.Server.RegisterServerReq.current_server)
  return current_server_;
}
inline ::IM::Server::ServerStatus* RegisterServerReq::release_current_server() {
  clear_has_current_server();
  ::IM::Server::ServerStatus* temp = current_server_;
  current_server_ = NULL;
  return temp;
}
inline void RegisterServerReq::set_allocated_current_server(::IM::Server::ServerStatus* current_server) {
  delete current_server_;
  current_server_ = current_server;
  if (current_server) {
    set_has_current_server();
  } else {
    clear_has_current_server();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.RegisterServerReq.current_server)
}

// -------------------------------------------------------------------

// RegisterServerRsp

// required .IM.BaseDefine.ResultType result_code = 1;
inline bool RegisterServerRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterServerRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterServerRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterServerRsp::clear_result_code() {
  result_code_ = 1;
  clear_has_result_code();
}
inline ::IM::BaseDefine::ResultType RegisterServerRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.RegisterServerRsp.result_code)
  return static_cast< ::IM::BaseDefine::ResultType >(result_code_);
}
inline void RegisterServerRsp::set_result_code(::IM::BaseDefine::ResultType value) {
  assert(::IM::BaseDefine::ResultType_IsValid(value));
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.RegisterServerRsp.result_code)
}

// required uint32 node_id = 2;
inline bool RegisterServerRsp::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterServerRsp::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterServerRsp::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterServerRsp::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 RegisterServerRsp::node_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.RegisterServerRsp.node_id)
  return node_id_;
}
inline void RegisterServerRsp::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.RegisterServerRsp.node_id)
}

// required bool is_enable = 3;
inline bool RegisterServerRsp::has_is_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterServerRsp::set_has_is_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterServerRsp::clear_has_is_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterServerRsp::clear_is_enable() {
  is_enable_ = false;
  clear_has_is_enable();
}
inline bool RegisterServerRsp::is_enable() const {
  // @@protoc_insertion_point(field_get:IM.Server.RegisterServerRsp.is_enable)
  return is_enable_;
}
inline void RegisterServerRsp::set_is_enable(bool value) {
  set_has_is_enable();
  is_enable_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.RegisterServerRsp.is_enable)
}

// -------------------------------------------------------------------

// GetAllServerStatusReq

// -------------------------------------------------------------------

// GetAllServerStatusRsp

// required .IM.BaseDefine.ResultType result_code = 1;
inline bool GetAllServerStatusRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllServerStatusRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllServerStatusRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllServerStatusRsp::clear_result_code() {
  result_code_ = 1;
  clear_has_result_code();
}
inline ::IM::BaseDefine::ResultType GetAllServerStatusRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.GetAllServerStatusRsp.result_code)
  return static_cast< ::IM::BaseDefine::ResultType >(result_code_);
}
inline void GetAllServerStatusRsp::set_result_code(::IM::BaseDefine::ResultType value) {
  assert(::IM::BaseDefine::ResultType_IsValid(value));
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.GetAllServerStatusRsp.result_code)
}

// repeated .IM.Server.ServerStatus server_list = 2;
inline int GetAllServerStatusRsp::server_list_size() const {
  return server_list_.size();
}
inline void GetAllServerStatusRsp::clear_server_list() {
  server_list_.Clear();
}
inline const ::IM::Server::ServerStatus& GetAllServerStatusRsp::server_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.GetAllServerStatusRsp.server_list)
  return server_list_.Get(index);
}
inline ::IM::Server::ServerStatus* GetAllServerStatusRsp::mutable_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.GetAllServerStatusRsp.server_list)
  return server_list_.Mutable(index);
}
inline ::IM::Server::ServerStatus* GetAllServerStatusRsp::add_server_list() {
  // @@protoc_insertion_point(field_add:IM.Server.GetAllServerStatusRsp.server_list)
  return server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
GetAllServerStatusRsp::server_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.GetAllServerStatusRsp.server_list)
  return server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
GetAllServerStatusRsp::mutable_server_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.GetAllServerStatusRsp.server_list)
  return &server_list_;
}

// -------------------------------------------------------------------

// ServerStatusUpdateReq

// required uint32 node_id = 1;
inline bool ServerStatusUpdateReq::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStatusUpdateReq::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStatusUpdateReq::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStatusUpdateReq::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 ServerStatusUpdateReq::node_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusUpdateReq.node_id)
  return node_id_;
}
inline void ServerStatusUpdateReq::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatusUpdateReq.node_id)
}

// required uint32 resource_payload = 2;
inline bool ServerStatusUpdateReq::has_resource_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStatusUpdateReq::set_has_resource_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStatusUpdateReq::clear_has_resource_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStatusUpdateReq::clear_resource_payload() {
  resource_payload_ = 0u;
  clear_has_resource_payload();
}
inline ::google::protobuf::uint32 ServerStatusUpdateReq::resource_payload() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusUpdateReq.resource_payload)
  return resource_payload_;
}
inline void ServerStatusUpdateReq::set_resource_payload(::google::protobuf::uint32 value) {
  set_has_resource_payload();
  resource_payload_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatusUpdateReq.resource_payload)
}

// -------------------------------------------------------------------

// ServerStatusUpdateRsp

// required .IM.BaseDefine.ResultType result_code = 1;
inline bool ServerStatusUpdateRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStatusUpdateRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStatusUpdateRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStatusUpdateRsp::clear_result_code() {
  result_code_ = 1;
  clear_has_result_code();
}
inline ::IM::BaseDefine::ResultType ServerStatusUpdateRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusUpdateRsp.result_code)
  return static_cast< ::IM::BaseDefine::ResultType >(result_code_);
}
inline void ServerStatusUpdateRsp::set_result_code(::IM::BaseDefine::ResultType value) {
  assert(::IM::BaseDefine::ResultType_IsValid(value));
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerStatusUpdateRsp.result_code)
}

// -------------------------------------------------------------------

// ServerStatusPush

// repeated .IM.Server.ServerStatus server_list = 1;
inline int ServerStatusPush::server_list_size() const {
  return server_list_.size();
}
inline void ServerStatusPush::clear_server_list() {
  server_list_.Clear();
}
inline const ::IM::Server::ServerStatus& ServerStatusPush::server_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusPush.server_list)
  return server_list_.Get(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::mutable_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ServerStatusPush.server_list)
  return server_list_.Mutable(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::add_server_list() {
  // @@protoc_insertion_point(field_add:IM.Server.ServerStatusPush.server_list)
  return server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
ServerStatusPush::server_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.ServerStatusPush.server_list)
  return server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
ServerStatusPush::mutable_server_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ServerStatusPush.server_list)
  return &server_list_;
}

// repeated .IM.Server.ServerStatus add_server_list = 2;
inline int ServerStatusPush::add_server_list_size() const {
  return add_server_list_.size();
}
inline void ServerStatusPush::clear_add_server_list() {
  add_server_list_.Clear();
}
inline const ::IM::Server::ServerStatus& ServerStatusPush::add_server_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusPush.add_server_list)
  return add_server_list_.Get(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::mutable_add_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ServerStatusPush.add_server_list)
  return add_server_list_.Mutable(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::add_add_server_list() {
  // @@protoc_insertion_point(field_add:IM.Server.ServerStatusPush.add_server_list)
  return add_server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
ServerStatusPush::add_server_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.ServerStatusPush.add_server_list)
  return add_server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
ServerStatusPush::mutable_add_server_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ServerStatusPush.add_server_list)
  return &add_server_list_;
}

// repeated .IM.Server.ServerStatus del_server_list = 3;
inline int ServerStatusPush::del_server_list_size() const {
  return del_server_list_.size();
}
inline void ServerStatusPush::clear_del_server_list() {
  del_server_list_.Clear();
}
inline const ::IM::Server::ServerStatus& ServerStatusPush::del_server_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerStatusPush.del_server_list)
  return del_server_list_.Get(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::mutable_del_server_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ServerStatusPush.del_server_list)
  return del_server_list_.Mutable(index);
}
inline ::IM::Server::ServerStatus* ServerStatusPush::add_del_server_list() {
  // @@protoc_insertion_point(field_add:IM.Server.ServerStatusPush.del_server_list)
  return del_server_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >&
ServerStatusPush::del_server_list() const {
  // @@protoc_insertion_point(field_list:IM.Server.ServerStatusPush.del_server_list)
  return del_server_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ServerStatus >*
ServerStatusPush::mutable_del_server_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ServerStatusPush.del_server_list)
  return &del_server_list_;
}

// -------------------------------------------------------------------

// MessageHeader

// required uint32 service_type = 1;
inline bool MessageHeader::has_service_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageHeader::set_has_service_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageHeader::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageHeader::clear_service_type() {
  service_type_ = 0u;
  clear_has_service_type();
}
inline ::google::protobuf::uint32 MessageHeader::service_type() const {
  // @@protoc_insertion_point(field_get:IM.Server.MessageHeader.service_type)
  return service_type_;
}
inline void MessageHeader::set_service_type(::google::protobuf::uint32 value) {
  set_has_service_type();
  service_type_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.MessageHeader.service_type)
}

// required uint32 cmd_id = 2;
inline bool MessageHeader::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageHeader::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageHeader::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageHeader::clear_cmd_id() {
  cmd_id_ = 0u;
  clear_has_cmd_id();
}
inline ::google::protobuf::uint32 MessageHeader::cmd_id() const {
  // @@protoc_insertion_point(field_get:IM.Server.MessageHeader.cmd_id)
  return cmd_id_;
}
inline void MessageHeader::set_cmd_id(::google::protobuf::uint32 value) {
  set_has_cmd_id();
  cmd_id_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.MessageHeader.cmd_id)
}

// required uint32 message_size = 3;
inline bool MessageHeader::has_message_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageHeader::set_has_message_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageHeader::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageHeader::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
inline ::google::protobuf::uint32 MessageHeader::message_size() const {
  // @@protoc_insertion_point(field_get:IM.Server.MessageHeader.message_size)
  return message_size_;
}
inline void MessageHeader::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.MessageHeader.message_size)
}

// -------------------------------------------------------------------

// BroadcastMessageReq

// required .IM.Server.MessageHeader header = 1;
inline bool BroadcastMessageReq::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessageReq::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessageReq::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessageReq::clear_header() {
  if (header_ != NULL) header_->::IM::Server::MessageHeader::Clear();
  clear_has_header();
}
inline const ::IM::Server::MessageHeader& BroadcastMessageReq::header() const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastMessageReq.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::IM::Server::MessageHeader* BroadcastMessageReq::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::IM::Server::MessageHeader;
  // @@protoc_insertion_point(field_mutable:IM.Server.BroadcastMessageReq.header)
  return header_;
}
inline ::IM::Server::MessageHeader* BroadcastMessageReq::release_header() {
  clear_has_header();
  ::IM::Server::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BroadcastMessageReq::set_allocated_header(::IM::Server::MessageHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.BroadcastMessageReq.header)
}

// optional bytes message_serialize = 2;
inline bool BroadcastMessageReq::has_message_serialize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastMessageReq::set_has_message_serialize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastMessageReq::clear_has_message_serialize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastMessageReq::clear_message_serialize() {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_->clear();
  }
  clear_has_message_serialize();
}
inline const ::std::string& BroadcastMessageReq::message_serialize() const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastMessageReq.message_serialize)
  return *message_serialize_;
}
inline void BroadcastMessageReq::set_message_serialize(const ::std::string& value) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Server.BroadcastMessageReq.message_serialize)
}
inline void BroadcastMessageReq::set_message_serialize(const char* value) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Server.BroadcastMessageReq.message_serialize)
}
inline void BroadcastMessageReq::set_message_serialize(const void* value, size_t size) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Server.BroadcastMessageReq.message_serialize)
}
inline ::std::string* BroadcastMessageReq::mutable_message_serialize() {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.BroadcastMessageReq.message_serialize)
  return message_serialize_;
}
inline ::std::string* BroadcastMessageReq::release_message_serialize() {
  clear_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_serialize_;
    message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BroadcastMessageReq::set_allocated_message_serialize(::std::string* message_serialize) {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_serialize_;
  }
  if (message_serialize) {
    set_has_message_serialize();
    message_serialize_ = message_serialize;
  } else {
    clear_has_message_serialize();
    message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.BroadcastMessageReq.message_serialize)
}

// repeated uint32 target_services = 3;
inline int BroadcastMessageReq::target_services_size() const {
  return target_services_.size();
}
inline void BroadcastMessageReq::clear_target_services() {
  target_services_.Clear();
}
inline ::google::protobuf::uint32 BroadcastMessageReq::target_services(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastMessageReq.target_services)
  return target_services_.Get(index);
}
inline void BroadcastMessageReq::set_target_services(int index, ::google::protobuf::uint32 value) {
  target_services_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.Server.BroadcastMessageReq.target_services)
}
inline void BroadcastMessageReq::add_target_services(::google::protobuf::uint32 value) {
  target_services_.Add(value);
  // @@protoc_insertion_point(field_add:IM.Server.BroadcastMessageReq.target_services)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BroadcastMessageReq::target_services() const {
  // @@protoc_insertion_point(field_list:IM.Server.BroadcastMessageReq.target_services)
  return target_services_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BroadcastMessageReq::mutable_target_services() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.BroadcastMessageReq.target_services)
  return &target_services_;
}

// -------------------------------------------------------------------

// BroadcastMessageRsp

// required .IM.BaseDefine.ResultType result_code = 1;
inline bool BroadcastMessageRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessageRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessageRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessageRsp::clear_result_code() {
  result_code_ = 1;
  clear_has_result_code();
}
inline ::IM::BaseDefine::ResultType BroadcastMessageRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastMessageRsp.result_code)
  return static_cast< ::IM::BaseDefine::ResultType >(result_code_);
}
inline void BroadcastMessageRsp::set_result_code(::IM::BaseDefine::ResultType value) {
  assert(::IM::BaseDefine::ResultType_IsValid(value));
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.BroadcastMessageRsp.result_code)
}

// -------------------------------------------------------------------

// BroadcastPush

// required .IM.Server.MessageHeader header = 1;
inline bool BroadcastPush::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastPush::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastPush::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastPush::clear_header() {
  if (header_ != NULL) header_->::IM::Server::MessageHeader::Clear();
  clear_has_header();
}
inline const ::IM::Server::MessageHeader& BroadcastPush::header() const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastPush.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::IM::Server::MessageHeader* BroadcastPush::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::IM::Server::MessageHeader;
  // @@protoc_insertion_point(field_mutable:IM.Server.BroadcastPush.header)
  return header_;
}
inline ::IM::Server::MessageHeader* BroadcastPush::release_header() {
  clear_has_header();
  ::IM::Server::MessageHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BroadcastPush::set_allocated_header(::IM::Server::MessageHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.BroadcastPush.header)
}

// optional bytes message_serialize = 2;
inline bool BroadcastPush::has_message_serialize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastPush::set_has_message_serialize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastPush::clear_has_message_serialize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastPush::clear_message_serialize() {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_->clear();
  }
  clear_has_message_serialize();
}
inline const ::std::string& BroadcastPush::message_serialize() const {
  // @@protoc_insertion_point(field_get:IM.Server.BroadcastPush.message_serialize)
  return *message_serialize_;
}
inline void BroadcastPush::set_message_serialize(const ::std::string& value) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Server.BroadcastPush.message_serialize)
}
inline void BroadcastPush::set_message_serialize(const char* value) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Server.BroadcastPush.message_serialize)
}
inline void BroadcastPush::set_message_serialize(const void* value, size_t size) {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  message_serialize_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Server.BroadcastPush.message_serialize)
}
inline ::std::string* BroadcastPush::mutable_message_serialize() {
  set_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_serialize_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.BroadcastPush.message_serialize)
  return message_serialize_;
}
inline ::std::string* BroadcastPush::release_message_serialize() {
  clear_has_message_serialize();
  if (message_serialize_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_serialize_;
    message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BroadcastPush::set_allocated_message_serialize(::std::string* message_serialize) {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_serialize_;
  }
  if (message_serialize) {
    set_has_message_serialize();
    message_serialize_ = message_serialize;
  } else {
    clear_has_message_serialize();
    message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.BroadcastPush.message_serialize)
}

// -------------------------------------------------------------------

// ConnNode

// required string ip = 1;
inline bool ConnNode::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnNode::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnNode::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnNode::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ConnNode::ip() const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnNode.ip)
  return *ip_;
}
inline void ConnNode::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Server.ConnNode.ip)
}
inline void ConnNode::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Server.ConnNode.ip)
}
inline void ConnNode::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Server.ConnNode.ip)
}
inline ::std::string* ConnNode::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.ConnNode.ip)
  return ip_;
}
inline ::std::string* ConnNode::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ConnNode::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.ConnNode.ip)
}

// required uint32 port = 2;
inline bool ConnNode::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnNode::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnNode::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnNode::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ConnNode::port() const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnNode.port)
  return port_;
}
inline void ConnNode::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ConnNode.port)
}

// required uint32 max_load = 3;
inline bool ConnNode::has_max_load() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnNode::set_has_max_load() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnNode::clear_has_max_load() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnNode::clear_max_load() {
  max_load_ = 0u;
  clear_has_max_load();
}
inline ::google::protobuf::uint32 ConnNode::max_load() const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnNode.max_load)
  return max_load_;
}
inline void ConnNode::set_max_load(::google::protobuf::uint32 value) {
  set_has_max_load();
  max_load_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ConnNode.max_load)
}

// required uint32 cur_load = 4;
inline bool ConnNode::has_cur_load() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnNode::set_has_cur_load() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnNode::clear_has_cur_load() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnNode::clear_cur_load() {
  cur_load_ = 0u;
  clear_has_cur_load();
}
inline ::google::protobuf::uint32 ConnNode::cur_load() const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnNode.cur_load)
  return cur_load_;
}
inline void ConnNode::set_cur_load(::google::protobuf::uint32 value) {
  set_has_cur_load();
  cur_load_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ConnNode.cur_load)
}

// required uint32 is_ssl = 5;
inline bool ConnNode::has_is_ssl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnNode::set_has_is_ssl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnNode::clear_has_is_ssl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnNode::clear_is_ssl() {
  is_ssl_ = 0u;
  clear_has_is_ssl();
}
inline ::google::protobuf::uint32 ConnNode::is_ssl() const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnNode.is_ssl)
  return is_ssl_;
}
inline void ConnNode::set_is_ssl(::google::protobuf::uint32 value) {
  set_has_is_ssl();
  is_ssl_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ConnNode.is_ssl)
}

// -------------------------------------------------------------------

// SrvAddrNode

// required string ip = 1;
inline bool SrvAddrNode::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrvAddrNode::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrvAddrNode::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrvAddrNode::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& SrvAddrNode::ip() const {
  // @@protoc_insertion_point(field_get:IM.Server.SrvAddrNode.ip)
  return *ip_;
}
inline void SrvAddrNode::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Server.SrvAddrNode.ip)
}
inline void SrvAddrNode::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Server.SrvAddrNode.ip)
}
inline void SrvAddrNode::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Server.SrvAddrNode.ip)
}
inline ::std::string* SrvAddrNode::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Server.SrvAddrNode.ip)
  return ip_;
}
inline ::std::string* SrvAddrNode::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SrvAddrNode::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Server.SrvAddrNode.ip)
}

// required uint32 port = 2;
inline bool SrvAddrNode::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrvAddrNode::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrvAddrNode::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrvAddrNode::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 SrvAddrNode::port() const {
  // @@protoc_insertion_point(field_get:IM.Server.SrvAddrNode.port)
  return port_;
}
inline void SrvAddrNode::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.SrvAddrNode.port)
}

// required uint32 is_ssl = 3;
inline bool SrvAddrNode::has_is_ssl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrvAddrNode::set_has_is_ssl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrvAddrNode::clear_has_is_ssl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrvAddrNode::clear_is_ssl() {
  is_ssl_ = 0u;
  clear_has_is_ssl();
}
inline ::google::protobuf::uint32 SrvAddrNode::is_ssl() const {
  // @@protoc_insertion_point(field_get:IM.Server.SrvAddrNode.is_ssl)
  return is_ssl_;
}
inline void SrvAddrNode::set_is_ssl(::google::protobuf::uint32 value) {
  set_has_is_ssl();
  is_ssl_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.SrvAddrNode.is_ssl)
}

// -------------------------------------------------------------------

// ConnSrvStatusReport

// repeated .IM.Server.ConnNode ConnNodeList = 1;
inline int ConnSrvStatusReport::connnodelist_size() const {
  return connnodelist_.size();
}
inline void ConnSrvStatusReport::clear_connnodelist() {
  connnodelist_.Clear();
}
inline const ::IM::Server::ConnNode& ConnSrvStatusReport::connnodelist(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnSrvStatusReport.ConnNodeList)
  return connnodelist_.Get(index);
}
inline ::IM::Server::ConnNode* ConnSrvStatusReport::mutable_connnodelist(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ConnSrvStatusReport.ConnNodeList)
  return connnodelist_.Mutable(index);
}
inline ::IM::Server::ConnNode* ConnSrvStatusReport::add_connnodelist() {
  // @@protoc_insertion_point(field_add:IM.Server.ConnSrvStatusReport.ConnNodeList)
  return connnodelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >&
ConnSrvStatusReport::connnodelist() const {
  // @@protoc_insertion_point(field_list:IM.Server.ConnSrvStatusReport.ConnNodeList)
  return connnodelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >*
ConnSrvStatusReport::mutable_connnodelist() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ConnSrvStatusReport.ConnNodeList)
  return &connnodelist_;
}

// -------------------------------------------------------------------

// ConnSrvListStatusReq

// -------------------------------------------------------------------

// ConnSrvListStatusPush

// repeated .IM.Server.ConnNode ConnNodeList = 1;
inline int ConnSrvListStatusPush::connnodelist_size() const {
  return connnodelist_.size();
}
inline void ConnSrvListStatusPush::clear_connnodelist() {
  connnodelist_.Clear();
}
inline const ::IM::Server::ConnNode& ConnSrvListStatusPush::connnodelist(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnSrvListStatusPush.ConnNodeList)
  return connnodelist_.Get(index);
}
inline ::IM::Server::ConnNode* ConnSrvListStatusPush::mutable_connnodelist(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ConnSrvListStatusPush.ConnNodeList)
  return connnodelist_.Mutable(index);
}
inline ::IM::Server::ConnNode* ConnSrvListStatusPush::add_connnodelist() {
  // @@protoc_insertion_point(field_add:IM.Server.ConnSrvListStatusPush.ConnNodeList)
  return connnodelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >&
ConnSrvListStatusPush::connnodelist() const {
  // @@protoc_insertion_point(field_list:IM.Server.ConnSrvListStatusPush.ConnNodeList)
  return connnodelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::ConnNode >*
ConnSrvListStatusPush::mutable_connnodelist() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ConnSrvListStatusPush.ConnNodeList)
  return &connnodelist_;
}

// repeated .IM.Server.SrvAddrNode FileSrvList = 2;
inline int ConnSrvListStatusPush::filesrvlist_size() const {
  return filesrvlist_.size();
}
inline void ConnSrvListStatusPush::clear_filesrvlist() {
  filesrvlist_.Clear();
}
inline const ::IM::Server::SrvAddrNode& ConnSrvListStatusPush::filesrvlist(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnSrvListStatusPush.FileSrvList)
  return filesrvlist_.Get(index);
}
inline ::IM::Server::SrvAddrNode* ConnSrvListStatusPush::mutable_filesrvlist(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ConnSrvListStatusPush.FileSrvList)
  return filesrvlist_.Mutable(index);
}
inline ::IM::Server::SrvAddrNode* ConnSrvListStatusPush::add_filesrvlist() {
  // @@protoc_insertion_point(field_add:IM.Server.ConnSrvListStatusPush.FileSrvList)
  return filesrvlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >&
ConnSrvListStatusPush::filesrvlist() const {
  // @@protoc_insertion_point(field_list:IM.Server.ConnSrvListStatusPush.FileSrvList)
  return filesrvlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >*
ConnSrvListStatusPush::mutable_filesrvlist() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ConnSrvListStatusPush.FileSrvList)
  return &filesrvlist_;
}

// repeated .IM.Server.SrvAddrNode CommentSrvList = 4;
inline int ConnSrvListStatusPush::commentsrvlist_size() const {
  return commentsrvlist_.size();
}
inline void ConnSrvListStatusPush::clear_commentsrvlist() {
  commentsrvlist_.Clear();
}
inline const ::IM::Server::SrvAddrNode& ConnSrvListStatusPush::commentsrvlist(int index) const {
  // @@protoc_insertion_point(field_get:IM.Server.ConnSrvListStatusPush.CommentSrvList)
  return commentsrvlist_.Get(index);
}
inline ::IM::Server::SrvAddrNode* ConnSrvListStatusPush::mutable_commentsrvlist(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Server.ConnSrvListStatusPush.CommentSrvList)
  return commentsrvlist_.Mutable(index);
}
inline ::IM::Server::SrvAddrNode* ConnSrvListStatusPush::add_commentsrvlist() {
  // @@protoc_insertion_point(field_add:IM.Server.ConnSrvListStatusPush.CommentSrvList)
  return commentsrvlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >&
ConnSrvListStatusPush::commentsrvlist() const {
  // @@protoc_insertion_point(field_list:IM.Server.ConnSrvListStatusPush.CommentSrvList)
  return commentsrvlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::Server::SrvAddrNode >*
ConnSrvListStatusPush::mutable_commentsrvlist() {
  // @@protoc_insertion_point(field_mutable_list:IM.Server.ConnSrvListStatusPush.CommentSrvList)
  return &commentsrvlist_;
}

// -------------------------------------------------------------------

// ServerStopPush

// -------------------------------------------------------------------

// ServerLocalCacheRefreshNotify

// required uint32 param = 1;
inline bool ServerLocalCacheRefreshNotify::has_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerLocalCacheRefreshNotify::set_has_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerLocalCacheRefreshNotify::clear_has_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerLocalCacheRefreshNotify::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 ServerLocalCacheRefreshNotify::param() const {
  // @@protoc_insertion_point(field_get:IM.Server.ServerLocalCacheRefreshNotify.param)
  return param_;
}
inline void ServerLocalCacheRefreshNotify::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:IM.Server.ServerLocalCacheRefreshNotify.param)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eRouter_2eproto__INCLUDED
