// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Server.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Server.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Server {

void protobuf_ShutdownFile_IM_2eServer_2eproto() {
  delete RecentContactItem::default_instance_;
  delete IMStopReceivePacket::default_instance_;
  delete IMValidateReq::default_instance_;
  delete IMValidateRsp::default_instance_;
  delete IMGetDeviceTokenReq::default_instance_;
  delete IMGetDeviceTokenRsp::default_instance_;
  delete IMRoleSet::default_instance_;
  delete IMOnlineUserInfo::default_instance_;
  delete IMMsgServInfo::default_instance_;
  delete IMUserStatusUpdate::default_instance_;
  delete IMUserCntUpdate::default_instance_;
  delete IMServerKickUser::default_instance_;
  delete IMServerPCLoginStatusNotify::default_instance_;
  delete IMPushToUserReq::default_instance_;
  delete IMPushToUserRsp::default_instance_;
  delete IMGroupGetShieldReq::default_instance_;
  delete IMGroupGetShieldRsp::default_instance_;
  delete IMFileTransferReq::default_instance_;
  delete IMFileTransferRsp::default_instance_;
  delete IMFileServerIPReq::default_instance_;
  delete IMFileServerIPRsp::default_instance_;
  delete IMGetBuddyConfigReq::default_instance_;
  delete IMGetBuddyConfigRsp::default_instance_;
  delete IMLoginToSqlReq::default_instance_;
  delete IMLoginToSqlRsp::default_instance_;
  delete IMUsrStatBroadcoast::default_instance_;
  delete IMOptBuddyStorageReq::default_instance_;
  delete IMOptBuddyStorageRsp::default_instance_;
  delete IMBuddyStorageReq::default_instance_;
  delete IMBuddyStorageRsp::default_instance_;
  delete IMRecentContactStorageReq::default_instance_;
  delete IMRecentContactStorageRsp::default_instance_;
  delete IMBuddyReqInfoStorage::default_instance_;
  delete IMDelRecentContactReq::default_instance_;
  delete IMAlterPswdReq::default_instance_;
  delete IMAlterPswdRsp::default_instance_;
  delete IMReportOnlineInfo::default_instance_;
  delete IMReportChatInfo::default_instance_;
  delete IMGetUserRoleReq::default_instance_;
  delete IMUserRoleAuthorityRsp::default_instance_;
  delete IMAuthenticationReq::default_instance_;
  delete IMAuthenticationRsp::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eServer_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eServer_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  RecentContactItem::default_instance_ = new RecentContactItem();
  IMStopReceivePacket::default_instance_ = new IMStopReceivePacket();
  IMValidateReq::default_instance_ = new IMValidateReq();
  IMValidateRsp::default_instance_ = new IMValidateRsp();
  IMGetDeviceTokenReq::default_instance_ = new IMGetDeviceTokenReq();
  IMGetDeviceTokenRsp::default_instance_ = new IMGetDeviceTokenRsp();
  IMRoleSet::default_instance_ = new IMRoleSet();
  IMOnlineUserInfo::default_instance_ = new IMOnlineUserInfo();
  IMMsgServInfo::default_instance_ = new IMMsgServInfo();
  IMUserStatusUpdate::default_instance_ = new IMUserStatusUpdate();
  IMUserCntUpdate::default_instance_ = new IMUserCntUpdate();
  IMServerKickUser::default_instance_ = new IMServerKickUser();
  IMServerPCLoginStatusNotify::default_instance_ = new IMServerPCLoginStatusNotify();
  IMPushToUserReq::default_instance_ = new IMPushToUserReq();
  IMPushToUserRsp::default_instance_ = new IMPushToUserRsp();
  IMGroupGetShieldReq::default_instance_ = new IMGroupGetShieldReq();
  IMGroupGetShieldRsp::default_instance_ = new IMGroupGetShieldRsp();
  IMFileTransferReq::default_instance_ = new IMFileTransferReq();
  IMFileTransferRsp::default_instance_ = new IMFileTransferRsp();
  IMFileServerIPReq::default_instance_ = new IMFileServerIPReq();
  IMFileServerIPRsp::default_instance_ = new IMFileServerIPRsp();
  IMGetBuddyConfigReq::default_instance_ = new IMGetBuddyConfigReq();
  IMGetBuddyConfigRsp::default_instance_ = new IMGetBuddyConfigRsp();
  IMLoginToSqlReq::default_instance_ = new IMLoginToSqlReq();
  IMLoginToSqlRsp::default_instance_ = new IMLoginToSqlRsp();
  IMUsrStatBroadcoast::default_instance_ = new IMUsrStatBroadcoast();
  IMOptBuddyStorageReq::default_instance_ = new IMOptBuddyStorageReq();
  IMOptBuddyStorageRsp::default_instance_ = new IMOptBuddyStorageRsp();
  IMBuddyStorageReq::default_instance_ = new IMBuddyStorageReq();
  IMBuddyStorageRsp::default_instance_ = new IMBuddyStorageRsp();
  IMRecentContactStorageReq::default_instance_ = new IMRecentContactStorageReq();
  IMRecentContactStorageRsp::default_instance_ = new IMRecentContactStorageRsp();
  IMBuddyReqInfoStorage::default_instance_ = new IMBuddyReqInfoStorage();
  IMDelRecentContactReq::default_instance_ = new IMDelRecentContactReq();
  IMAlterPswdReq::default_instance_ = new IMAlterPswdReq();
  IMAlterPswdRsp::default_instance_ = new IMAlterPswdRsp();
  IMReportOnlineInfo::default_instance_ = new IMReportOnlineInfo();
  IMReportChatInfo::default_instance_ = new IMReportChatInfo();
  IMGetUserRoleReq::default_instance_ = new IMGetUserRoleReq();
  IMUserRoleAuthorityRsp::default_instance_ = new IMUserRoleAuthorityRsp();
  IMAuthenticationReq::default_instance_ = new IMAuthenticationReq();
  IMAuthenticationRsp::default_instance_ = new IMAuthenticationRsp();
  RecentContactItem::default_instance_->InitAsDefaultInstance();
  IMStopReceivePacket::default_instance_->InitAsDefaultInstance();
  IMValidateReq::default_instance_->InitAsDefaultInstance();
  IMValidateRsp::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenReq::default_instance_->InitAsDefaultInstance();
  IMGetDeviceTokenRsp::default_instance_->InitAsDefaultInstance();
  IMRoleSet::default_instance_->InitAsDefaultInstance();
  IMOnlineUserInfo::default_instance_->InitAsDefaultInstance();
  IMMsgServInfo::default_instance_->InitAsDefaultInstance();
  IMUserStatusUpdate::default_instance_->InitAsDefaultInstance();
  IMUserCntUpdate::default_instance_->InitAsDefaultInstance();
  IMServerKickUser::default_instance_->InitAsDefaultInstance();
  IMServerPCLoginStatusNotify::default_instance_->InitAsDefaultInstance();
  IMPushToUserReq::default_instance_->InitAsDefaultInstance();
  IMPushToUserRsp::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldReq::default_instance_->InitAsDefaultInstance();
  IMGroupGetShieldRsp::default_instance_->InitAsDefaultInstance();
  IMFileTransferReq::default_instance_->InitAsDefaultInstance();
  IMFileTransferRsp::default_instance_->InitAsDefaultInstance();
  IMFileServerIPReq::default_instance_->InitAsDefaultInstance();
  IMFileServerIPRsp::default_instance_->InitAsDefaultInstance();
  IMGetBuddyConfigReq::default_instance_->InitAsDefaultInstance();
  IMGetBuddyConfigRsp::default_instance_->InitAsDefaultInstance();
  IMLoginToSqlReq::default_instance_->InitAsDefaultInstance();
  IMLoginToSqlRsp::default_instance_->InitAsDefaultInstance();
  IMUsrStatBroadcoast::default_instance_->InitAsDefaultInstance();
  IMOptBuddyStorageReq::default_instance_->InitAsDefaultInstance();
  IMOptBuddyStorageRsp::default_instance_->InitAsDefaultInstance();
  IMBuddyStorageReq::default_instance_->InitAsDefaultInstance();
  IMBuddyStorageRsp::default_instance_->InitAsDefaultInstance();
  IMRecentContactStorageReq::default_instance_->InitAsDefaultInstance();
  IMRecentContactStorageRsp::default_instance_->InitAsDefaultInstance();
  IMBuddyReqInfoStorage::default_instance_->InitAsDefaultInstance();
  IMDelRecentContactReq::default_instance_->InitAsDefaultInstance();
  IMAlterPswdReq::default_instance_->InitAsDefaultInstance();
  IMAlterPswdRsp::default_instance_->InitAsDefaultInstance();
  IMReportOnlineInfo::default_instance_->InitAsDefaultInstance();
  IMReportChatInfo::default_instance_->InitAsDefaultInstance();
  IMGetUserRoleReq::default_instance_->InitAsDefaultInstance();
  IMUserRoleAuthorityRsp::default_instance_->InitAsDefaultInstance();
  IMAuthenticationReq::default_instance_->InitAsDefaultInstance();
  IMAuthenticationRsp::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eServer_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eServer_2eproto_once_);
void protobuf_AddDesc_IM_2eServer_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eServer_2eproto_once_,
                 &protobuf_AddDesc_IM_2eServer_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eServer_2eproto {
  StaticDescriptorInitializer_IM_2eServer_2eproto() {
    protobuf_AddDesc_IM_2eServer_2eproto();
  }
} static_descriptor_initializer_IM_2eServer_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int RecentContactItem::kCompanyIdFieldNumber;
const int RecentContactItem::kUserIdFieldNumber;
const int RecentContactItem::kUpdateTimeFieldNumber;
#endif  // !_MSC_VER

RecentContactItem::RecentContactItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.RecentContactItem)
}

void RecentContactItem::InitAsDefaultInstance() {
}

RecentContactItem::RecentContactItem(const RecentContactItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.RecentContactItem)
}

void RecentContactItem::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecentContactItem::~RecentContactItem() {
  // @@protoc_insertion_point(destructor:IM.Server.RecentContactItem)
  SharedDtor();
}

void RecentContactItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RecentContactItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RecentContactItem& RecentContactItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

RecentContactItem* RecentContactItem::default_instance_ = NULL;

RecentContactItem* RecentContactItem::New() const {
  return new RecentContactItem;
}

void RecentContactItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RecentContactItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, update_time_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RecentContactItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.RecentContactItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 3;
      case 3: {
        if (tag == 24) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.RecentContactItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.RecentContactItem)
  return false;
#undef DO_
}

void RecentContactItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.RecentContactItem)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint64 update_time = 3;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->update_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.RecentContactItem)
}

int RecentContactItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint64 update_time = 3;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecentContactItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RecentContactItem*>(&from));
}

void RecentContactItem::MergeFrom(const RecentContactItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RecentContactItem::CopyFrom(const RecentContactItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecentContactItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RecentContactItem::Swap(RecentContactItem* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(update_time_, other->update_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RecentContactItem::GetTypeName() const {
  return "IM.Server.RecentContactItem";
}


// ===================================================================

#ifndef _MSC_VER
const int IMStopReceivePacket::kResultFieldNumber;
#endif  // !_MSC_VER

IMStopReceivePacket::IMStopReceivePacket()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMStopReceivePacket)
}

void IMStopReceivePacket::InitAsDefaultInstance() {
}

IMStopReceivePacket::IMStopReceivePacket(const IMStopReceivePacket& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMStopReceivePacket)
}

void IMStopReceivePacket::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMStopReceivePacket::~IMStopReceivePacket() {
  // @@protoc_insertion_point(destructor:IM.Server.IMStopReceivePacket)
  SharedDtor();
}

void IMStopReceivePacket::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMStopReceivePacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMStopReceivePacket& IMStopReceivePacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMStopReceivePacket* IMStopReceivePacket::default_instance_ = NULL;

IMStopReceivePacket* IMStopReceivePacket::New() const {
  return new IMStopReceivePacket;
}

void IMStopReceivePacket::Clear() {
  result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMStopReceivePacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMStopReceivePacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMStopReceivePacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMStopReceivePacket)
  return false;
#undef DO_
}

void IMStopReceivePacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMStopReceivePacket)
  // required uint32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMStopReceivePacket)
}

int IMStopReceivePacket::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMStopReceivePacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMStopReceivePacket*>(&from));
}

void IMStopReceivePacket::MergeFrom(const IMStopReceivePacket& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMStopReceivePacket::CopyFrom(const IMStopReceivePacket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMStopReceivePacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMStopReceivePacket::Swap(IMStopReceivePacket* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMStopReceivePacket::GetTypeName() const {
  return "IM.Server.IMStopReceivePacket";
}


// ===================================================================

#ifndef _MSC_VER
const int IMValidateReq::kUserNameFieldNumber;
const int IMValidateReq::kPasswordFieldNumber;
const int IMValidateReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMValidateReq::IMValidateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateReq)
}

void IMValidateReq::InitAsDefaultInstance() {
}

IMValidateReq::IMValidateReq(const IMValidateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateReq)
}

void IMValidateReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateReq::~IMValidateReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateReq)
  SharedDtor();
}

void IMValidateReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMValidateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateReq& IMValidateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateReq* IMValidateReq::default_instance_ = NULL;

IMValidateReq* IMValidateReq::New() const {
  return new IMValidateReq;
}

void IMValidateReq::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMValidateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required string password = 2;
      case 2: {
        if (tag == 18) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateReq)
  return false;
#undef DO_
}

void IMValidateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateReq)
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateReq)
}

int IMValidateReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateReq*>(&from));
}

void IMValidateReq::MergeFrom(const IMValidateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMValidateReq::CopyFrom(const IMValidateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMValidateReq::Swap(IMValidateReq* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(password_, other->password_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMValidateReq::GetTypeName() const {
  return "IM.Server.IMValidateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMValidateRsp::kUserNameFieldNumber;
const int IMValidateRsp::kResultCodeFieldNumber;
const int IMValidateRsp::kResultStringFieldNumber;
const int IMValidateRsp::kUserInfoFieldNumber;
const int IMValidateRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMValidateRsp::IMValidateRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateRsp)
}

void IMValidateRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
#else
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(&::IM::BaseDefine::UserInfo::default_instance());
#endif
}

IMValidateRsp::IMValidateRsp(const IMValidateRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateRsp)
}

void IMValidateRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_code_ = 0u;
  result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_info_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMValidateRsp::~IMValidateRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateRsp)
  SharedDtor();
}

void IMValidateRsp::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_string_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_info_;
  }
}

void IMValidateRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMValidateRsp& IMValidateRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMValidateRsp* IMValidateRsp::default_instance_ = NULL;

IMValidateRsp* IMValidateRsp::New() const {
  return new IMValidateRsp;
}

void IMValidateRsp::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    result_code_ = 0u;
    if (has_result_string()) {
      if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        result_string_->clear();
      }
    }
    if (has_user_info()) {
      if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMValidateRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (tag == 16) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_result_string;
        break;
      }

      // optional string result_string = 3;
      case 3: {
        if (tag == 26) {
         parse_result_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_info;
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 4;
      case 4: {
        if (tag == 34) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateRsp)
  return false;
#undef DO_
}

void IMValidateRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateRsp)
  // required string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required uint32 result_code = 2;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  // optional string result_string = 3;
  if (has_result_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->result_string(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 4;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->user_info(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateRsp)
}

int IMValidateRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required uint32 result_code = 2;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // optional string result_string = 3;
    if (has_result_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result_string());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 4;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_info());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMValidateRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateRsp*>(&from));
}

void IMValidateRsp::MergeFrom(const IMValidateRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_result_string()) {
      set_result_string(from.result_string());
    }
    if (from.has_user_info()) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMValidateRsp::CopyFrom(const IMValidateRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_user_info()) {
    if (!this->user_info().IsInitialized()) return false;
  }
  return true;
}

void IMValidateRsp::Swap(IMValidateRsp* other) {
  if (other != this) {
    std::swap(user_name_, other->user_name_);
    std::swap(result_code_, other->result_code_);
    std::swap(result_string_, other->result_string_);
    std::swap(user_info_, other->user_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMValidateRsp::GetTypeName() const {
  return "IM.Server.IMValidateRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeviceTokenReq::kUserIdFieldNumber;
const int IMGetDeviceTokenReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetDeviceTokenReq::IMGetDeviceTokenReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenReq)
}

void IMGetDeviceTokenReq::InitAsDefaultInstance() {
}

IMGetDeviceTokenReq::IMGetDeviceTokenReq(const IMGetDeviceTokenReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenReq)
}

void IMGetDeviceTokenReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenReq::~IMGetDeviceTokenReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenReq)
  SharedDtor();
}

void IMGetDeviceTokenReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenReq& IMGetDeviceTokenReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenReq* IMGetDeviceTokenReq::default_instance_ = NULL;

IMGetDeviceTokenReq* IMGetDeviceTokenReq::New() const {
  return new IMGetDeviceTokenReq;
}

void IMGetDeviceTokenReq::Clear() {
  if (has_attach_data()) {
    if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      attach_data_->clear();
    }
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetDeviceTokenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_user_id())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenReq)
  return false;
#undef DO_
}

void IMGetDeviceTokenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenReq)
  // repeated uint32 user_id = 1;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenReq)
}

int IMGetDeviceTokenReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 user_id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenReq*>(&from));
}

void IMGetDeviceTokenReq::MergeFrom(const IMGetDeviceTokenReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetDeviceTokenReq::CopyFrom(const IMGetDeviceTokenReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenReq::IsInitialized() const {

  return true;
}

void IMGetDeviceTokenReq::Swap(IMGetDeviceTokenReq* other) {
  if (other != this) {
    user_id_.Swap(&other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeviceTokenReq::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetDeviceTokenRsp::kUserTokenInfoFieldNumber;
const int IMGetDeviceTokenRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenRsp)
}

void IMGetDeviceTokenRsp::InitAsDefaultInstance() {
}

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp(const IMGetDeviceTokenRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenRsp)
}

void IMGetDeviceTokenRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetDeviceTokenRsp::~IMGetDeviceTokenRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenRsp)
  SharedDtor();
}

void IMGetDeviceTokenRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetDeviceTokenRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetDeviceTokenRsp& IMGetDeviceTokenRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::default_instance_ = NULL;

IMGetDeviceTokenRsp* IMGetDeviceTokenRsp::New() const {
  return new IMGetDeviceTokenRsp;
}

void IMGetDeviceTokenRsp::Clear() {
  if (has_attach_data()) {
    if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      attach_data_->clear();
    }
  }
  user_token_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetDeviceTokenRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
      case 1: {
        if (tag == 10) {
         parse_user_token_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_token_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_user_token_info;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenRsp)
  return false;
#undef DO_
}

void IMGetDeviceTokenRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenRsp)
  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  for (int i = 0; i < this->user_token_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_token_info(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenRsp)
}

int IMGetDeviceTokenRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  total_size += 1 * this->user_token_info_size();
  for (int i = 0; i < this->user_token_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_info(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetDeviceTokenRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenRsp*>(&from));
}

void IMGetDeviceTokenRsp::MergeFrom(const IMGetDeviceTokenRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_token_info_.MergeFrom(from.user_token_info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetDeviceTokenRsp::CopyFrom(const IMGetDeviceTokenRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_info())) return false;
  return true;
}

void IMGetDeviceTokenRsp::Swap(IMGetDeviceTokenRsp* other) {
  if (other != this) {
    user_token_info_.Swap(&other->user_token_info_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetDeviceTokenRsp::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRoleSet::kMasterFieldNumber;
#endif  // !_MSC_VER

IMRoleSet::IMRoleSet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMRoleSet)
}

void IMRoleSet::InitAsDefaultInstance() {
}

IMRoleSet::IMRoleSet(const IMRoleSet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMRoleSet)
}

void IMRoleSet::SharedCtor() {
  _cached_size_ = 0;
  master_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRoleSet::~IMRoleSet() {
  // @@protoc_insertion_point(destructor:IM.Server.IMRoleSet)
  SharedDtor();
}

void IMRoleSet::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMRoleSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRoleSet& IMRoleSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMRoleSet* IMRoleSet::default_instance_ = NULL;

IMRoleSet* IMRoleSet::New() const {
  return new IMRoleSet;
}

void IMRoleSet::Clear() {
  master_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRoleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMRoleSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 master = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &master_)));
          set_has_master();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMRoleSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMRoleSet)
  return false;
#undef DO_
}

void IMRoleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMRoleSet)
  // required uint32 master = 1;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->master(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMRoleSet)
}

int IMRoleSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 master = 1;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->master());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRoleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRoleSet*>(&from));
}

void IMRoleSet::MergeFrom(const IMRoleSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_master()) {
      set_master(from.master());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRoleSet::CopyFrom(const IMRoleSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRoleSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMRoleSet::Swap(IMRoleSet* other) {
  if (other != this) {
    std::swap(master_, other->master_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRoleSet::GetTypeName() const {
  return "IM.Server.IMRoleSet";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOnlineUserInfo::kUserStatListFieldNumber;
#endif  // !_MSC_VER

IMOnlineUserInfo::IMOnlineUserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMOnlineUserInfo)
}

void IMOnlineUserInfo::InitAsDefaultInstance() {
}

IMOnlineUserInfo::IMOnlineUserInfo(const IMOnlineUserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMOnlineUserInfo)
}

void IMOnlineUserInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOnlineUserInfo::~IMOnlineUserInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMOnlineUserInfo)
  SharedDtor();
}

void IMOnlineUserInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOnlineUserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOnlineUserInfo& IMOnlineUserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMOnlineUserInfo* IMOnlineUserInfo::default_instance_ = NULL;

IMOnlineUserInfo* IMOnlineUserInfo::New() const {
  return new IMOnlineUserInfo;
}

void IMOnlineUserInfo::Clear() {
  user_stat_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOnlineUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMOnlineUserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
      case 1: {
        if (tag == 10) {
         parse_user_stat_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_stat_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_user_stat_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMOnlineUserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMOnlineUserInfo)
  return false;
#undef DO_
}

void IMOnlineUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMOnlineUserInfo)
  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  for (int i = 0; i < this->user_stat_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->user_stat_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMOnlineUserInfo)
}

int IMOnlineUserInfo::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  total_size += 1 * this->user_stat_list_size();
  for (int i = 0; i < this->user_stat_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_stat_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOnlineUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOnlineUserInfo*>(&from));
}

void IMOnlineUserInfo::MergeFrom(const IMOnlineUserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_stat_list_.MergeFrom(from.user_stat_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOnlineUserInfo::CopyFrom(const IMOnlineUserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOnlineUserInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->user_stat_list())) return false;
  return true;
}

void IMOnlineUserInfo::Swap(IMOnlineUserInfo* other) {
  if (other != this) {
    user_stat_list_.Swap(&other->user_stat_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOnlineUserInfo::GetTypeName() const {
  return "IM.Server.IMOnlineUserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgServInfo::kIp1FieldNumber;
const int IMMsgServInfo::kIp2FieldNumber;
const int IMMsgServInfo::kPortFieldNumber;
const int IMMsgServInfo::kMaxConnCntFieldNumber;
const int IMMsgServInfo::kCurConnCntFieldNumber;
const int IMMsgServInfo::kHostNameFieldNumber;
#endif  // !_MSC_VER

IMMsgServInfo::IMMsgServInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMMsgServInfo)
}

void IMMsgServInfo::InitAsDefaultInstance() {
}

IMMsgServInfo::IMMsgServInfo(const IMMsgServInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMMsgServInfo)
}

void IMMsgServInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  max_conn_cnt_ = 0u;
  cur_conn_cnt_ = 0u;
  host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgServInfo::~IMMsgServInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMMsgServInfo)
  SharedDtor();
}

void IMMsgServInfo::SharedDtor() {
  if (ip1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip1_;
  }
  if (ip2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip2_;
  }
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgServInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgServInfo& IMMsgServInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMMsgServInfo* IMMsgServInfo::default_instance_ = NULL;

IMMsgServInfo* IMMsgServInfo::New() const {
  return new IMMsgServInfo;
}

void IMMsgServInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMMsgServInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(port_, max_conn_cnt_);
    if (has_ip1()) {
      if (ip1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip1_->clear();
      }
    }
    if (has_ip2()) {
      if (ip2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip2_->clear();
      }
    }
    cur_conn_cnt_ = 0u;
    if (has_host_name()) {
      if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        host_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsgServInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMMsgServInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip1 = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip2;
        break;
      }

      // required string ip2 = 2;
      case 2: {
        if (tag == 18) {
         parse_ip2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required uint32 port = 3;
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_max_conn_cnt;
        break;
      }

      // required uint32 max_conn_cnt = 4;
      case 4: {
        if (tag == 32) {
         parse_max_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_conn_cnt_)));
          set_has_max_conn_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_cur_conn_cnt;
        break;
      }

      // required uint32 cur_conn_cnt = 5;
      case 5: {
        if (tag == 40) {
         parse_cur_conn_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_conn_cnt_)));
          set_has_cur_conn_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_host_name;
        break;
      }

      // required string host_name = 6;
      case 6: {
        if (tag == 50) {
         parse_host_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMMsgServInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMMsgServInfo)
  return false;
#undef DO_
}

void IMMsgServInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMMsgServInfo)
  // required string ip1 = 1;
  if (has_ip1()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip1(), output);
  }

  // required string ip2 = 2;
  if (has_ip2()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip2(), output);
  }

  // required uint32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // required uint32 max_conn_cnt = 4;
  if (has_max_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->max_conn_cnt(), output);
  }

  // required uint32 cur_conn_cnt = 5;
  if (has_cur_conn_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cur_conn_cnt(), output);
  }

  // required string host_name = 6;
  if (has_host_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->host_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMMsgServInfo)
}

int IMMsgServInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip1 = 1;
    if (has_ip1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip1());
    }

    // required string ip2 = 2;
    if (has_ip2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip2());
    }

    // required uint32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required uint32 max_conn_cnt = 4;
    if (has_max_conn_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_conn_cnt());
    }

    // required uint32 cur_conn_cnt = 5;
    if (has_cur_conn_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_conn_cnt());
    }

    // required string host_name = 6;
    if (has_host_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgServInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgServInfo*>(&from));
}

void IMMsgServInfo::MergeFrom(const IMMsgServInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip1()) {
      set_ip1(from.ip1());
    }
    if (from.has_ip2()) {
      set_ip2(from.ip2());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_max_conn_cnt()) {
      set_max_conn_cnt(from.max_conn_cnt());
    }
    if (from.has_cur_conn_cnt()) {
      set_cur_conn_cnt(from.cur_conn_cnt());
    }
    if (from.has_host_name()) {
      set_host_name(from.host_name());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsgServInfo::CopyFrom(const IMMsgServInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgServInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMMsgServInfo::Swap(IMMsgServInfo* other) {
  if (other != this) {
    std::swap(ip1_, other->ip1_);
    std::swap(ip2_, other->ip2_);
    std::swap(port_, other->port_);
    std::swap(max_conn_cnt_, other->max_conn_cnt_);
    std::swap(cur_conn_cnt_, other->cur_conn_cnt_);
    std::swap(host_name_, other->host_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgServInfo::GetTypeName() const {
  return "IM.Server.IMMsgServInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserStatusUpdate::kUserStatusFieldNumber;
const int IMUserStatusUpdate::kUserIdFieldNumber;
const int IMUserStatusUpdate::kClientTypeFieldNumber;
#endif  // !_MSC_VER

IMUserStatusUpdate::IMUserStatusUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserStatusUpdate)
}

void IMUserStatusUpdate::InitAsDefaultInstance() {
}

IMUserStatusUpdate::IMUserStatusUpdate(const IMUserStatusUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserStatusUpdate)
}

void IMUserStatusUpdate::SharedCtor() {
  _cached_size_ = 0;
  user_status_ = 0u;
  user_id_ = 0u;
  client_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserStatusUpdate::~IMUserStatusUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserStatusUpdate)
  SharedDtor();
}

void IMUserStatusUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserStatusUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserStatusUpdate& IMUserStatusUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserStatusUpdate* IMUserStatusUpdate::default_instance_ = NULL;

IMUserStatusUpdate* IMUserStatusUpdate::New() const {
  return new IMUserStatusUpdate;
}

void IMUserStatusUpdate::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMUserStatusUpdate*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(user_status_, user_id_);
    client_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUserStatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserStatusUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_status_)));
          set_has_user_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3: {
        if (tag == 24) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserStatusUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserStatusUpdate)
  return false;
#undef DO_
}

void IMUserStatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserStatusUpdate)
  // required uint32 user_status = 1;
  if (has_user_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_status(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->client_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserStatusUpdate)
}

int IMUserStatusUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_status = 1;
    if (has_user_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_status());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType client_type = 3;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserStatusUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserStatusUpdate*>(&from));
}

void IMUserStatusUpdate::MergeFrom(const IMUserStatusUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_status()) {
      set_user_status(from.user_status());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUserStatusUpdate::CopyFrom(const IMUserStatusUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMUserStatusUpdate::Swap(IMUserStatusUpdate* other) {
  if (other != this) {
    std::swap(user_status_, other->user_status_);
    std::swap(user_id_, other->user_id_);
    std::swap(client_type_, other->client_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserStatusUpdate::GetTypeName() const {
  return "IM.Server.IMUserStatusUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserCntUpdate::kUserActionFieldNumber;
const int IMUserCntUpdate::kUserIdFieldNumber;
#endif  // !_MSC_VER

IMUserCntUpdate::IMUserCntUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserCntUpdate)
}

void IMUserCntUpdate::InitAsDefaultInstance() {
}

IMUserCntUpdate::IMUserCntUpdate(const IMUserCntUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserCntUpdate)
}

void IMUserCntUpdate::SharedCtor() {
  _cached_size_ = 0;
  user_action_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserCntUpdate::~IMUserCntUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserCntUpdate)
  SharedDtor();
}

void IMUserCntUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserCntUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserCntUpdate& IMUserCntUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserCntUpdate* IMUserCntUpdate::default_instance_ = NULL;

IMUserCntUpdate* IMUserCntUpdate::New() const {
  return new IMUserCntUpdate;
}

void IMUserCntUpdate::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMUserCntUpdate*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(user_action_, user_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUserCntUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserCntUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_action = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_action_)));
          set_has_user_action();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserCntUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserCntUpdate)
  return false;
#undef DO_
}

void IMUserCntUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserCntUpdate)
  // required uint32 user_action = 1;
  if (has_user_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_action(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserCntUpdate)
}

int IMUserCntUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_action = 1;
    if (has_user_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_action());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserCntUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserCntUpdate*>(&from));
}

void IMUserCntUpdate::MergeFrom(const IMUserCntUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_action()) {
      set_user_action(from.user_action());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUserCntUpdate::CopyFrom(const IMUserCntUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserCntUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMUserCntUpdate::Swap(IMUserCntUpdate* other) {
  if (other != this) {
    std::swap(user_action_, other->user_action_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserCntUpdate::GetTypeName() const {
  return "IM.Server.IMUserCntUpdate";
}


// ===================================================================

#ifndef _MSC_VER
const int IMServerKickUser::kUserIdFieldNumber;
const int IMServerKickUser::kClientTypeFieldNumber;
const int IMServerKickUser::kReasonFieldNumber;
#endif  // !_MSC_VER

IMServerKickUser::IMServerKickUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerKickUser)
}

void IMServerKickUser::InitAsDefaultInstance() {
}

IMServerKickUser::IMServerKickUser(const IMServerKickUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerKickUser)
}

void IMServerKickUser::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  client_type_ = 1;
  reason_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerKickUser::~IMServerKickUser() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerKickUser)
  SharedDtor();
}

void IMServerKickUser::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerKickUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerKickUser& IMServerKickUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerKickUser* IMServerKickUser::default_instance_ = NULL;

IMServerKickUser* IMServerKickUser::New() const {
  return new IMServerKickUser;
}

void IMServerKickUser::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    user_id_ = 0u;
    client_type_ = 1;
    reason_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMServerKickUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerKickUser)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 2;
      case 2: {
        if (tag == 16) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_reason;
        break;
      }

      // required uint32 reason = 3;
      case 3: {
        if (tag == 24) {
         parse_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reason_)));
          set_has_reason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerKickUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerKickUser)
  return false;
#undef DO_
}

void IMServerKickUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerKickUser)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 2;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->client_type(), output);
  }

  // required uint32 reason = 3;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->reason(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerKickUser)
}

int IMServerKickUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType client_type = 2;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

    // required uint32 reason = 3;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reason());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerKickUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerKickUser*>(&from));
}

void IMServerKickUser::MergeFrom(const IMServerKickUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMServerKickUser::CopyFrom(const IMServerKickUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerKickUser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMServerKickUser::Swap(IMServerKickUser* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(client_type_, other->client_type_);
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMServerKickUser::GetTypeName() const {
  return "IM.Server.IMServerKickUser";
}


// ===================================================================

#ifndef _MSC_VER
const int IMServerPCLoginStatusNotify::kUserIdFieldNumber;
const int IMServerPCLoginStatusNotify::kLoginStatusFieldNumber;
#endif  // !_MSC_VER

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerPCLoginStatusNotify)
}

void IMServerPCLoginStatusNotify::InitAsDefaultInstance() {
}

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify(const IMServerPCLoginStatusNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerPCLoginStatusNotify)
}

void IMServerPCLoginStatusNotify::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  login_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMServerPCLoginStatusNotify::~IMServerPCLoginStatusNotify() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerPCLoginStatusNotify)
  SharedDtor();
}

void IMServerPCLoginStatusNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMServerPCLoginStatusNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMServerPCLoginStatusNotify& IMServerPCLoginStatusNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::default_instance_ = NULL;

IMServerPCLoginStatusNotify* IMServerPCLoginStatusNotify::New() const {
  return new IMServerPCLoginStatusNotify;
}

void IMServerPCLoginStatusNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMServerPCLoginStatusNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(user_id_, login_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMServerPCLoginStatusNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerPCLoginStatusNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_login_status;
        break;
      }

      // required uint32 login_status = 2;
      case 2: {
        if (tag == 16) {
         parse_login_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_status_)));
          set_has_login_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerPCLoginStatusNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerPCLoginStatusNotify)
  return false;
#undef DO_
}

void IMServerPCLoginStatusNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerPCLoginStatusNotify)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 login_status = 2;
  if (has_login_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerPCLoginStatusNotify)
}

int IMServerPCLoginStatusNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 login_status = 2;
    if (has_login_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->login_status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMServerPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerPCLoginStatusNotify*>(&from));
}

void IMServerPCLoginStatusNotify::MergeFrom(const IMServerPCLoginStatusNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_login_status()) {
      set_login_status(from.login_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMServerPCLoginStatusNotify::CopyFrom(const IMServerPCLoginStatusNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerPCLoginStatusNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMServerPCLoginStatusNotify::Swap(IMServerPCLoginStatusNotify* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(login_status_, other->login_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMServerPCLoginStatusNotify::GetTypeName() const {
  return "IM.Server.IMServerPCLoginStatusNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMPushToUserReq::kFlashFieldNumber;
const int IMPushToUserReq::kDataFieldNumber;
const int IMPushToUserReq::kUserTokenListFieldNumber;
#endif  // !_MSC_VER

IMPushToUserReq::IMPushToUserReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserReq)
}

void IMPushToUserReq::InitAsDefaultInstance() {
}

IMPushToUserReq::IMPushToUserReq(const IMPushToUserReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserReq)
}

void IMPushToUserReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  flash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserReq::~IMPushToUserReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserReq)
  SharedDtor();
}

void IMPushToUserReq::SharedDtor() {
  if (flash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete flash_;
  }
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserReq& IMPushToUserReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserReq* IMPushToUserReq::default_instance_ = NULL;

IMPushToUserReq* IMPushToUserReq::New() const {
  return new IMPushToUserReq;
}

void IMPushToUserReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_flash()) {
      if (flash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        flash_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  user_token_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMPushToUserReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string flash = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_flash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required string data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user_token_list;
        break;
      }

      // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
      case 3: {
        if (tag == 26) {
         parse_user_token_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_token_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_user_token_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserReq)
  return false;
#undef DO_
}

void IMPushToUserReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserReq)
  // required string flash = 1;
  if (has_flash()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->flash(), output);
  }

  // required string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->data(), output);
  }

  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  for (int i = 0; i < this->user_token_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->user_token_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserReq)
}

int IMPushToUserReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string flash = 1;
    if (has_flash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->flash());
    }

    // required string data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }

  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  total_size += 1 * this->user_token_list_size();
  for (int i = 0; i < this->user_token_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_token_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserReq*>(&from));
}

void IMPushToUserReq::MergeFrom(const IMPushToUserReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_token_list_.MergeFrom(from.user_token_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flash()) {
      set_flash(from.flash());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMPushToUserReq::CopyFrom(const IMPushToUserReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_list())) return false;
  return true;
}

void IMPushToUserReq::Swap(IMPushToUserReq* other) {
  if (other != this) {
    std::swap(flash_, other->flash_);
    std::swap(data_, other->data_);
    user_token_list_.Swap(&other->user_token_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMPushToUserReq::GetTypeName() const {
  return "IM.Server.IMPushToUserReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMPushToUserRsp::kPushResultListFieldNumber;
#endif  // !_MSC_VER

IMPushToUserRsp::IMPushToUserRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserRsp)
}

void IMPushToUserRsp::InitAsDefaultInstance() {
}

IMPushToUserRsp::IMPushToUserRsp(const IMPushToUserRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserRsp)
}

void IMPushToUserRsp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMPushToUserRsp::~IMPushToUserRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserRsp)
  SharedDtor();
}

void IMPushToUserRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMPushToUserRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMPushToUserRsp& IMPushToUserRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMPushToUserRsp* IMPushToUserRsp::default_instance_ = NULL;

IMPushToUserRsp* IMPushToUserRsp::New() const {
  return new IMPushToUserRsp;
}

void IMPushToUserRsp::Clear() {
  push_result_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMPushToUserRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.PushResult push_result_list = 1;
      case 1: {
        if (tag == 10) {
         parse_push_result_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_push_result_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_push_result_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserRsp)
  return false;
#undef DO_
}

void IMPushToUserRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserRsp)
  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  for (int i = 0; i < this->push_result_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->push_result_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserRsp)
}

int IMPushToUserRsp::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  total_size += 1 * this->push_result_list_size();
  for (int i = 0; i < this->push_result_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->push_result_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMPushToUserRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserRsp*>(&from));
}

void IMPushToUserRsp::MergeFrom(const IMPushToUserRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  push_result_list_.MergeFrom(from.push_result_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMPushToUserRsp::CopyFrom(const IMPushToUserRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->push_result_list())) return false;
  return true;
}

void IMPushToUserRsp::Swap(IMPushToUserRsp* other) {
  if (other != this) {
    push_result_list_.Swap(&other->push_result_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMPushToUserRsp::GetTypeName() const {
  return "IM.Server.IMPushToUserRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGroupGetShieldReq::kGroupIdFieldNumber;
const int IMGroupGetShieldReq::kUserIdFieldNumber;
const int IMGroupGetShieldReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGroupGetShieldReq::IMGroupGetShieldReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldReq)
}

void IMGroupGetShieldReq::InitAsDefaultInstance() {
}

IMGroupGetShieldReq::IMGroupGetShieldReq(const IMGroupGetShieldReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldReq)
}

void IMGroupGetShieldReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldReq::~IMGroupGetShieldReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldReq)
  SharedDtor();
}

void IMGroupGetShieldReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldReq& IMGroupGetShieldReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldReq* IMGroupGetShieldReq::default_instance_ = NULL;

IMGroupGetShieldReq* IMGroupGetShieldReq::New() const {
  return new IMGroupGetShieldReq;
}

void IMGroupGetShieldReq::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    group_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  user_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGroupGetShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // repeated uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_user_id())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldReq)
  return false;
#undef DO_
}

void IMGroupGetShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldReq)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated uint32 user_id = 2;
  for (int i = 0; i < this->user_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldReq)
}

int IMGroupGetShieldReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated uint32 user_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->user_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->user_id(i));
    }
    total_size += 1 * this->user_id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldReq*>(&from));
}

void IMGroupGetShieldReq::MergeFrom(const IMGroupGetShieldReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  user_id_.MergeFrom(from.user_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGroupGetShieldReq::CopyFrom(const IMGroupGetShieldReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IMGroupGetShieldReq::Swap(IMGroupGetShieldReq* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    user_id_.Swap(&other->user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGroupGetShieldReq::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGroupGetShieldRsp::kGroupIdFieldNumber;
const int IMGroupGetShieldRsp::kShieldStatusListFieldNumber;
const int IMGroupGetShieldRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGroupGetShieldRsp::IMGroupGetShieldRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldRsp)
}

void IMGroupGetShieldRsp::InitAsDefaultInstance() {
}

IMGroupGetShieldRsp::IMGroupGetShieldRsp(const IMGroupGetShieldRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldRsp)
}

void IMGroupGetShieldRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGroupGetShieldRsp::~IMGroupGetShieldRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldRsp)
  SharedDtor();
}

void IMGroupGetShieldRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGroupGetShieldRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGroupGetShieldRsp& IMGroupGetShieldRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGroupGetShieldRsp* IMGroupGetShieldRsp::default_instance_ = NULL;

IMGroupGetShieldRsp* IMGroupGetShieldRsp::New() const {
  return new IMGroupGetShieldRsp;
}

void IMGroupGetShieldRsp::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    group_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  shield_status_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGroupGetShieldRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shield_status_list;
        break;
      }

      // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
      case 2: {
        if (tag == 18) {
         parse_shield_status_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shield_status_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_shield_status_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldRsp)
  return false;
#undef DO_
}

void IMGroupGetShieldRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldRsp)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  for (int i = 0; i < this->shield_status_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->shield_status_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldRsp)
}

int IMGroupGetShieldRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  total_size += 1 * this->shield_status_list_size();
  for (int i = 0; i < this->shield_status_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shield_status_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGroupGetShieldRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldRsp*>(&from));
}

void IMGroupGetShieldRsp::MergeFrom(const IMGroupGetShieldRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  shield_status_list_.MergeFrom(from.shield_status_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGroupGetShieldRsp::CopyFrom(const IMGroupGetShieldRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->shield_status_list())) return false;
  return true;
}

void IMGroupGetShieldRsp::Swap(IMGroupGetShieldRsp* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    shield_status_list_.Swap(&other->shield_status_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGroupGetShieldRsp::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileTransferReq::kFromUserIdFieldNumber;
const int IMFileTransferReq::kToUserIdFieldNumber;
const int IMFileTransferReq::kFileNameFieldNumber;
const int IMFileTransferReq::kFileSizeFieldNumber;
const int IMFileTransferReq::kTransModeFieldNumber;
const int IMFileTransferReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileTransferReq::IMFileTransferReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferReq)
}

void IMFileTransferReq::InitAsDefaultInstance() {
}

IMFileTransferReq::IMFileTransferReq(const IMFileTransferReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferReq)
}

void IMFileTransferReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  trans_mode_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferReq::~IMFileTransferReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferReq)
  SharedDtor();
}

void IMFileTransferReq::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferReq& IMFileTransferReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferReq* IMFileTransferReq::default_instance_ = NULL;

IMFileTransferReq* IMFileTransferReq::New() const {
  return new IMFileTransferReq;
}

void IMFileTransferReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMFileTransferReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(from_user_id_, to_user_id_);
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_name_->clear();
      }
    }
    file_size_ = 0u;
    trans_mode_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMFileTransferReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }

      // required string file_name = 3;
      case 3: {
        if (tag == 26) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }

      // required uint32 file_size = 4;
      case 4: {
        if (tag == 32) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_trans_mode;
        break;
      }

      // required .IM.BaseDefine.TransferFileType trans_mode = 5;
      case 5: {
        if (tag == 40) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferReq)
  return false;
#undef DO_
}

void IMFileTransferReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferReq)
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 2;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }

  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->file_name(), output);
  }

  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferReq)
}

int IMFileTransferReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_user_id = 2;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required string file_name = 3;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // required uint32 file_size = 4;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferReq*>(&from));
}

void IMFileTransferReq::MergeFrom(const IMFileTransferReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMFileTransferReq::CopyFrom(const IMFileTransferReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMFileTransferReq::Swap(IMFileTransferReq* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileTransferReq::GetTypeName() const {
  return "IM.Server.IMFileTransferReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileTransferRsp::kResultCodeFieldNumber;
const int IMFileTransferRsp::kFromUserIdFieldNumber;
const int IMFileTransferRsp::kToUserIdFieldNumber;
const int IMFileTransferRsp::kFileNameFieldNumber;
const int IMFileTransferRsp::kFileSizeFieldNumber;
const int IMFileTransferRsp::kTaskIdFieldNumber;
const int IMFileTransferRsp::kTransModeFieldNumber;
const int IMFileTransferRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMFileTransferRsp::IMFileTransferRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferRsp)
}

void IMFileTransferRsp::InitAsDefaultInstance() {
}

IMFileTransferRsp::IMFileTransferRsp(const IMFileTransferRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferRsp)
}

void IMFileTransferRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  result_code_ = 0u;
  from_user_id_ = 0u;
  to_user_id_ = 0u;
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trans_mode_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileTransferRsp::~IMFileTransferRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferRsp)
  SharedDtor();
}

void IMFileTransferRsp::SharedDtor() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileTransferRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileTransferRsp& IMFileTransferRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileTransferRsp* IMFileTransferRsp::default_instance_ = NULL;

IMFileTransferRsp* IMFileTransferRsp::New() const {
  return new IMFileTransferRsp;
}

void IMFileTransferRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMFileTransferRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(result_code_, from_user_id_);
    ZR_(to_user_id_, file_size_);
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_name_->clear();
      }
    }
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        task_id_->clear();
      }
    }
    trans_mode_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMFileTransferRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_file_name;
        break;
      }

      // optional string file_name = 4;
      case 4: {
        if (tag == 34) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_file_size;
        break;
      }

      // optional uint32 file_size = 5;
      case 5: {
        if (tag == 40) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_task_id;
        break;
      }

      // optional string task_id = 6;
      case 6: {
        if (tag == 50) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_trans_mode;
        break;
      }

      // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
      case 7: {
        if (tag == 56) {
         parse_trans_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferRsp)
  return false;
#undef DO_
}

void IMFileTransferRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferRsp)
  // required uint32 result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 3;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_user_id(), output);
  }

  // optional string file_name = 4;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->file_name(), output);
  }

  // optional uint32 file_size = 5;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }

  // optional string task_id = 6;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->task_id(), output);
  }

  // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
  if (has_trans_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferRsp)
}

int IMFileTransferRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_user_id = 3;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // optional string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // optional uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // optional string task_id = 6;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileTransferRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferRsp*>(&from));
}

void IMFileTransferRsp::MergeFrom(const IMFileTransferRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_trans_mode()) {
      set_trans_mode(from.trans_mode());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMFileTransferRsp::CopyFrom(const IMFileTransferRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMFileTransferRsp::Swap(IMFileTransferRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    std::swap(task_id_, other->task_id_);
    std::swap(trans_mode_, other->trans_mode_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileTransferRsp::GetTypeName() const {
  return "IM.Server.IMFileTransferRsp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

IMFileServerIPReq::IMFileServerIPReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPReq)
}

void IMFileServerIPReq::InitAsDefaultInstance() {
}

IMFileServerIPReq::IMFileServerIPReq(const IMFileServerIPReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPReq)
}

void IMFileServerIPReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPReq::~IMFileServerIPReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPReq)
  SharedDtor();
}

void IMFileServerIPReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPReq& IMFileServerIPReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPReq* IMFileServerIPReq::default_instance_ = NULL;

IMFileServerIPReq* IMFileServerIPReq::New() const {
  return new IMFileServerIPReq;
}

void IMFileServerIPReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMFileServerIPReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPReq)
  return false;
#undef DO_
}

void IMFileServerIPReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPReq)
}

int IMFileServerIPReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPReq*>(&from));
}

void IMFileServerIPReq::MergeFrom(const IMFileServerIPReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMFileServerIPReq::CopyFrom(const IMFileServerIPReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPReq::IsInitialized() const {

  return true;
}

void IMFileServerIPReq::Swap(IMFileServerIPReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileServerIPReq::GetTypeName() const {
  return "IM.Server.IMFileServerIPReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMFileServerIPRsp::kIpAddrListFieldNumber;
#endif  // !_MSC_VER

IMFileServerIPRsp::IMFileServerIPRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPRsp)
}

void IMFileServerIPRsp::InitAsDefaultInstance() {
}

IMFileServerIPRsp::IMFileServerIPRsp(const IMFileServerIPRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPRsp)
}

void IMFileServerIPRsp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMFileServerIPRsp::~IMFileServerIPRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPRsp)
  SharedDtor();
}

void IMFileServerIPRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMFileServerIPRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMFileServerIPRsp& IMFileServerIPRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMFileServerIPRsp* IMFileServerIPRsp::default_instance_ = NULL;

IMFileServerIPRsp* IMFileServerIPRsp::New() const {
  return new IMFileServerIPRsp;
}

void IMFileServerIPRsp::Clear() {
  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMFileServerIPRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
      case 1: {
        if (tag == 10) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ip_addr_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPRsp)
  return false;
#undef DO_
}

void IMFileServerIPRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPRsp)
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->ip_addr_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPRsp)
}

int IMFileServerIPRsp::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMFileServerIPRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPRsp*>(&from));
}

void IMFileServerIPRsp::MergeFrom(const IMFileServerIPRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMFileServerIPRsp::CopyFrom(const IMFileServerIPRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ip_addr_list())) return false;
  return true;
}

void IMFileServerIPRsp::Swap(IMFileServerIPRsp* other) {
  if (other != this) {
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMFileServerIPRsp::GetTypeName() const {
  return "IM.Server.IMFileServerIPRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetBuddyConfigReq::kCompanyIdFieldNumber;
const int IMGetBuddyConfigReq::kUserIdFieldNumber;
#endif  // !_MSC_VER

IMGetBuddyConfigReq::IMGetBuddyConfigReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetBuddyConfigReq)
}

void IMGetBuddyConfigReq::InitAsDefaultInstance() {
}

IMGetBuddyConfigReq::IMGetBuddyConfigReq(const IMGetBuddyConfigReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetBuddyConfigReq)
}

void IMGetBuddyConfigReq::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetBuddyConfigReq::~IMGetBuddyConfigReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetBuddyConfigReq)
  SharedDtor();
}

void IMGetBuddyConfigReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetBuddyConfigReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetBuddyConfigReq& IMGetBuddyConfigReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetBuddyConfigReq* IMGetBuddyConfigReq::default_instance_ = NULL;

IMGetBuddyConfigReq* IMGetBuddyConfigReq::New() const {
  return new IMGetBuddyConfigReq;
}

void IMGetBuddyConfigReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetBuddyConfigReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, user_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetBuddyConfigReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetBuddyConfigReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetBuddyConfigReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetBuddyConfigReq)
  return false;
#undef DO_
}

void IMGetBuddyConfigReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetBuddyConfigReq)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetBuddyConfigReq)
}

int IMGetBuddyConfigReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetBuddyConfigReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetBuddyConfigReq*>(&from));
}

void IMGetBuddyConfigReq::MergeFrom(const IMGetBuddyConfigReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetBuddyConfigReq::CopyFrom(const IMGetBuddyConfigReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetBuddyConfigReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMGetBuddyConfigReq::Swap(IMGetBuddyConfigReq* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetBuddyConfigReq::GetTypeName() const {
  return "IM.Server.IMGetBuddyConfigReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetBuddyConfigRsp::kCompanyIdFieldNumber;
const int IMGetBuddyConfigRsp::kUserIdFieldNumber;
const int IMGetBuddyConfigRsp::kCompanyConfigFieldNumber;
const int IMGetBuddyConfigRsp::kUserConfigFieldNumber;
#endif  // !_MSC_VER

IMGetBuddyConfigRsp::IMGetBuddyConfigRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetBuddyConfigRsp)
}

void IMGetBuddyConfigRsp::InitAsDefaultInstance() {
}

IMGetBuddyConfigRsp::IMGetBuddyConfigRsp(const IMGetBuddyConfigRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetBuddyConfigRsp)
}

void IMGetBuddyConfigRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  company_config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_config_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetBuddyConfigRsp::~IMGetBuddyConfigRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetBuddyConfigRsp)
  SharedDtor();
}

void IMGetBuddyConfigRsp::SharedDtor() {
  if (company_config_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete company_config_;
  }
  if (user_config_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_config_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetBuddyConfigRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetBuddyConfigRsp& IMGetBuddyConfigRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetBuddyConfigRsp* IMGetBuddyConfigRsp::default_instance_ = NULL;

IMGetBuddyConfigRsp* IMGetBuddyConfigRsp::New() const {
  return new IMGetBuddyConfigRsp;
}

void IMGetBuddyConfigRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetBuddyConfigRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(company_id_, user_id_);
    if (has_company_config()) {
      if (company_config_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        company_config_->clear();
      }
    }
    if (has_user_config()) {
      if (user_config_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_config_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetBuddyConfigRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetBuddyConfigRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_company_config;
        break;
      }

      // required bytes company_config = 5;
      case 5: {
        if (tag == 42) {
         parse_company_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_company_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_user_config;
        break;
      }

      // required bytes user_config = 6;
      case 6: {
        if (tag == 50) {
         parse_user_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetBuddyConfigRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetBuddyConfigRsp)
  return false;
#undef DO_
}

void IMGetBuddyConfigRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetBuddyConfigRsp)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required bytes company_config = 5;
  if (has_company_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->company_config(), output);
  }

  // required bytes user_config = 6;
  if (has_user_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->user_config(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetBuddyConfigRsp)
}

int IMGetBuddyConfigRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required bytes company_config = 5;
    if (has_company_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->company_config());
    }

    // required bytes user_config = 6;
    if (has_user_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user_config());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetBuddyConfigRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetBuddyConfigRsp*>(&from));
}

void IMGetBuddyConfigRsp::MergeFrom(const IMGetBuddyConfigRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_company_config()) {
      set_company_config(from.company_config());
    }
    if (from.has_user_config()) {
      set_user_config(from.user_config());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetBuddyConfigRsp::CopyFrom(const IMGetBuddyConfigRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetBuddyConfigRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMGetBuddyConfigRsp::Swap(IMGetBuddyConfigRsp* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(company_config_, other->company_config_);
    std::swap(user_config_, other->user_config_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetBuddyConfigRsp::GetTypeName() const {
  return "IM.Server.IMGetBuddyConfigRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLoginToSqlReq::kCompanyIdFieldNumber;
const int IMLoginToSqlReq::kUserNameFieldNumber;
const int IMLoginToSqlReq::kPasswordFieldNumber;
const int IMLoginToSqlReq::kClientTypeFieldNumber;
const int IMLoginToSqlReq::kOnlineStatusFieldNumber;
const int IMLoginToSqlReq::kResultCodeFieldNumber;
const int IMLoginToSqlReq::kUserInfoFieldNumber;
const int IMLoginToSqlReq::kPcLastOfflineTimeFieldNumber;
const int IMLoginToSqlReq::kPhoneLastOfflineTimeFieldNumber;
const int IMLoginToSqlReq::kClientVerFieldNumber;
#endif  // !_MSC_VER

IMLoginToSqlReq::IMLoginToSqlReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMLoginToSqlReq)
}

void IMLoginToSqlReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
#else
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(&::IM::BaseDefine::UserInfo::default_instance());
#endif
}

IMLoginToSqlReq::IMLoginToSqlReq(const IMLoginToSqlReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMLoginToSqlReq)
}

void IMLoginToSqlReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_type_ = 1;
  online_status_ = 1;
  result_code_ = 1;
  user_info_ = NULL;
  pc_last_offline_time_ = GOOGLE_ULONGLONG(0);
  phone_last_offline_time_ = GOOGLE_ULONGLONG(0);
  client_ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLoginToSqlReq::~IMLoginToSqlReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMLoginToSqlReq)
  SharedDtor();
}

void IMLoginToSqlReq::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (client_ver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_ver_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_info_;
  }
}

void IMLoginToSqlReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLoginToSqlReq& IMLoginToSqlReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMLoginToSqlReq* IMLoginToSqlReq::default_instance_ = NULL;

IMLoginToSqlReq* IMLoginToSqlReq::New() const {
  return new IMLoginToSqlReq;
}

void IMLoginToSqlReq::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    company_id_ = 0u;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    client_type_ = 1;
    online_status_ = 1;
    result_code_ = 1;
    if (has_user_info()) {
      if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
    }
    pc_last_offline_time_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & 768) {
    phone_last_offline_time_ = GOOGLE_ULONGLONG(0);
    if (has_client_ver()) {
      if (client_ver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        client_ver_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLoginToSqlReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMLoginToSqlReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (tag == 18) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_password;
        break;
      }

      // required string password = 3;
      case 3: {
        if (tag == 26) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 4;
      case 4: {
        if (tag == 32) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_online_status;
        break;
      }

      // required .IM.BaseDefine.UserStatType online_status = 5;
      case 5: {
        if (tag == 40) {
         parse_online_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_online_status(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_result_code;
        break;
      }

      // optional .IM.BaseDefine.LoginResultCode result_code = 6;
      case 6: {
        if (tag == 48) {
         parse_result_code:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::LoginResultCode_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::LoginResultCode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_user_info;
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 7;
      case 7: {
        if (tag == 58) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_pc_last_offline_time;
        break;
      }

      // optional uint64 pc_last_offline_time = 8;
      case 8: {
        if (tag == 64) {
         parse_pc_last_offline_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pc_last_offline_time_)));
          set_has_pc_last_offline_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_phone_last_offline_time;
        break;
      }

      // optional uint64 phone_last_offline_time = 9;
      case 9: {
        if (tag == 72) {
         parse_phone_last_offline_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &phone_last_offline_time_)));
          set_has_phone_last_offline_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_client_ver;
        break;
      }

      // optional string client_ver = 10;
      case 10: {
        if (tag == 82) {
         parse_client_ver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_ver()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMLoginToSqlReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMLoginToSqlReq)
  return false;
#undef DO_
}

void IMLoginToSqlReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMLoginToSqlReq)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->user_name(), output);
  }

  // required string password = 3;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->password(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 4;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->client_type(), output);
  }

  // required .IM.BaseDefine.UserStatType online_status = 5;
  if (has_online_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->online_status(), output);
  }

  // optional .IM.BaseDefine.LoginResultCode result_code = 6;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->result_code(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 7;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->user_info(), output);
  }

  // optional uint64 pc_last_offline_time = 8;
  if (has_pc_last_offline_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->pc_last_offline_time(), output);
  }

  // optional uint64 phone_last_offline_time = 9;
  if (has_phone_last_offline_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->phone_last_offline_time(), output);
  }

  // optional string client_ver = 10;
  if (has_client_ver()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->client_ver(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMLoginToSqlReq)
}

int IMLoginToSqlReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string password = 3;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // required .IM.BaseDefine.ClientType client_type = 4;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

    // required .IM.BaseDefine.UserStatType online_status = 5;
    if (has_online_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->online_status());
    }

    // optional .IM.BaseDefine.LoginResultCode result_code = 6;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 7;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_info());
    }

    // optional uint64 pc_last_offline_time = 8;
    if (has_pc_last_offline_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pc_last_offline_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 phone_last_offline_time = 9;
    if (has_phone_last_offline_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->phone_last_offline_time());
    }

    // optional string client_ver = 10;
    if (has_client_ver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_ver());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLoginToSqlReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLoginToSqlReq*>(&from));
}

void IMLoginToSqlReq::MergeFrom(const IMLoginToSqlReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_online_status()) {
      set_online_status(from.online_status());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_user_info()) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (from.has_pc_last_offline_time()) {
      set_pc_last_offline_time(from.pc_last_offline_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_phone_last_offline_time()) {
      set_phone_last_offline_time(from.phone_last_offline_time());
    }
    if (from.has_client_ver()) {
      set_client_ver(from.client_ver());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLoginToSqlReq::CopyFrom(const IMLoginToSqlReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLoginToSqlReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_user_info()) {
    if (!this->user_info().IsInitialized()) return false;
  }
  return true;
}

void IMLoginToSqlReq::Swap(IMLoginToSqlReq* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(password_, other->password_);
    std::swap(client_type_, other->client_type_);
    std::swap(online_status_, other->online_status_);
    std::swap(result_code_, other->result_code_);
    std::swap(user_info_, other->user_info_);
    std::swap(pc_last_offline_time_, other->pc_last_offline_time_);
    std::swap(phone_last_offline_time_, other->phone_last_offline_time_);
    std::swap(client_ver_, other->client_ver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLoginToSqlReq::GetTypeName() const {
  return "IM.Server.IMLoginToSqlReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMLoginToSqlRsp::kCompanyIdFieldNumber;
const int IMLoginToSqlRsp::kUserNameFieldNumber;
const int IMLoginToSqlRsp::kPasswordFieldNumber;
const int IMLoginToSqlRsp::kClientTypeFieldNumber;
const int IMLoginToSqlRsp::kOnlineStatusFieldNumber;
const int IMLoginToSqlRsp::kResultCodeFieldNumber;
const int IMLoginToSqlRsp::kUserInfoFieldNumber;
const int IMLoginToSqlRsp::kPcLastOfflineTimeFieldNumber;
const int IMLoginToSqlRsp::kPhoneLastOfflineTimeFieldNumber;
#endif  // !_MSC_VER

IMLoginToSqlRsp::IMLoginToSqlRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMLoginToSqlRsp)
}

void IMLoginToSqlRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
#else
  user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(&::IM::BaseDefine::UserInfo::default_instance());
#endif
}

IMLoginToSqlRsp::IMLoginToSqlRsp(const IMLoginToSqlRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMLoginToSqlRsp)
}

void IMLoginToSqlRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_type_ = 1;
  online_status_ = 1;
  result_code_ = 1;
  user_info_ = NULL;
  pc_last_offline_time_ = GOOGLE_ULONGLONG(0);
  phone_last_offline_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMLoginToSqlRsp::~IMLoginToSqlRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMLoginToSqlRsp)
  SharedDtor();
}

void IMLoginToSqlRsp::SharedDtor() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete user_info_;
  }
}

void IMLoginToSqlRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMLoginToSqlRsp& IMLoginToSqlRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMLoginToSqlRsp* IMLoginToSqlRsp::default_instance_ = NULL;

IMLoginToSqlRsp* IMLoginToSqlRsp::New() const {
  return new IMLoginToSqlRsp;
}

void IMLoginToSqlRsp::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    company_id_ = 0u;
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    client_type_ = 1;
    online_status_ = 1;
    result_code_ = 1;
    if (has_user_info()) {
      if (user_info_ != NULL) user_info_->::IM::BaseDefine::UserInfo::Clear();
    }
    pc_last_offline_time_ = GOOGLE_ULONGLONG(0);
  }
  phone_last_offline_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMLoginToSqlRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMLoginToSqlRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // required string user_name = 2;
      case 2: {
        if (tag == 18) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_password;
        break;
      }

      // required string password = 3;
      case 3: {
        if (tag == 26) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 4;
      case 4: {
        if (tag == 32) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_online_status;
        break;
      }

      // required .IM.BaseDefine.UserStatType online_status = 5;
      case 5: {
        if (tag == 40) {
         parse_online_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_online_status(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_result_code;
        break;
      }

      // optional .IM.BaseDefine.LoginResultCode result_code = 6;
      case 6: {
        if (tag == 48) {
         parse_result_code:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::LoginResultCode_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::LoginResultCode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_user_info;
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 7;
      case 7: {
        if (tag == 58) {
         parse_user_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_pc_last_offline_time;
        break;
      }

      // optional uint64 pc_last_offline_time = 8;
      case 8: {
        if (tag == 64) {
         parse_pc_last_offline_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pc_last_offline_time_)));
          set_has_pc_last_offline_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_phone_last_offline_time;
        break;
      }

      // optional uint64 phone_last_offline_time = 9;
      case 9: {
        if (tag == 72) {
         parse_phone_last_offline_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &phone_last_offline_time_)));
          set_has_phone_last_offline_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMLoginToSqlRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMLoginToSqlRsp)
  return false;
#undef DO_
}

void IMLoginToSqlRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMLoginToSqlRsp)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required string user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->user_name(), output);
  }

  // required string password = 3;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->password(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 4;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->client_type(), output);
  }

  // required .IM.BaseDefine.UserStatType online_status = 5;
  if (has_online_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->online_status(), output);
  }

  // optional .IM.BaseDefine.LoginResultCode result_code = 6;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->result_code(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 7;
  if (has_user_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->user_info(), output);
  }

  // optional uint64 pc_last_offline_time = 8;
  if (has_pc_last_offline_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->pc_last_offline_time(), output);
  }

  // optional uint64 phone_last_offline_time = 9;
  if (has_phone_last_offline_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->phone_last_offline_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMLoginToSqlRsp)
}

int IMLoginToSqlRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required string user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // required string password = 3;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // required .IM.BaseDefine.ClientType client_type = 4;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

    // required .IM.BaseDefine.UserStatType online_status = 5;
    if (has_online_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->online_status());
    }

    // optional .IM.BaseDefine.LoginResultCode result_code = 6;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 7;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_info());
    }

    // optional uint64 pc_last_offline_time = 8;
    if (has_pc_last_offline_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pc_last_offline_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 phone_last_offline_time = 9;
    if (has_phone_last_offline_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->phone_last_offline_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMLoginToSqlRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMLoginToSqlRsp*>(&from));
}

void IMLoginToSqlRsp::MergeFrom(const IMLoginToSqlRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_online_status()) {
      set_online_status(from.online_status());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_user_info()) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (from.has_pc_last_offline_time()) {
      set_pc_last_offline_time(from.pc_last_offline_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_phone_last_offline_time()) {
      set_phone_last_offline_time(from.phone_last_offline_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMLoginToSqlRsp::CopyFrom(const IMLoginToSqlRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMLoginToSqlRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_user_info()) {
    if (!this->user_info().IsInitialized()) return false;
  }
  return true;
}

void IMLoginToSqlRsp::Swap(IMLoginToSqlRsp* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(password_, other->password_);
    std::swap(client_type_, other->client_type_);
    std::swap(online_status_, other->online_status_);
    std::swap(result_code_, other->result_code_);
    std::swap(user_info_, other->user_info_);
    std::swap(pc_last_offline_time_, other->pc_last_offline_time_);
    std::swap(phone_last_offline_time_, other->phone_last_offline_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMLoginToSqlRsp::GetTypeName() const {
  return "IM.Server.IMLoginToSqlRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUsrStatBroadcoast::kCompanyIdFieldNumber;
const int IMUsrStatBroadcoast::kUserIdFieldNumber;
const int IMUsrStatBroadcoast::kConnsvrIdFieldNumber;
const int IMUsrStatBroadcoast::kConnsocketIndexFieldNumber;
const int IMUsrStatBroadcoast::kClientTypeFieldNumber;
const int IMUsrStatBroadcoast::kClientStatFieldNumber;
const int IMUsrStatBroadcoast::kUpdateTimeFieldNumber;
#endif  // !_MSC_VER

IMUsrStatBroadcoast::IMUsrStatBroadcoast()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUsrStatBroadcoast)
}

void IMUsrStatBroadcoast::InitAsDefaultInstance() {
}

IMUsrStatBroadcoast::IMUsrStatBroadcoast(const IMUsrStatBroadcoast& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUsrStatBroadcoast)
}

void IMUsrStatBroadcoast::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  connsvr_id_ = 0u;
  connsocket_index_ = 0u;
  client_type_ = 1;
  client_stat_ = 1;
  update_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUsrStatBroadcoast::~IMUsrStatBroadcoast() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUsrStatBroadcoast)
  SharedDtor();
}

void IMUsrStatBroadcoast::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUsrStatBroadcoast::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUsrStatBroadcoast& IMUsrStatBroadcoast::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUsrStatBroadcoast* IMUsrStatBroadcoast::default_instance_ = NULL;

IMUsrStatBroadcoast* IMUsrStatBroadcoast::New() const {
  return new IMUsrStatBroadcoast;
}

void IMUsrStatBroadcoast::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMUsrStatBroadcoast*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(company_id_, connsocket_index_);
    client_type_ = 1;
    client_stat_ = 1;
    update_time_ = GOOGLE_ULONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUsrStatBroadcoast::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUsrStatBroadcoast)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_connsvr_id;
        break;
      }

      // required uint32 connsvr_id = 3;
      case 3: {
        if (tag == 24) {
         parse_connsvr_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &connsvr_id_)));
          set_has_connsvr_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_connsocket_index;
        break;
      }

      // required uint32 connsocket_index = 4;
      case 4: {
        if (tag == 32) {
         parse_connsocket_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &connsocket_index_)));
          set_has_connsocket_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_client_type;
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 5;
      case 5: {
        if (tag == 40) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_client_stat;
        break;
      }

      // required .IM.BaseDefine.UserStatType client_stat = 6;
      case 6: {
        if (tag == 48) {
         parse_client_stat:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_client_stat(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 7;
      case 7: {
        if (tag == 56) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUsrStatBroadcoast)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUsrStatBroadcoast)
  return false;
#undef DO_
}

void IMUsrStatBroadcoast::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUsrStatBroadcoast)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint32 connsvr_id = 3;
  if (has_connsvr_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->connsvr_id(), output);
  }

  // required uint32 connsocket_index = 4;
  if (has_connsocket_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->connsocket_index(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 5;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->client_type(), output);
  }

  // required .IM.BaseDefine.UserStatType client_stat = 6;
  if (has_client_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->client_stat(), output);
  }

  // required uint64 update_time = 7;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->update_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUsrStatBroadcoast)
}

int IMUsrStatBroadcoast::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 connsvr_id = 3;
    if (has_connsvr_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->connsvr_id());
    }

    // required uint32 connsocket_index = 4;
    if (has_connsocket_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->connsocket_index());
    }

    // required .IM.BaseDefine.ClientType client_type = 5;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

    // required .IM.BaseDefine.UserStatType client_stat = 6;
    if (has_client_stat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_stat());
    }

    // required uint64 update_time = 7;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUsrStatBroadcoast::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUsrStatBroadcoast*>(&from));
}

void IMUsrStatBroadcoast::MergeFrom(const IMUsrStatBroadcoast& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_connsvr_id()) {
      set_connsvr_id(from.connsvr_id());
    }
    if (from.has_connsocket_index()) {
      set_connsocket_index(from.connsocket_index());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
    if (from.has_client_stat()) {
      set_client_stat(from.client_stat());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUsrStatBroadcoast::CopyFrom(const IMUsrStatBroadcoast& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUsrStatBroadcoast::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMUsrStatBroadcoast::Swap(IMUsrStatBroadcoast* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(connsvr_id_, other->connsvr_id_);
    std::swap(connsocket_index_, other->connsocket_index_);
    std::swap(client_type_, other->client_type_);
    std::swap(client_stat_, other->client_stat_);
    std::swap(update_time_, other->update_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUsrStatBroadcoast::GetTypeName() const {
  return "IM.Server.IMUsrStatBroadcoast";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOptBuddyStorageReq::kReqUserIdFieldNumber;
const int IMOptBuddyStorageReq::kReqCompanyIdFieldNumber;
const int IMOptBuddyStorageReq::kDestUserIdFieldNumber;
const int IMOptBuddyStorageReq::kDestCompanyIdFieldNumber;
const int IMOptBuddyStorageReq::kCreateTimeFieldNumber;
const int IMOptBuddyStorageReq::kOptRemarkFieldNumber;
const int IMOptBuddyStorageReq::kReqStatFieldNumber;
#endif  // !_MSC_VER

IMOptBuddyStorageReq::IMOptBuddyStorageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMOptBuddyStorageReq)
}

void IMOptBuddyStorageReq::InitAsDefaultInstance() {
}

IMOptBuddyStorageReq::IMOptBuddyStorageReq(const IMOptBuddyStorageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMOptBuddyStorageReq)
}

void IMOptBuddyStorageReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  create_time_ = GOOGLE_ULONGLONG(0);
  opt_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  req_stat_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOptBuddyStorageReq::~IMOptBuddyStorageReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMOptBuddyStorageReq)
  SharedDtor();
}

void IMOptBuddyStorageReq::SharedDtor() {
  if (opt_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opt_remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOptBuddyStorageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOptBuddyStorageReq& IMOptBuddyStorageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMOptBuddyStorageReq* IMOptBuddyStorageReq::default_instance_ = NULL;

IMOptBuddyStorageReq* IMOptBuddyStorageReq::New() const {
  return new IMOptBuddyStorageReq;
}

void IMOptBuddyStorageReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOptBuddyStorageReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(req_user_id_, create_time_);
    if (has_opt_remark()) {
      if (opt_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        opt_remark_->clear();
      }
    }
    req_stat_ = false;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOptBuddyStorageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMOptBuddyStorageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_create_time;
        break;
      }

      // required uint64 create_time = 5;
      case 5: {
        if (tag == 40) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_opt_remark;
        break;
      }

      // required string opt_remark = 7;
      case 7: {
        if (tag == 58) {
         parse_opt_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_opt_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_req_stat;
        break;
      }

      // required bool req_stat = 8;
      case 8: {
        if (tag == 64) {
         parse_req_stat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &req_stat_)));
          set_has_req_stat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMOptBuddyStorageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMOptBuddyStorageReq)
  return false;
#undef DO_
}

void IMOptBuddyStorageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMOptBuddyStorageReq)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required uint64 create_time = 5;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->create_time(), output);
  }

  // required string opt_remark = 7;
  if (has_opt_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->opt_remark(), output);
  }

  // required bool req_stat = 8;
  if (has_req_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->req_stat(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMOptBuddyStorageReq)
}

int IMOptBuddyStorageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required uint64 create_time = 5;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->create_time());
    }

    // required string opt_remark = 7;
    if (has_opt_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->opt_remark());
    }

    // required bool req_stat = 8;
    if (has_req_stat()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOptBuddyStorageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOptBuddyStorageReq*>(&from));
}

void IMOptBuddyStorageReq::MergeFrom(const IMOptBuddyStorageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
    if (from.has_opt_remark()) {
      set_opt_remark(from.opt_remark());
    }
    if (from.has_req_stat()) {
      set_req_stat(from.req_stat());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOptBuddyStorageReq::CopyFrom(const IMOptBuddyStorageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOptBuddyStorageReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMOptBuddyStorageReq::Swap(IMOptBuddyStorageReq* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(create_time_, other->create_time_);
    std::swap(opt_remark_, other->opt_remark_);
    std::swap(req_stat_, other->req_stat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOptBuddyStorageReq::GetTypeName() const {
  return "IM.Server.IMOptBuddyStorageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOptBuddyStorageRsp::kReqUserIdFieldNumber;
const int IMOptBuddyStorageRsp::kReqCompanyIdFieldNumber;
const int IMOptBuddyStorageRsp::kDestUserIdFieldNumber;
const int IMOptBuddyStorageRsp::kDestCompanyIdFieldNumber;
const int IMOptBuddyStorageRsp::kCreateTimeFieldNumber;
const int IMOptBuddyStorageRsp::kOptRemarkFieldNumber;
const int IMOptBuddyStorageRsp::kReqStatFieldNumber;
#endif  // !_MSC_VER

IMOptBuddyStorageRsp::IMOptBuddyStorageRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMOptBuddyStorageRsp)
}

void IMOptBuddyStorageRsp::InitAsDefaultInstance() {
}

IMOptBuddyStorageRsp::IMOptBuddyStorageRsp(const IMOptBuddyStorageRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMOptBuddyStorageRsp)
}

void IMOptBuddyStorageRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  create_time_ = GOOGLE_ULONGLONG(0);
  opt_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  req_stat_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOptBuddyStorageRsp::~IMOptBuddyStorageRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMOptBuddyStorageRsp)
  SharedDtor();
}

void IMOptBuddyStorageRsp::SharedDtor() {
  if (opt_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opt_remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOptBuddyStorageRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOptBuddyStorageRsp& IMOptBuddyStorageRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMOptBuddyStorageRsp* IMOptBuddyStorageRsp::default_instance_ = NULL;

IMOptBuddyStorageRsp* IMOptBuddyStorageRsp::New() const {
  return new IMOptBuddyStorageRsp;
}

void IMOptBuddyStorageRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOptBuddyStorageRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(req_user_id_, create_time_);
    if (has_opt_remark()) {
      if (opt_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        opt_remark_->clear();
      }
    }
    req_stat_ = false;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOptBuddyStorageRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMOptBuddyStorageRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_create_time;
        break;
      }

      // required uint64 create_time = 5;
      case 5: {
        if (tag == 40) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_opt_remark;
        break;
      }

      // required string opt_remark = 7;
      case 7: {
        if (tag == 58) {
         parse_opt_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_opt_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_req_stat;
        break;
      }

      // required bool req_stat = 8;
      case 8: {
        if (tag == 64) {
         parse_req_stat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &req_stat_)));
          set_has_req_stat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMOptBuddyStorageRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMOptBuddyStorageRsp)
  return false;
#undef DO_
}

void IMOptBuddyStorageRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMOptBuddyStorageRsp)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required uint64 create_time = 5;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->create_time(), output);
  }

  // required string opt_remark = 7;
  if (has_opt_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->opt_remark(), output);
  }

  // required bool req_stat = 8;
  if (has_req_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->req_stat(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMOptBuddyStorageRsp)
}

int IMOptBuddyStorageRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required uint64 create_time = 5;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->create_time());
    }

    // required string opt_remark = 7;
    if (has_opt_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->opt_remark());
    }

    // required bool req_stat = 8;
    if (has_req_stat()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOptBuddyStorageRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOptBuddyStorageRsp*>(&from));
}

void IMOptBuddyStorageRsp::MergeFrom(const IMOptBuddyStorageRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
    if (from.has_opt_remark()) {
      set_opt_remark(from.opt_remark());
    }
    if (from.has_req_stat()) {
      set_req_stat(from.req_stat());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOptBuddyStorageRsp::CopyFrom(const IMOptBuddyStorageRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOptBuddyStorageRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMOptBuddyStorageRsp::Swap(IMOptBuddyStorageRsp* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(create_time_, other->create_time_);
    std::swap(opt_remark_, other->opt_remark_);
    std::swap(req_stat_, other->req_stat_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOptBuddyStorageRsp::GetTypeName() const {
  return "IM.Server.IMOptBuddyStorageRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMBuddyStorageReq::kReqUserIdFieldNumber;
const int IMBuddyStorageReq::kReqCompanyIdFieldNumber;
const int IMBuddyStorageReq::kDestUserIdFieldNumber;
const int IMBuddyStorageReq::kDestCompanyIdFieldNumber;
const int IMBuddyStorageReq::kOptTypeFieldNumber;
const int IMBuddyStorageReq::kUpdateTimeFieldNumber;
const int IMBuddyStorageReq::kResultFieldNumber;
#endif  // !_MSC_VER

IMBuddyStorageReq::IMBuddyStorageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMBuddyStorageReq)
}

void IMBuddyStorageReq::InitAsDefaultInstance() {
}

IMBuddyStorageReq::IMBuddyStorageReq(const IMBuddyStorageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMBuddyStorageReq)
}

void IMBuddyStorageReq::SharedCtor() {
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  opt_type_ = 1;
  update_time_ = GOOGLE_ULONGLONG(0);
  result_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMBuddyStorageReq::~IMBuddyStorageReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMBuddyStorageReq)
  SharedDtor();
}

void IMBuddyStorageReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMBuddyStorageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMBuddyStorageReq& IMBuddyStorageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMBuddyStorageReq* IMBuddyStorageReq::default_instance_ = NULL;

IMBuddyStorageReq* IMBuddyStorageReq::New() const {
  return new IMBuddyStorageReq;
}

void IMBuddyStorageReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMBuddyStorageReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(req_user_id_, update_time_);
    opt_type_ = 1;
    result_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMBuddyStorageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMBuddyStorageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_opt_type;
        break;
      }

      // required .IM.BaseDefine.BuddyOptType opt_type = 5;
      case 5: {
        if (tag == 40) {
         parse_opt_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::BuddyOptType_IsValid(value)) {
            set_opt_type(static_cast< ::IM::BaseDefine::BuddyOptType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 6;
      case 6: {
        if (tag == 48) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_result;
        break;
      }

      // required .IM.BaseDefine.OptResultCode result = 7;
      case 7: {
        if (tag == 56) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::OptResultCode_IsValid(value)) {
            set_result(static_cast< ::IM::BaseDefine::OptResultCode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMBuddyStorageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMBuddyStorageReq)
  return false;
#undef DO_
}

void IMBuddyStorageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMBuddyStorageReq)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required .IM.BaseDefine.BuddyOptType opt_type = 5;
  if (has_opt_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->opt_type(), output);
  }

  // required uint64 update_time = 6;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->update_time(), output);
  }

  // required .IM.BaseDefine.OptResultCode result = 7;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMBuddyStorageReq)
}

int IMBuddyStorageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required .IM.BaseDefine.BuddyOptType opt_type = 5;
    if (has_opt_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->opt_type());
    }

    // required uint64 update_time = 6;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // required .IM.BaseDefine.OptResultCode result = 7;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMBuddyStorageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMBuddyStorageReq*>(&from));
}

void IMBuddyStorageReq::MergeFrom(const IMBuddyStorageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_opt_type()) {
      set_opt_type(from.opt_type());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMBuddyStorageReq::CopyFrom(const IMBuddyStorageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMBuddyStorageReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMBuddyStorageReq::Swap(IMBuddyStorageReq* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(opt_type_, other->opt_type_);
    std::swap(update_time_, other->update_time_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMBuddyStorageReq::GetTypeName() const {
  return "IM.Server.IMBuddyStorageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMBuddyStorageRsp::kReqUserIdFieldNumber;
const int IMBuddyStorageRsp::kReqCompanyIdFieldNumber;
const int IMBuddyStorageRsp::kDestUserIdFieldNumber;
const int IMBuddyStorageRsp::kDestCompanyIdFieldNumber;
const int IMBuddyStorageRsp::kOptTypeFieldNumber;
const int IMBuddyStorageRsp::kUpdateTimeFieldNumber;
const int IMBuddyStorageRsp::kResultFieldNumber;
#endif  // !_MSC_VER

IMBuddyStorageRsp::IMBuddyStorageRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMBuddyStorageRsp)
}

void IMBuddyStorageRsp::InitAsDefaultInstance() {
}

IMBuddyStorageRsp::IMBuddyStorageRsp(const IMBuddyStorageRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMBuddyStorageRsp)
}

void IMBuddyStorageRsp::SharedCtor() {
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  opt_type_ = 1;
  update_time_ = GOOGLE_ULONGLONG(0);
  result_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMBuddyStorageRsp::~IMBuddyStorageRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMBuddyStorageRsp)
  SharedDtor();
}

void IMBuddyStorageRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMBuddyStorageRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMBuddyStorageRsp& IMBuddyStorageRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMBuddyStorageRsp* IMBuddyStorageRsp::default_instance_ = NULL;

IMBuddyStorageRsp* IMBuddyStorageRsp::New() const {
  return new IMBuddyStorageRsp;
}

void IMBuddyStorageRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMBuddyStorageRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(req_user_id_, update_time_);
    opt_type_ = 1;
    result_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMBuddyStorageRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMBuddyStorageRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_opt_type;
        break;
      }

      // required .IM.BaseDefine.BuddyOptType opt_type = 5;
      case 5: {
        if (tag == 40) {
         parse_opt_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::BuddyOptType_IsValid(value)) {
            set_opt_type(static_cast< ::IM::BaseDefine::BuddyOptType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 6;
      case 6: {
        if (tag == 48) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_result;
        break;
      }

      // required .IM.BaseDefine.OptResultCode result = 7;
      case 7: {
        if (tag == 56) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::OptResultCode_IsValid(value)) {
            set_result(static_cast< ::IM::BaseDefine::OptResultCode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMBuddyStorageRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMBuddyStorageRsp)
  return false;
#undef DO_
}

void IMBuddyStorageRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMBuddyStorageRsp)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required .IM.BaseDefine.BuddyOptType opt_type = 5;
  if (has_opt_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->opt_type(), output);
  }

  // required uint64 update_time = 6;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->update_time(), output);
  }

  // required .IM.BaseDefine.OptResultCode result = 7;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMBuddyStorageRsp)
}

int IMBuddyStorageRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required .IM.BaseDefine.BuddyOptType opt_type = 5;
    if (has_opt_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->opt_type());
    }

    // required uint64 update_time = 6;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // required .IM.BaseDefine.OptResultCode result = 7;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMBuddyStorageRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMBuddyStorageRsp*>(&from));
}

void IMBuddyStorageRsp::MergeFrom(const IMBuddyStorageRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_opt_type()) {
      set_opt_type(from.opt_type());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMBuddyStorageRsp::CopyFrom(const IMBuddyStorageRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMBuddyStorageRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMBuddyStorageRsp::Swap(IMBuddyStorageRsp* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(opt_type_, other->opt_type_);
    std::swap(update_time_, other->update_time_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMBuddyStorageRsp::GetTypeName() const {
  return "IM.Server.IMBuddyStorageRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRecentContactStorageReq::kReqUserIdFieldNumber;
const int IMRecentContactStorageReq::kReqCompanyIdFieldNumber;
const int IMRecentContactStorageReq::kRecentContactFieldNumber;
#endif  // !_MSC_VER

IMRecentContactStorageReq::IMRecentContactStorageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMRecentContactStorageReq)
}

void IMRecentContactStorageReq::InitAsDefaultInstance() {
}

IMRecentContactStorageReq::IMRecentContactStorageReq(const IMRecentContactStorageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMRecentContactStorageReq)
}

void IMRecentContactStorageReq::SharedCtor() {
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRecentContactStorageReq::~IMRecentContactStorageReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMRecentContactStorageReq)
  SharedDtor();
}

void IMRecentContactStorageReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMRecentContactStorageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRecentContactStorageReq& IMRecentContactStorageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMRecentContactStorageReq* IMRecentContactStorageReq::default_instance_ = NULL;

IMRecentContactStorageReq* IMRecentContactStorageReq::New() const {
  return new IMRecentContactStorageReq;
}

void IMRecentContactStorageReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRecentContactStorageReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_user_id_, req_company_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  recent_contact_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRecentContactStorageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMRecentContactStorageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recent_contact;
        break;
      }

      // repeated .IM.Server.RecentContactItem recent_contact = 3;
      case 3: {
        if (tag == 26) {
         parse_recent_contact:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_recent_contact()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recent_contact;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMRecentContactStorageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMRecentContactStorageReq)
  return false;
#undef DO_
}

void IMRecentContactStorageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMRecentContactStorageReq)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // repeated .IM.Server.RecentContactItem recent_contact = 3;
  for (int i = 0; i < this->recent_contact_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->recent_contact(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMRecentContactStorageReq)
}

int IMRecentContactStorageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

  }
  // repeated .IM.Server.RecentContactItem recent_contact = 3;
  total_size += 1 * this->recent_contact_size();
  for (int i = 0; i < this->recent_contact_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->recent_contact(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRecentContactStorageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRecentContactStorageReq*>(&from));
}

void IMRecentContactStorageReq::MergeFrom(const IMRecentContactStorageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  recent_contact_.MergeFrom(from.recent_contact_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRecentContactStorageReq::CopyFrom(const IMRecentContactStorageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactStorageReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->recent_contact())) return false;
  return true;
}

void IMRecentContactStorageReq::Swap(IMRecentContactStorageReq* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    recent_contact_.Swap(&other->recent_contact_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRecentContactStorageReq::GetTypeName() const {
  return "IM.Server.IMRecentContactStorageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMRecentContactStorageRsp::kReqUserIdFieldNumber;
const int IMRecentContactStorageRsp::kReqCompanyIdFieldNumber;
const int IMRecentContactStorageRsp::kRecentContactFieldNumber;
#endif  // !_MSC_VER

IMRecentContactStorageRsp::IMRecentContactStorageRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMRecentContactStorageRsp)
}

void IMRecentContactStorageRsp::InitAsDefaultInstance() {
}

IMRecentContactStorageRsp::IMRecentContactStorageRsp(const IMRecentContactStorageRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMRecentContactStorageRsp)
}

void IMRecentContactStorageRsp::SharedCtor() {
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMRecentContactStorageRsp::~IMRecentContactStorageRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMRecentContactStorageRsp)
  SharedDtor();
}

void IMRecentContactStorageRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMRecentContactStorageRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMRecentContactStorageRsp& IMRecentContactStorageRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMRecentContactStorageRsp* IMRecentContactStorageRsp::default_instance_ = NULL;

IMRecentContactStorageRsp* IMRecentContactStorageRsp::New() const {
  return new IMRecentContactStorageRsp;
}

void IMRecentContactStorageRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMRecentContactStorageRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(req_user_id_, req_company_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  recent_contact_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMRecentContactStorageRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMRecentContactStorageRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recent_contact;
        break;
      }

      // repeated .IM.Server.RecentContactItem recent_contact = 3;
      case 3: {
        if (tag == 26) {
         parse_recent_contact:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_recent_contact()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_recent_contact;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMRecentContactStorageRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMRecentContactStorageRsp)
  return false;
#undef DO_
}

void IMRecentContactStorageRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMRecentContactStorageRsp)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // repeated .IM.Server.RecentContactItem recent_contact = 3;
  for (int i = 0; i < this->recent_contact_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->recent_contact(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMRecentContactStorageRsp)
}

int IMRecentContactStorageRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

  }
  // repeated .IM.Server.RecentContactItem recent_contact = 3;
  total_size += 1 * this->recent_contact_size();
  for (int i = 0; i < this->recent_contact_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->recent_contact(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMRecentContactStorageRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRecentContactStorageRsp*>(&from));
}

void IMRecentContactStorageRsp::MergeFrom(const IMRecentContactStorageRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  recent_contact_.MergeFrom(from.recent_contact_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMRecentContactStorageRsp::CopyFrom(const IMRecentContactStorageRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRecentContactStorageRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->recent_contact())) return false;
  return true;
}

void IMRecentContactStorageRsp::Swap(IMRecentContactStorageRsp* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    recent_contact_.Swap(&other->recent_contact_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMRecentContactStorageRsp::GetTypeName() const {
  return "IM.Server.IMRecentContactStorageRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMBuddyReqInfoStorage::kUserIdFieldNumber;
const int IMBuddyReqInfoStorage::kCompanyIdFieldNumber;
const int IMBuddyReqInfoStorage::kDestUserIdFieldNumber;
const int IMBuddyReqInfoStorage::kDestCompanyIdFieldNumber;
const int IMBuddyReqInfoStorage::kReqStatFieldNumber;
const int IMBuddyReqInfoStorage::kReqTimeFieldNumber;
const int IMBuddyReqInfoStorage::kRemarkFieldNumber;
#endif  // !_MSC_VER

IMBuddyReqInfoStorage::IMBuddyReqInfoStorage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMBuddyReqInfoStorage)
}

void IMBuddyReqInfoStorage::InitAsDefaultInstance() {
}

IMBuddyReqInfoStorage::IMBuddyReqInfoStorage(const IMBuddyReqInfoStorage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMBuddyReqInfoStorage)
}

void IMBuddyReqInfoStorage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  req_stat_ = 0u;
  req_time_ = GOOGLE_ULONGLONG(0);
  remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMBuddyReqInfoStorage::~IMBuddyReqInfoStorage() {
  // @@protoc_insertion_point(destructor:IM.Server.IMBuddyReqInfoStorage)
  SharedDtor();
}

void IMBuddyReqInfoStorage::SharedDtor() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMBuddyReqInfoStorage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMBuddyReqInfoStorage& IMBuddyReqInfoStorage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMBuddyReqInfoStorage* IMBuddyReqInfoStorage::default_instance_ = NULL;

IMBuddyReqInfoStorage* IMBuddyReqInfoStorage::New() const {
  return new IMBuddyReqInfoStorage;
}

void IMBuddyReqInfoStorage::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMBuddyReqInfoStorage*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(user_id_, req_time_);
    req_stat_ = 0u;
    if (has_remark()) {
      if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remark_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMBuddyReqInfoStorage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMBuddyReqInfoStorage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_company_id;
        break;
      }

      // required uint32 company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_req_stat;
        break;
      }

      // required uint32 req_stat = 5;
      case 5: {
        if (tag == 40) {
         parse_req_stat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_stat_)));
          set_has_req_stat();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_req_time;
        break;
      }

      // required uint64 req_time = 6;
      case 6: {
        if (tag == 48) {
         parse_req_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &req_time_)));
          set_has_req_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_remark;
        break;
      }

      // required string remark = 7;
      case 7: {
        if (tag == 58) {
         parse_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMBuddyReqInfoStorage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMBuddyReqInfoStorage)
  return false;
#undef DO_
}

void IMBuddyReqInfoStorage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMBuddyReqInfoStorage)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 company_id = 2;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required uint32 req_stat = 5;
  if (has_req_stat()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->req_stat(), output);
  }

  // required uint64 req_time = 6;
  if (has_req_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->req_time(), output);
  }

  // required string remark = 7;
  if (has_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->remark(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMBuddyReqInfoStorage)
}

int IMBuddyReqInfoStorage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 company_id = 2;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required uint32 req_stat = 5;
    if (has_req_stat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_stat());
    }

    // required uint64 req_time = 6;
    if (has_req_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->req_time());
    }

    // required string remark = 7;
    if (has_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remark());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMBuddyReqInfoStorage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMBuddyReqInfoStorage*>(&from));
}

void IMBuddyReqInfoStorage::MergeFrom(const IMBuddyReqInfoStorage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_req_stat()) {
      set_req_stat(from.req_stat());
    }
    if (from.has_req_time()) {
      set_req_time(from.req_time());
    }
    if (from.has_remark()) {
      set_remark(from.remark());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMBuddyReqInfoStorage::CopyFrom(const IMBuddyReqInfoStorage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMBuddyReqInfoStorage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMBuddyReqInfoStorage::Swap(IMBuddyReqInfoStorage* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(company_id_, other->company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(req_stat_, other->req_stat_);
    std::swap(req_time_, other->req_time_);
    std::swap(remark_, other->remark_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMBuddyReqInfoStorage::GetTypeName() const {
  return "IM.Server.IMBuddyReqInfoStorage";
}


// ===================================================================

#ifndef _MSC_VER
const int IMDelRecentContactReq::kReqUserIdFieldNumber;
const int IMDelRecentContactReq::kReqCompanyIdFieldNumber;
const int IMDelRecentContactReq::kDestUserIdFieldNumber;
const int IMDelRecentContactReq::kDestCompanyIdFieldNumber;
const int IMDelRecentContactReq::kOptTypeFieldNumber;
#endif  // !_MSC_VER

IMDelRecentContactReq::IMDelRecentContactReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMDelRecentContactReq)
}

void IMDelRecentContactReq::InitAsDefaultInstance() {
}

IMDelRecentContactReq::IMDelRecentContactReq(const IMDelRecentContactReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMDelRecentContactReq)
}

void IMDelRecentContactReq::SharedCtor() {
  _cached_size_ = 0;
  req_user_id_ = 0u;
  req_company_id_ = 0u;
  dest_user_id_ = 0u;
  dest_company_id_ = 0u;
  opt_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMDelRecentContactReq::~IMDelRecentContactReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMDelRecentContactReq)
  SharedDtor();
}

void IMDelRecentContactReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMDelRecentContactReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMDelRecentContactReq& IMDelRecentContactReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMDelRecentContactReq* IMDelRecentContactReq::default_instance_ = NULL;

IMDelRecentContactReq* IMDelRecentContactReq::New() const {
  return new IMDelRecentContactReq;
}

void IMDelRecentContactReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMDelRecentContactReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(req_user_id_, dest_company_id_);
    opt_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMDelRecentContactReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMDelRecentContactReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 req_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_user_id_)));
          set_has_req_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_req_company_id;
        break;
      }

      // required uint32 req_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_req_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &req_company_id_)));
          set_has_req_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dest_user_id;
        break;
      }

      // required uint32 dest_user_id = 3;
      case 3: {
        if (tag == 24) {
         parse_dest_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_user_id_)));
          set_has_dest_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dest_company_id;
        break;
      }

      // required uint32 dest_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_dest_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_company_id_)));
          set_has_dest_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_opt_type;
        break;
      }

      // required .IM.BaseDefine.BuddyOptType opt_type = 5;
      case 5: {
        if (tag == 40) {
         parse_opt_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::BuddyOptType_IsValid(value)) {
            set_opt_type(static_cast< ::IM::BaseDefine::BuddyOptType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMDelRecentContactReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMDelRecentContactReq)
  return false;
#undef DO_
}

void IMDelRecentContactReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMDelRecentContactReq)
  // required uint32 req_user_id = 1;
  if (has_req_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->req_user_id(), output);
  }

  // required uint32 req_company_id = 2;
  if (has_req_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->req_company_id(), output);
  }

  // required uint32 dest_user_id = 3;
  if (has_dest_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dest_user_id(), output);
  }

  // required uint32 dest_company_id = 4;
  if (has_dest_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dest_company_id(), output);
  }

  // required .IM.BaseDefine.BuddyOptType opt_type = 5;
  if (has_opt_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->opt_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMDelRecentContactReq)
}

int IMDelRecentContactReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 req_user_id = 1;
    if (has_req_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_user_id());
    }

    // required uint32 req_company_id = 2;
    if (has_req_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->req_company_id());
    }

    // required uint32 dest_user_id = 3;
    if (has_dest_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_user_id());
    }

    // required uint32 dest_company_id = 4;
    if (has_dest_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_company_id());
    }

    // required .IM.BaseDefine.BuddyOptType opt_type = 5;
    if (has_opt_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->opt_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMDelRecentContactReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMDelRecentContactReq*>(&from));
}

void IMDelRecentContactReq::MergeFrom(const IMDelRecentContactReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req_user_id()) {
      set_req_user_id(from.req_user_id());
    }
    if (from.has_req_company_id()) {
      set_req_company_id(from.req_company_id());
    }
    if (from.has_dest_user_id()) {
      set_dest_user_id(from.dest_user_id());
    }
    if (from.has_dest_company_id()) {
      set_dest_company_id(from.dest_company_id());
    }
    if (from.has_opt_type()) {
      set_opt_type(from.opt_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMDelRecentContactReq::CopyFrom(const IMDelRecentContactReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMDelRecentContactReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMDelRecentContactReq::Swap(IMDelRecentContactReq* other) {
  if (other != this) {
    std::swap(req_user_id_, other->req_user_id_);
    std::swap(req_company_id_, other->req_company_id_);
    std::swap(dest_user_id_, other->dest_user_id_);
    std::swap(dest_company_id_, other->dest_company_id_);
    std::swap(opt_type_, other->opt_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMDelRecentContactReq::GetTypeName() const {
  return "IM.Server.IMDelRecentContactReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMAlterPswdReq::kCompanyIdFieldNumber;
const int IMAlterPswdReq::kUserIdFieldNumber;
const int IMAlterPswdReq::kNewPswdFieldNumber;
const int IMAlterPswdReq::kOldPswdFieldNumber;
#endif  // !_MSC_VER

IMAlterPswdReq::IMAlterPswdReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMAlterPswdReq)
}

void IMAlterPswdReq::InitAsDefaultInstance() {
}

IMAlterPswdReq::IMAlterPswdReq(const IMAlterPswdReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMAlterPswdReq)
}

void IMAlterPswdReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  new_pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  old_pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMAlterPswdReq::~IMAlterPswdReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMAlterPswdReq)
  SharedDtor();
}

void IMAlterPswdReq::SharedDtor() {
  if (new_pswd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_pswd_;
  }
  if (old_pswd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete old_pswd_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMAlterPswdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMAlterPswdReq& IMAlterPswdReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMAlterPswdReq* IMAlterPswdReq::default_instance_ = NULL;

IMAlterPswdReq* IMAlterPswdReq::New() const {
  return new IMAlterPswdReq;
}

void IMAlterPswdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMAlterPswdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(company_id_, user_id_);
    if (has_new_pswd()) {
      if (new_pswd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        new_pswd_->clear();
      }
    }
    if (has_old_pswd()) {
      if (old_pswd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        old_pswd_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMAlterPswdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMAlterPswdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_new_pswd;
        break;
      }

      // required string new_pswd = 3;
      case 3: {
        if (tag == 26) {
         parse_new_pswd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_new_pswd()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_old_pswd;
        break;
      }

      // required string old_pswd = 4;
      case 4: {
        if (tag == 34) {
         parse_old_pswd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_old_pswd()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMAlterPswdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMAlterPswdReq)
  return false;
#undef DO_
}

void IMAlterPswdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMAlterPswdReq)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required string new_pswd = 3;
  if (has_new_pswd()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->new_pswd(), output);
  }

  // required string old_pswd = 4;
  if (has_old_pswd()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->old_pswd(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMAlterPswdReq)
}

int IMAlterPswdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required string new_pswd = 3;
    if (has_new_pswd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->new_pswd());
    }

    // required string old_pswd = 4;
    if (has_old_pswd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->old_pswd());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMAlterPswdReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMAlterPswdReq*>(&from));
}

void IMAlterPswdReq::MergeFrom(const IMAlterPswdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_new_pswd()) {
      set_new_pswd(from.new_pswd());
    }
    if (from.has_old_pswd()) {
      set_old_pswd(from.old_pswd());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMAlterPswdReq::CopyFrom(const IMAlterPswdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAlterPswdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void IMAlterPswdReq::Swap(IMAlterPswdReq* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(new_pswd_, other->new_pswd_);
    std::swap(old_pswd_, other->old_pswd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMAlterPswdReq::GetTypeName() const {
  return "IM.Server.IMAlterPswdReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMAlterPswdRsp::kCompanyIdFieldNumber;
const int IMAlterPswdRsp::kUserIdFieldNumber;
const int IMAlterPswdRsp::kResultCodeFieldNumber;
#endif  // !_MSC_VER

IMAlterPswdRsp::IMAlterPswdRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMAlterPswdRsp)
}

void IMAlterPswdRsp::InitAsDefaultInstance() {
}

IMAlterPswdRsp::IMAlterPswdRsp(const IMAlterPswdRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMAlterPswdRsp)
}

void IMAlterPswdRsp::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMAlterPswdRsp::~IMAlterPswdRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMAlterPswdRsp)
  SharedDtor();
}

void IMAlterPswdRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMAlterPswdRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMAlterPswdRsp& IMAlterPswdRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMAlterPswdRsp* IMAlterPswdRsp::default_instance_ = NULL;

IMAlterPswdRsp* IMAlterPswdRsp::New() const {
  return new IMAlterPswdRsp;
}

void IMAlterPswdRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMAlterPswdRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(company_id_, user_id_);
    result_code_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMAlterPswdRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMAlterPswdRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result_code;
        break;
      }

      // required .IM.BaseDefine.OptResultCode result_code = 3;
      case 3: {
        if (tag == 24) {
         parse_result_code:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::OptResultCode_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::OptResultCode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMAlterPswdRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMAlterPswdRsp)
  return false;
#undef DO_
}

void IMAlterPswdRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMAlterPswdRsp)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.OptResultCode result_code = 3;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->result_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMAlterPswdRsp)
}

int IMAlterPswdRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.OptResultCode result_code = 3;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMAlterPswdRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMAlterPswdRsp*>(&from));
}

void IMAlterPswdRsp::MergeFrom(const IMAlterPswdRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMAlterPswdRsp::CopyFrom(const IMAlterPswdRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAlterPswdRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMAlterPswdRsp::Swap(IMAlterPswdRsp* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(result_code_, other->result_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMAlterPswdRsp::GetTypeName() const {
  return "IM.Server.IMAlterPswdRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMReportOnlineInfo::kCompanyIdFieldNumber;
const int IMReportOnlineInfo::kNodeIdFieldNumber;
const int IMReportOnlineInfo::kOnlineCountFieldNumber;
const int IMReportOnlineInfo::kOnlinePeekFieldNumber;
const int IMReportOnlineInfo::kUpdateTimeFieldNumber;
#endif  // !_MSC_VER

IMReportOnlineInfo::IMReportOnlineInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMReportOnlineInfo)
}

void IMReportOnlineInfo::InitAsDefaultInstance() {
}

IMReportOnlineInfo::IMReportOnlineInfo(const IMReportOnlineInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMReportOnlineInfo)
}

void IMReportOnlineInfo::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  node_id_ = 0u;
  online_count_ = 0u;
  online_peek_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMReportOnlineInfo::~IMReportOnlineInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMReportOnlineInfo)
  SharedDtor();
}

void IMReportOnlineInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMReportOnlineInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMReportOnlineInfo& IMReportOnlineInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMReportOnlineInfo* IMReportOnlineInfo::default_instance_ = NULL;

IMReportOnlineInfo* IMReportOnlineInfo::New() const {
  return new IMReportOnlineInfo;
}

void IMReportOnlineInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMReportOnlineInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(company_id_, update_time_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMReportOnlineInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMReportOnlineInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // required uint32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_online_count;
        break;
      }

      // required uint32 online_count = 3;
      case 3: {
        if (tag == 24) {
         parse_online_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_count_)));
          set_has_online_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_peek;
        break;
      }

      // required uint32 online_peek = 4;
      case 4: {
        if (tag == 32) {
         parse_online_peek:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &online_peek_)));
          set_has_online_peek();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 5;
      case 5: {
        if (tag == 40) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMReportOnlineInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMReportOnlineInfo)
  return false;
#undef DO_
}

void IMReportOnlineInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMReportOnlineInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->node_id(), output);
  }

  // required uint32 online_count = 3;
  if (has_online_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->online_count(), output);
  }

  // required uint32 online_peek = 4;
  if (has_online_peek()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->online_peek(), output);
  }

  // required uint64 update_time = 5;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->update_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMReportOnlineInfo)
}

int IMReportOnlineInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required uint32 online_count = 3;
    if (has_online_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_count());
    }

    // required uint32 online_peek = 4;
    if (has_online_peek()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->online_peek());
    }

    // required uint64 update_time = 5;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMReportOnlineInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMReportOnlineInfo*>(&from));
}

void IMReportOnlineInfo::MergeFrom(const IMReportOnlineInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_online_count()) {
      set_online_count(from.online_count());
    }
    if (from.has_online_peek()) {
      set_online_peek(from.online_peek());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMReportOnlineInfo::CopyFrom(const IMReportOnlineInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMReportOnlineInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMReportOnlineInfo::Swap(IMReportOnlineInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(node_id_, other->node_id_);
    std::swap(online_count_, other->online_count_);
    std::swap(online_peek_, other->online_peek_);
    std::swap(update_time_, other->update_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMReportOnlineInfo::GetTypeName() const {
  return "IM.Server.IMReportOnlineInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMReportChatInfo::kCompanyIdFieldNumber;
const int IMReportChatInfo::kSessionTypeFieldNumber;
const int IMReportChatInfo::kNodeIdFieldNumber;
const int IMReportChatInfo::kOnlineCountFieldNumber;
const int IMReportChatInfo::kOfflineCountFieldNumber;
const int IMReportChatInfo::kUpdateTimeFieldNumber;
#endif  // !_MSC_VER

IMReportChatInfo::IMReportChatInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMReportChatInfo)
}

void IMReportChatInfo::InitAsDefaultInstance() {
}

IMReportChatInfo::IMReportChatInfo(const IMReportChatInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMReportChatInfo)
}

void IMReportChatInfo::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  session_type_ = 1;
  node_id_ = 0u;
  online_count_ = GOOGLE_ULONGLONG(0);
  offline_count_ = GOOGLE_ULONGLONG(0);
  update_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMReportChatInfo::~IMReportChatInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMReportChatInfo)
  SharedDtor();
}

void IMReportChatInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMReportChatInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMReportChatInfo& IMReportChatInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMReportChatInfo* IMReportChatInfo::default_instance_ = NULL;

IMReportChatInfo* IMReportChatInfo::New() const {
  return new IMReportChatInfo;
}

void IMReportChatInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMReportChatInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(online_count_, node_id_);
    company_id_ = 0u;
    session_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMReportChatInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMReportChatInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2: {
        if (tag == 16) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_node_id;
        break;
      }

      // required uint32 node_id = 3;
      case 3: {
        if (tag == 24) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_online_count;
        break;
      }

      // required uint64 online_count = 4;
      case 4: {
        if (tag == 32) {
         parse_online_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &online_count_)));
          set_has_online_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_offline_count;
        break;
      }

      // required uint64 offline_count = 5;
      case 5: {
        if (tag == 40) {
         parse_offline_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offline_count_)));
          set_has_offline_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 6;
      case 6: {
        if (tag == 48) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMReportChatInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMReportChatInfo)
  return false;
#undef DO_
}

void IMReportChatInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMReportChatInfo)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->session_type(), output);
  }

  // required uint32 node_id = 3;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->node_id(), output);
  }

  // required uint64 online_count = 4;
  if (has_online_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->online_count(), output);
  }

  // required uint64 offline_count = 5;
  if (has_offline_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->offline_count(), output);
  }

  // required uint64 update_time = 6;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->update_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMReportChatInfo)
}

int IMReportChatInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 2;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint32 node_id = 3;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required uint64 online_count = 4;
    if (has_online_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->online_count());
    }

    // required uint64 offline_count = 5;
    if (has_offline_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offline_count());
    }

    // required uint64 update_time = 6;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMReportChatInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMReportChatInfo*>(&from));
}

void IMReportChatInfo::MergeFrom(const IMReportChatInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_online_count()) {
      set_online_count(from.online_count());
    }
    if (from.has_offline_count()) {
      set_offline_count(from.offline_count());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMReportChatInfo::CopyFrom(const IMReportChatInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMReportChatInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMReportChatInfo::Swap(IMReportChatInfo* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(node_id_, other->node_id_);
    std::swap(online_count_, other->online_count_);
    std::swap(offline_count_, other->offline_count_);
    std::swap(update_time_, other->update_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMReportChatInfo::GetTypeName() const {
  return "IM.Server.IMReportChatInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetUserRoleReq::kCompanyIdFieldNumber;
const int IMGetUserRoleReq::kUserIdFieldNumber;
#endif  // !_MSC_VER

IMGetUserRoleReq::IMGetUserRoleReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetUserRoleReq)
}

void IMGetUserRoleReq::InitAsDefaultInstance() {
}

IMGetUserRoleReq::IMGetUserRoleReq(const IMGetUserRoleReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetUserRoleReq)
}

void IMGetUserRoleReq::SharedCtor() {
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetUserRoleReq::~IMGetUserRoleReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetUserRoleReq)
  SharedDtor();
}

void IMGetUserRoleReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetUserRoleReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetUserRoleReq& IMGetUserRoleReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMGetUserRoleReq* IMGetUserRoleReq::default_instance_ = NULL;

IMGetUserRoleReq* IMGetUserRoleReq::New() const {
  return new IMGetUserRoleReq;
}

void IMGetUserRoleReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetUserRoleReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(company_id_, user_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetUserRoleReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetUserRoleReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetUserRoleReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetUserRoleReq)
  return false;
#undef DO_
}

void IMGetUserRoleReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetUserRoleReq)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetUserRoleReq)
}

int IMGetUserRoleReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetUserRoleReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetUserRoleReq*>(&from));
}

void IMGetUserRoleReq::MergeFrom(const IMGetUserRoleReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetUserRoleReq::CopyFrom(const IMGetUserRoleReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetUserRoleReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMGetUserRoleReq::Swap(IMGetUserRoleReq* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetUserRoleReq::GetTypeName() const {
  return "IM.Server.IMGetUserRoleReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMUserRoleAuthorityRsp::kRoleFieldNumber;
#endif  // !_MSC_VER

IMUserRoleAuthorityRsp::IMUserRoleAuthorityRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserRoleAuthorityRsp)
}

void IMUserRoleAuthorityRsp::InitAsDefaultInstance() {
}

IMUserRoleAuthorityRsp::IMUserRoleAuthorityRsp(const IMUserRoleAuthorityRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserRoleAuthorityRsp)
}

void IMUserRoleAuthorityRsp::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMUserRoleAuthorityRsp::~IMUserRoleAuthorityRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserRoleAuthorityRsp)
  SharedDtor();
}

void IMUserRoleAuthorityRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMUserRoleAuthorityRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMUserRoleAuthorityRsp& IMUserRoleAuthorityRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMUserRoleAuthorityRsp* IMUserRoleAuthorityRsp::default_instance_ = NULL;

IMUserRoleAuthorityRsp* IMUserRoleAuthorityRsp::New() const {
  return new IMUserRoleAuthorityRsp;
}

void IMUserRoleAuthorityRsp::Clear() {
  role_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMUserRoleAuthorityRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserRoleAuthorityRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.IMUserRole role = 1;
      case 1: {
        if (tag == 10) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_role()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_role;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserRoleAuthorityRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserRoleAuthorityRsp)
  return false;
#undef DO_
}

void IMUserRoleAuthorityRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserRoleAuthorityRsp)
  // repeated .IM.BaseDefine.IMUserRole role = 1;
  for (int i = 0; i < this->role_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->role(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserRoleAuthorityRsp)
}

int IMUserRoleAuthorityRsp::ByteSize() const {
  int total_size = 0;

  // repeated .IM.BaseDefine.IMUserRole role = 1;
  total_size += 1 * this->role_size();
  for (int i = 0; i < this->role_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->role(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMUserRoleAuthorityRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserRoleAuthorityRsp*>(&from));
}

void IMUserRoleAuthorityRsp::MergeFrom(const IMUserRoleAuthorityRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  role_.MergeFrom(from.role_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMUserRoleAuthorityRsp::CopyFrom(const IMUserRoleAuthorityRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserRoleAuthorityRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->role())) return false;
  return true;
}

void IMUserRoleAuthorityRsp::Swap(IMUserRoleAuthorityRsp* other) {
  if (other != this) {
    role_.Swap(&other->role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMUserRoleAuthorityRsp::GetTypeName() const {
  return "IM.Server.IMUserRoleAuthorityRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMAuthenticationReq::kTypeFieldNumber;
const int IMAuthenticationReq::kNodeIdFieldNumber;
#endif  // !_MSC_VER

IMAuthenticationReq::IMAuthenticationReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMAuthenticationReq)
}

void IMAuthenticationReq::InitAsDefaultInstance() {
}

IMAuthenticationReq::IMAuthenticationReq(const IMAuthenticationReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMAuthenticationReq)
}

void IMAuthenticationReq::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  node_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMAuthenticationReq::~IMAuthenticationReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMAuthenticationReq)
  SharedDtor();
}

void IMAuthenticationReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMAuthenticationReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMAuthenticationReq& IMAuthenticationReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMAuthenticationReq* IMAuthenticationReq::default_instance_ = NULL;

IMAuthenticationReq* IMAuthenticationReq::New() const {
  return new IMAuthenticationReq;
}

void IMAuthenticationReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    type_ = 1;
    node_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMAuthenticationReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMAuthenticationReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ServiceID type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ServiceID_IsValid(value)) {
            set_type(static_cast< ::IM::BaseDefine::ServiceID >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // required uint32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMAuthenticationReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMAuthenticationReq)
  return false;
#undef DO_
}

void IMAuthenticationReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMAuthenticationReq)
  // required .IM.BaseDefine.ServiceID type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->node_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMAuthenticationReq)
}

int IMAuthenticationReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ServiceID type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMAuthenticationReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMAuthenticationReq*>(&from));
}

void IMAuthenticationReq::MergeFrom(const IMAuthenticationReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMAuthenticationReq::CopyFrom(const IMAuthenticationReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAuthenticationReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMAuthenticationReq::Swap(IMAuthenticationReq* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(node_id_, other->node_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMAuthenticationReq::GetTypeName() const {
  return "IM.Server.IMAuthenticationReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMAuthenticationRsp::kTypeFieldNumber;
const int IMAuthenticationRsp::kNodeIdFieldNumber;
const int IMAuthenticationRsp::kResultFieldNumber;
const int IMAuthenticationRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMAuthenticationRsp::IMAuthenticationRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMAuthenticationRsp)
}

void IMAuthenticationRsp::InitAsDefaultInstance() {
}

IMAuthenticationRsp::IMAuthenticationRsp(const IMAuthenticationRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMAuthenticationRsp)
}

void IMAuthenticationRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  node_id_ = 0u;
  result_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMAuthenticationRsp::~IMAuthenticationRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMAuthenticationRsp)
  SharedDtor();
}

void IMAuthenticationRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMAuthenticationRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMAuthenticationRsp& IMAuthenticationRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eServer_2eproto();
#endif
  return *default_instance_;
}

IMAuthenticationRsp* IMAuthenticationRsp::default_instance_ = NULL;

IMAuthenticationRsp* IMAuthenticationRsp::New() const {
  return new IMAuthenticationRsp;
}

void IMAuthenticationRsp::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    type_ = 1;
    node_id_ = 0u;
    result_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMAuthenticationRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.IMAuthenticationRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ServiceID type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ServiceID_IsValid(value)) {
            set_type(static_cast< ::IM::BaseDefine::ServiceID >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // required uint32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_result;
        break;
      }

      // required uint32 result = 3;
      case 3: {
        if (tag == 24) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMAuthenticationRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMAuthenticationRsp)
  return false;
#undef DO_
}

void IMAuthenticationRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMAuthenticationRsp)
  // required .IM.BaseDefine.ServiceID type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->node_id(), output);
  }

  // required uint32 result = 3;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->result(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.IMAuthenticationRsp)
}

int IMAuthenticationRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ServiceID type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required uint32 result = 3;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMAuthenticationRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMAuthenticationRsp*>(&from));
}

void IMAuthenticationRsp::MergeFrom(const IMAuthenticationRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMAuthenticationRsp::CopyFrom(const IMAuthenticationRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMAuthenticationRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void IMAuthenticationRsp::Swap(IMAuthenticationRsp* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(node_id_, other->node_id_);
    std::swap(result_, other->result_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMAuthenticationRsp::GetTypeName() const {
  return "IM.Server.IMAuthenticationRsp";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace IM

// @@protoc_insertion_point(global_scope)
