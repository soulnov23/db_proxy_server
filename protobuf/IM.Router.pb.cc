// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Router.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Router.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Server {

void protobuf_ShutdownFile_IM_2eRouter_2eproto() {
  delete PayloadInfo::default_instance_;
  delete ServerStatus::default_instance_;
  delete RegisterServerReq::default_instance_;
  delete RegisterServerRsp::default_instance_;
  delete GetAllServerStatusReq::default_instance_;
  delete GetAllServerStatusRsp::default_instance_;
  delete ServerStatusUpdateReq::default_instance_;
  delete ServerStatusUpdateRsp::default_instance_;
  delete ServerStatusPush::default_instance_;
  delete MessageHeader::default_instance_;
  delete BroadcastMessageReq::default_instance_;
  delete BroadcastMessageRsp::default_instance_;
  delete BroadcastPush::default_instance_;
  delete ConnNode::default_instance_;
  delete SrvAddrNode::default_instance_;
  delete ConnSrvStatusReport::default_instance_;
  delete ConnSrvListStatusReq::default_instance_;
  delete ConnSrvListStatusPush::default_instance_;
  delete ServerStopPush::default_instance_;
  delete ServerLocalCacheRefreshNotify::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eRouter_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eRouter_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  PayloadInfo::default_instance_ = new PayloadInfo();
  ServerStatus::default_instance_ = new ServerStatus();
  RegisterServerReq::default_instance_ = new RegisterServerReq();
  RegisterServerRsp::default_instance_ = new RegisterServerRsp();
  GetAllServerStatusReq::default_instance_ = new GetAllServerStatusReq();
  GetAllServerStatusRsp::default_instance_ = new GetAllServerStatusRsp();
  ServerStatusUpdateReq::default_instance_ = new ServerStatusUpdateReq();
  ServerStatusUpdateRsp::default_instance_ = new ServerStatusUpdateRsp();
  ServerStatusPush::default_instance_ = new ServerStatusPush();
  MessageHeader::default_instance_ = new MessageHeader();
  BroadcastMessageReq::default_instance_ = new BroadcastMessageReq();
  BroadcastMessageRsp::default_instance_ = new BroadcastMessageRsp();
  BroadcastPush::default_instance_ = new BroadcastPush();
  ConnNode::default_instance_ = new ConnNode();
  SrvAddrNode::default_instance_ = new SrvAddrNode();
  ConnSrvStatusReport::default_instance_ = new ConnSrvStatusReport();
  ConnSrvListStatusReq::default_instance_ = new ConnSrvListStatusReq();
  ConnSrvListStatusPush::default_instance_ = new ConnSrvListStatusPush();
  ServerStopPush::default_instance_ = new ServerStopPush();
  ServerLocalCacheRefreshNotify::default_instance_ = new ServerLocalCacheRefreshNotify();
  PayloadInfo::default_instance_->InitAsDefaultInstance();
  ServerStatus::default_instance_->InitAsDefaultInstance();
  RegisterServerReq::default_instance_->InitAsDefaultInstance();
  RegisterServerRsp::default_instance_->InitAsDefaultInstance();
  GetAllServerStatusReq::default_instance_->InitAsDefaultInstance();
  GetAllServerStatusRsp::default_instance_->InitAsDefaultInstance();
  ServerStatusUpdateReq::default_instance_->InitAsDefaultInstance();
  ServerStatusUpdateRsp::default_instance_->InitAsDefaultInstance();
  ServerStatusPush::default_instance_->InitAsDefaultInstance();
  MessageHeader::default_instance_->InitAsDefaultInstance();
  BroadcastMessageReq::default_instance_->InitAsDefaultInstance();
  BroadcastMessageRsp::default_instance_->InitAsDefaultInstance();
  BroadcastPush::default_instance_->InitAsDefaultInstance();
  ConnNode::default_instance_->InitAsDefaultInstance();
  SrvAddrNode::default_instance_->InitAsDefaultInstance();
  ConnSrvStatusReport::default_instance_->InitAsDefaultInstance();
  ConnSrvListStatusReq::default_instance_->InitAsDefaultInstance();
  ConnSrvListStatusPush::default_instance_->InitAsDefaultInstance();
  ServerStopPush::default_instance_->InitAsDefaultInstance();
  ServerLocalCacheRefreshNotify::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eRouter_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eRouter_2eproto_once_);
void protobuf_AddDesc_IM_2eRouter_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eRouter_2eproto_once_,
                 &protobuf_AddDesc_IM_2eRouter_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eRouter_2eproto {
  StaticDescriptorInitializer_IM_2eRouter_2eproto() {
    protobuf_AddDesc_IM_2eRouter_2eproto();
  }
} static_descriptor_initializer_IM_2eRouter_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int PayloadInfo::kResourcePayloadFieldNumber;
const int PayloadInfo::kMaxResourceNumFieldNumber;
#endif  // !_MSC_VER

PayloadInfo::PayloadInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.PayloadInfo)
}

void PayloadInfo::InitAsDefaultInstance() {
}

PayloadInfo::PayloadInfo(const PayloadInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.PayloadInfo)
}

void PayloadInfo::SharedCtor() {
  _cached_size_ = 0;
  resource_payload_ = 0u;
  max_resource_num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PayloadInfo::~PayloadInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.PayloadInfo)
  SharedDtor();
}

void PayloadInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PayloadInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PayloadInfo& PayloadInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

PayloadInfo* PayloadInfo::default_instance_ = NULL;

PayloadInfo* PayloadInfo::New() const {
  return new PayloadInfo;
}

void PayloadInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PayloadInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(resource_payload_, max_resource_num_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PayloadInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.PayloadInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 resource_payload = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &resource_payload_)));
          set_has_resource_payload();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_resource_num;
        break;
      }

      // optional uint32 max_resource_num = 2;
      case 2: {
        if (tag == 16) {
         parse_max_resource_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_resource_num_)));
          set_has_max_resource_num();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.PayloadInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.PayloadInfo)
  return false;
#undef DO_
}

void PayloadInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.PayloadInfo)
  // optional uint32 resource_payload = 1;
  if (has_resource_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->resource_payload(), output);
  }

  // optional uint32 max_resource_num = 2;
  if (has_max_resource_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_resource_num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.PayloadInfo)
}

int PayloadInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 resource_payload = 1;
    if (has_resource_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->resource_payload());
    }

    // optional uint32 max_resource_num = 2;
    if (has_max_resource_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_resource_num());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PayloadInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PayloadInfo*>(&from));
}

void PayloadInfo::MergeFrom(const PayloadInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resource_payload()) {
      set_resource_payload(from.resource_payload());
    }
    if (from.has_max_resource_num()) {
      set_max_resource_num(from.max_resource_num());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PayloadInfo::CopyFrom(const PayloadInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PayloadInfo::IsInitialized() const {

  return true;
}

void PayloadInfo::Swap(PayloadInfo* other) {
  if (other != this) {
    std::swap(resource_payload_, other->resource_payload_);
    std::swap(max_resource_num_, other->max_resource_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PayloadInfo::GetTypeName() const {
  return "IM.Server.PayloadInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerStatus::kNodeIdFieldNumber;
const int ServerStatus::kServiceTypeFieldNumber;
const int ServerStatus::kServerIpFieldNumber;
const int ServerStatus::kServerPortFieldNumber;
const int ServerStatus::kIsEnableFieldNumber;
const int ServerStatus::kPayloadFieldNumber;
#endif  // !_MSC_VER

ServerStatus::ServerStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerStatus)
}

void ServerStatus::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  payload_ = const_cast< ::IM::Server::PayloadInfo*>(
      ::IM::Server::PayloadInfo::internal_default_instance());
#else
  payload_ = const_cast< ::IM::Server::PayloadInfo*>(&::IM::Server::PayloadInfo::default_instance());
#endif
}

ServerStatus::ServerStatus(const ServerStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerStatus)
}

void ServerStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_id_ = 0u;
  server_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_port_ = 0u;
  is_enable_ = false;
  payload_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerStatus::~ServerStatus() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerStatus)
  SharedDtor();
}

void ServerStatus::SharedDtor() {
  if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete payload_;
  }
}

void ServerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerStatus& ServerStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerStatus* ServerStatus::default_instance_ = NULL;

ServerStatus* ServerStatus::New() const {
  return new ServerStatus;
}

void ServerStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ServerStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 61) {
    ZR_(node_id_, server_port_);
    if (has_server_ip()) {
      if (server_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        server_ip_->clear();
      }
    }
    is_enable_ = false;
    if (has_payload()) {
      if (payload_ != NULL) payload_->::IM::Server::PayloadInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  service_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 node_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_service_type;
        break;
      }

      // repeated .IM.BaseDefine.ServiceID service_type = 2;
      case 2: {
        if (tag == 16) {
         parse_service_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ServiceID_IsValid(value)) {
            add_service_type(static_cast< ::IM::BaseDefine::ServiceID >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::IM::BaseDefine::ServiceID_IsValid,
                 this->mutable_service_type())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_service_type;
        if (input->ExpectTag(26)) goto parse_server_ip;
        break;
      }

      // required string server_ip = 3;
      case 3: {
        if (tag == 26) {
         parse_server_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_server_port;
        break;
      }

      // required uint32 server_port = 4;
      case 4: {
        if (tag == 32) {
         parse_server_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_port_)));
          set_has_server_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_is_enable;
        break;
      }

      // required bool is_enable = 5;
      case 5: {
        if (tag == 40) {
         parse_is_enable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_enable_)));
          set_has_is_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_payload;
        break;
      }

      // optional .IM.Server.PayloadInfo payload = 6;
      case 6: {
        if (tag == 50) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_payload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerStatus)
  return false;
#undef DO_
}

void ServerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerStatus)
  // required uint32 node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->node_id(), output);
  }

  // repeated .IM.BaseDefine.ServiceID service_type = 2;
  for (int i = 0; i < this->service_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->service_type(i), output);
  }

  // required string server_ip = 3;
  if (has_server_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->server_ip(), output);
  }

  // required uint32 server_port = 4;
  if (has_server_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->server_port(), output);
  }

  // required bool is_enable = 5;
  if (has_is_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->is_enable(), output);
  }

  // optional .IM.Server.PayloadInfo payload = 6;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerStatus)
}

int ServerStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required string server_ip = 3;
    if (has_server_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server_ip());
    }

    // required uint32 server_port = 4;
    if (has_server_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_port());
    }

    // required bool is_enable = 5;
    if (has_is_enable()) {
      total_size += 1 + 1;
    }

    // optional .IM.Server.PayloadInfo payload = 6;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->payload());
    }

  }
  // repeated .IM.BaseDefine.ServiceID service_type = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->service_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->service_type(i));
    }
    total_size += 1 * this->service_type_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerStatus*>(&from));
}

void ServerStatus::MergeFrom(const ServerStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  service_type_.MergeFrom(from.service_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_server_ip()) {
      set_server_ip(from.server_ip());
    }
    if (from.has_server_port()) {
      set_server_port(from.server_port());
    }
    if (from.has_is_enable()) {
      set_is_enable(from.is_enable());
    }
    if (from.has_payload()) {
      mutable_payload()->::IM::Server::PayloadInfo::MergeFrom(from.payload());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerStatus::CopyFrom(const ServerStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001d) != 0x0000001d) return false;

  return true;
}

void ServerStatus::Swap(ServerStatus* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    service_type_.Swap(&other->service_type_);
    std::swap(server_ip_, other->server_ip_);
    std::swap(server_port_, other->server_port_);
    std::swap(is_enable_, other->is_enable_);
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerStatus::GetTypeName() const {
  return "IM.Server.ServerStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterServerReq::kCurrentServerFieldNumber;
#endif  // !_MSC_VER

RegisterServerReq::RegisterServerReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.RegisterServerReq)
}

void RegisterServerReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  current_server_ = const_cast< ::IM::Server::ServerStatus*>(
      ::IM::Server::ServerStatus::internal_default_instance());
#else
  current_server_ = const_cast< ::IM::Server::ServerStatus*>(&::IM::Server::ServerStatus::default_instance());
#endif
}

RegisterServerReq::RegisterServerReq(const RegisterServerReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.RegisterServerReq)
}

void RegisterServerReq::SharedCtor() {
  _cached_size_ = 0;
  current_server_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterServerReq::~RegisterServerReq() {
  // @@protoc_insertion_point(destructor:IM.Server.RegisterServerReq)
  SharedDtor();
}

void RegisterServerReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete current_server_;
  }
}

void RegisterServerReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterServerReq& RegisterServerReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

RegisterServerReq* RegisterServerReq::default_instance_ = NULL;

RegisterServerReq* RegisterServerReq::New() const {
  return new RegisterServerReq;
}

void RegisterServerReq::Clear() {
  if (has_current_server()) {
    if (current_server_ != NULL) current_server_->::IM::Server::ServerStatus::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegisterServerReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.RegisterServerReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.Server.ServerStatus current_server = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_current_server()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.RegisterServerReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.RegisterServerReq)
  return false;
#undef DO_
}

void RegisterServerReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.RegisterServerReq)
  // required .IM.Server.ServerStatus current_server = 1;
  if (has_current_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->current_server(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.RegisterServerReq)
}

int RegisterServerReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.Server.ServerStatus current_server = 1;
    if (has_current_server()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->current_server());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterServerReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterServerReq*>(&from));
}

void RegisterServerReq::MergeFrom(const RegisterServerReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_current_server()) {
      mutable_current_server()->::IM::Server::ServerStatus::MergeFrom(from.current_server());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegisterServerReq::CopyFrom(const RegisterServerReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterServerReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_current_server()) {
    if (!this->current_server().IsInitialized()) return false;
  }
  return true;
}

void RegisterServerReq::Swap(RegisterServerReq* other) {
  if (other != this) {
    std::swap(current_server_, other->current_server_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterServerReq::GetTypeName() const {
  return "IM.Server.RegisterServerReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterServerRsp::kResultCodeFieldNumber;
const int RegisterServerRsp::kNodeIdFieldNumber;
const int RegisterServerRsp::kIsEnableFieldNumber;
#endif  // !_MSC_VER

RegisterServerRsp::RegisterServerRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.RegisterServerRsp)
}

void RegisterServerRsp::InitAsDefaultInstance() {
}

RegisterServerRsp::RegisterServerRsp(const RegisterServerRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.RegisterServerRsp)
}

void RegisterServerRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 1;
  node_id_ = 0u;
  is_enable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterServerRsp::~RegisterServerRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.RegisterServerRsp)
  SharedDtor();
}

void RegisterServerRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterServerRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterServerRsp& RegisterServerRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

RegisterServerRsp* RegisterServerRsp::default_instance_ = NULL;

RegisterServerRsp* RegisterServerRsp::New() const {
  return new RegisterServerRsp;
}

void RegisterServerRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RegisterServerRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(node_id_, is_enable_);
    result_code_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RegisterServerRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.RegisterServerRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ResultType result_code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ResultType_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::ResultType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // required uint32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_is_enable;
        break;
      }

      // required bool is_enable = 3;
      case 3: {
        if (tag == 24) {
         parse_is_enable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_enable_)));
          set_has_is_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.RegisterServerRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.RegisterServerRsp)
  return false;
#undef DO_
}

void RegisterServerRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.RegisterServerRsp)
  // required .IM.BaseDefine.ResultType result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result_code(), output);
  }

  // required uint32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->node_id(), output);
  }

  // required bool is_enable = 3;
  if (has_is_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_enable(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.RegisterServerRsp)
}

int RegisterServerRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ResultType result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

    // required uint32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required bool is_enable = 3;
    if (has_is_enable()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterServerRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterServerRsp*>(&from));
}

void RegisterServerRsp::MergeFrom(const RegisterServerRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_is_enable()) {
      set_is_enable(from.is_enable());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RegisterServerRsp::CopyFrom(const RegisterServerRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterServerRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RegisterServerRsp::Swap(RegisterServerRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(node_id_, other->node_id_);
    std::swap(is_enable_, other->is_enable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterServerRsp::GetTypeName() const {
  return "IM.Server.RegisterServerRsp";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetAllServerStatusReq::GetAllServerStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.GetAllServerStatusReq)
}

void GetAllServerStatusReq::InitAsDefaultInstance() {
}

GetAllServerStatusReq::GetAllServerStatusReq(const GetAllServerStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.GetAllServerStatusReq)
}

void GetAllServerStatusReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAllServerStatusReq::~GetAllServerStatusReq() {
  // @@protoc_insertion_point(destructor:IM.Server.GetAllServerStatusReq)
  SharedDtor();
}

void GetAllServerStatusReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAllServerStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAllServerStatusReq& GetAllServerStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

GetAllServerStatusReq* GetAllServerStatusReq::default_instance_ = NULL;

GetAllServerStatusReq* GetAllServerStatusReq::New() const {
  return new GetAllServerStatusReq;
}

void GetAllServerStatusReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAllServerStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.GetAllServerStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.GetAllServerStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.GetAllServerStatusReq)
  return false;
#undef DO_
}

void GetAllServerStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.GetAllServerStatusReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.GetAllServerStatusReq)
}

int GetAllServerStatusReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAllServerStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAllServerStatusReq*>(&from));
}

void GetAllServerStatusReq::MergeFrom(const GetAllServerStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAllServerStatusReq::CopyFrom(const GetAllServerStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAllServerStatusReq::IsInitialized() const {

  return true;
}

void GetAllServerStatusReq::Swap(GetAllServerStatusReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAllServerStatusReq::GetTypeName() const {
  return "IM.Server.GetAllServerStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int GetAllServerStatusRsp::kResultCodeFieldNumber;
const int GetAllServerStatusRsp::kServerListFieldNumber;
#endif  // !_MSC_VER

GetAllServerStatusRsp::GetAllServerStatusRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.GetAllServerStatusRsp)
}

void GetAllServerStatusRsp::InitAsDefaultInstance() {
}

GetAllServerStatusRsp::GetAllServerStatusRsp(const GetAllServerStatusRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.GetAllServerStatusRsp)
}

void GetAllServerStatusRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAllServerStatusRsp::~GetAllServerStatusRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.GetAllServerStatusRsp)
  SharedDtor();
}

void GetAllServerStatusRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAllServerStatusRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAllServerStatusRsp& GetAllServerStatusRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

GetAllServerStatusRsp* GetAllServerStatusRsp::default_instance_ = NULL;

GetAllServerStatusRsp* GetAllServerStatusRsp::New() const {
  return new GetAllServerStatusRsp;
}

void GetAllServerStatusRsp::Clear() {
  result_code_ = 1;
  server_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAllServerStatusRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.GetAllServerStatusRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ResultType result_code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ResultType_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::ResultType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_server_list;
        break;
      }

      // repeated .IM.Server.ServerStatus server_list = 2;
      case 2: {
        if (tag == 18) {
         parse_server_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_server_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_server_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.GetAllServerStatusRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.GetAllServerStatusRsp)
  return false;
#undef DO_
}

void GetAllServerStatusRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.GetAllServerStatusRsp)
  // required .IM.BaseDefine.ResultType result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result_code(), output);
  }

  // repeated .IM.Server.ServerStatus server_list = 2;
  for (int i = 0; i < this->server_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->server_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.GetAllServerStatusRsp)
}

int GetAllServerStatusRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ResultType result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

  }
  // repeated .IM.Server.ServerStatus server_list = 2;
  total_size += 1 * this->server_list_size();
  for (int i = 0; i < this->server_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->server_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAllServerStatusRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAllServerStatusRsp*>(&from));
}

void GetAllServerStatusRsp::MergeFrom(const GetAllServerStatusRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  server_list_.MergeFrom(from.server_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAllServerStatusRsp::CopyFrom(const GetAllServerStatusRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAllServerStatusRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->server_list())) return false;
  return true;
}

void GetAllServerStatusRsp::Swap(GetAllServerStatusRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    server_list_.Swap(&other->server_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAllServerStatusRsp::GetTypeName() const {
  return "IM.Server.GetAllServerStatusRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerStatusUpdateReq::kNodeIdFieldNumber;
const int ServerStatusUpdateReq::kResourcePayloadFieldNumber;
#endif  // !_MSC_VER

ServerStatusUpdateReq::ServerStatusUpdateReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerStatusUpdateReq)
}

void ServerStatusUpdateReq::InitAsDefaultInstance() {
}

ServerStatusUpdateReq::ServerStatusUpdateReq(const ServerStatusUpdateReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerStatusUpdateReq)
}

void ServerStatusUpdateReq::SharedCtor() {
  _cached_size_ = 0;
  node_id_ = 0u;
  resource_payload_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerStatusUpdateReq::~ServerStatusUpdateReq() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerStatusUpdateReq)
  SharedDtor();
}

void ServerStatusUpdateReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerStatusUpdateReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerStatusUpdateReq& ServerStatusUpdateReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerStatusUpdateReq* ServerStatusUpdateReq::default_instance_ = NULL;

ServerStatusUpdateReq* ServerStatusUpdateReq::New() const {
  return new ServerStatusUpdateReq;
}

void ServerStatusUpdateReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ServerStatusUpdateReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(node_id_, resource_payload_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerStatusUpdateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerStatusUpdateReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 node_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_resource_payload;
        break;
      }

      // required uint32 resource_payload = 2;
      case 2: {
        if (tag == 16) {
         parse_resource_payload:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &resource_payload_)));
          set_has_resource_payload();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerStatusUpdateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerStatusUpdateReq)
  return false;
#undef DO_
}

void ServerStatusUpdateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerStatusUpdateReq)
  // required uint32 node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->node_id(), output);
  }

  // required uint32 resource_payload = 2;
  if (has_resource_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->resource_payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerStatusUpdateReq)
}

int ServerStatusUpdateReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // required uint32 resource_payload = 2;
    if (has_resource_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->resource_payload());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerStatusUpdateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerStatusUpdateReq*>(&from));
}

void ServerStatusUpdateReq::MergeFrom(const ServerStatusUpdateReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_resource_payload()) {
      set_resource_payload(from.resource_payload());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerStatusUpdateReq::CopyFrom(const ServerStatusUpdateReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerStatusUpdateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ServerStatusUpdateReq::Swap(ServerStatusUpdateReq* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(resource_payload_, other->resource_payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerStatusUpdateReq::GetTypeName() const {
  return "IM.Server.ServerStatusUpdateReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerStatusUpdateRsp::kResultCodeFieldNumber;
#endif  // !_MSC_VER

ServerStatusUpdateRsp::ServerStatusUpdateRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerStatusUpdateRsp)
}

void ServerStatusUpdateRsp::InitAsDefaultInstance() {
}

ServerStatusUpdateRsp::ServerStatusUpdateRsp(const ServerStatusUpdateRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerStatusUpdateRsp)
}

void ServerStatusUpdateRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerStatusUpdateRsp::~ServerStatusUpdateRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerStatusUpdateRsp)
  SharedDtor();
}

void ServerStatusUpdateRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerStatusUpdateRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerStatusUpdateRsp& ServerStatusUpdateRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerStatusUpdateRsp* ServerStatusUpdateRsp::default_instance_ = NULL;

ServerStatusUpdateRsp* ServerStatusUpdateRsp::New() const {
  return new ServerStatusUpdateRsp;
}

void ServerStatusUpdateRsp::Clear() {
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerStatusUpdateRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerStatusUpdateRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ResultType result_code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ResultType_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::ResultType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerStatusUpdateRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerStatusUpdateRsp)
  return false;
#undef DO_
}

void ServerStatusUpdateRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerStatusUpdateRsp)
  // required .IM.BaseDefine.ResultType result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerStatusUpdateRsp)
}

int ServerStatusUpdateRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ResultType result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerStatusUpdateRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerStatusUpdateRsp*>(&from));
}

void ServerStatusUpdateRsp::MergeFrom(const ServerStatusUpdateRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerStatusUpdateRsp::CopyFrom(const ServerStatusUpdateRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerStatusUpdateRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ServerStatusUpdateRsp::Swap(ServerStatusUpdateRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerStatusUpdateRsp::GetTypeName() const {
  return "IM.Server.ServerStatusUpdateRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerStatusPush::kServerListFieldNumber;
const int ServerStatusPush::kAddServerListFieldNumber;
const int ServerStatusPush::kDelServerListFieldNumber;
#endif  // !_MSC_VER

ServerStatusPush::ServerStatusPush()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerStatusPush)
}

void ServerStatusPush::InitAsDefaultInstance() {
}

ServerStatusPush::ServerStatusPush(const ServerStatusPush& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerStatusPush)
}

void ServerStatusPush::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerStatusPush::~ServerStatusPush() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerStatusPush)
  SharedDtor();
}

void ServerStatusPush::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerStatusPush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerStatusPush& ServerStatusPush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerStatusPush* ServerStatusPush::default_instance_ = NULL;

ServerStatusPush* ServerStatusPush::New() const {
  return new ServerStatusPush;
}

void ServerStatusPush::Clear() {
  server_list_.Clear();
  add_server_list_.Clear();
  del_server_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerStatusPush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerStatusPush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.Server.ServerStatus server_list = 1;
      case 1: {
        if (tag == 10) {
         parse_server_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_server_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_server_list;
        if (input->ExpectTag(18)) goto parse_add_server_list;
        break;
      }

      // repeated .IM.Server.ServerStatus add_server_list = 2;
      case 2: {
        if (tag == 18) {
         parse_add_server_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_add_server_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_add_server_list;
        if (input->ExpectTag(26)) goto parse_del_server_list;
        break;
      }

      // repeated .IM.Server.ServerStatus del_server_list = 3;
      case 3: {
        if (tag == 26) {
         parse_del_server_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_del_server_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_del_server_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerStatusPush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerStatusPush)
  return false;
#undef DO_
}

void ServerStatusPush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerStatusPush)
  // repeated .IM.Server.ServerStatus server_list = 1;
  for (int i = 0; i < this->server_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->server_list(i), output);
  }

  // repeated .IM.Server.ServerStatus add_server_list = 2;
  for (int i = 0; i < this->add_server_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->add_server_list(i), output);
  }

  // repeated .IM.Server.ServerStatus del_server_list = 3;
  for (int i = 0; i < this->del_server_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->del_server_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerStatusPush)
}

int ServerStatusPush::ByteSize() const {
  int total_size = 0;

  // repeated .IM.Server.ServerStatus server_list = 1;
  total_size += 1 * this->server_list_size();
  for (int i = 0; i < this->server_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->server_list(i));
  }

  // repeated .IM.Server.ServerStatus add_server_list = 2;
  total_size += 1 * this->add_server_list_size();
  for (int i = 0; i < this->add_server_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->add_server_list(i));
  }

  // repeated .IM.Server.ServerStatus del_server_list = 3;
  total_size += 1 * this->del_server_list_size();
  for (int i = 0; i < this->del_server_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->del_server_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerStatusPush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerStatusPush*>(&from));
}

void ServerStatusPush::MergeFrom(const ServerStatusPush& from) {
  GOOGLE_CHECK_NE(&from, this);
  server_list_.MergeFrom(from.server_list_);
  add_server_list_.MergeFrom(from.add_server_list_);
  del_server_list_.MergeFrom(from.del_server_list_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerStatusPush::CopyFrom(const ServerStatusPush& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerStatusPush::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->server_list())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->add_server_list())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->del_server_list())) return false;
  return true;
}

void ServerStatusPush::Swap(ServerStatusPush* other) {
  if (other != this) {
    server_list_.Swap(&other->server_list_);
    add_server_list_.Swap(&other->add_server_list_);
    del_server_list_.Swap(&other->del_server_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerStatusPush::GetTypeName() const {
  return "IM.Server.ServerStatusPush";
}


// ===================================================================

#ifndef _MSC_VER
const int MessageHeader::kServiceTypeFieldNumber;
const int MessageHeader::kCmdIdFieldNumber;
const int MessageHeader::kMessageSizeFieldNumber;
#endif  // !_MSC_VER

MessageHeader::MessageHeader()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.MessageHeader)
}

void MessageHeader::InitAsDefaultInstance() {
}

MessageHeader::MessageHeader(const MessageHeader& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.MessageHeader)
}

void MessageHeader::SharedCtor() {
  _cached_size_ = 0;
  service_type_ = 0u;
  cmd_id_ = 0u;
  message_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MessageHeader::~MessageHeader() {
  // @@protoc_insertion_point(destructor:IM.Server.MessageHeader)
  SharedDtor();
}

void MessageHeader::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MessageHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MessageHeader& MessageHeader::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

MessageHeader* MessageHeader::default_instance_ = NULL;

MessageHeader* MessageHeader::New() const {
  return new MessageHeader;
}

void MessageHeader::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MessageHeader*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(service_type_, message_size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MessageHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.MessageHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 service_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &service_type_)));
          set_has_service_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cmd_id;
        break;
      }

      // required uint32 cmd_id = 2;
      case 2: {
        if (tag == 16) {
         parse_cmd_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_id_)));
          set_has_cmd_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_message_size;
        break;
      }

      // required uint32 message_size = 3;
      case 3: {
        if (tag == 24) {
         parse_message_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_size_)));
          set_has_message_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.MessageHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.MessageHeader)
  return false;
#undef DO_
}

void MessageHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.MessageHeader)
  // required uint32 service_type = 1;
  if (has_service_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->service_type(), output);
  }

  // required uint32 cmd_id = 2;
  if (has_cmd_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cmd_id(), output);
  }

  // required uint32 message_size = 3;
  if (has_message_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->message_size(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.MessageHeader)
}

int MessageHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 service_type = 1;
    if (has_service_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->service_type());
    }

    // required uint32 cmd_id = 2;
    if (has_cmd_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cmd_id());
    }

    // required uint32 message_size = 3;
    if (has_message_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_size());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageHeader::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MessageHeader*>(&from));
}

void MessageHeader::MergeFrom(const MessageHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_type()) {
      set_service_type(from.service_type());
    }
    if (from.has_cmd_id()) {
      set_cmd_id(from.cmd_id());
    }
    if (from.has_message_size()) {
      set_message_size(from.message_size());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MessageHeader::CopyFrom(const MessageHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MessageHeader::Swap(MessageHeader* other) {
  if (other != this) {
    std::swap(service_type_, other->service_type_);
    std::swap(cmd_id_, other->cmd_id_);
    std::swap(message_size_, other->message_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MessageHeader::GetTypeName() const {
  return "IM.Server.MessageHeader";
}


// ===================================================================

#ifndef _MSC_VER
const int BroadcastMessageReq::kHeaderFieldNumber;
const int BroadcastMessageReq::kMessageSerializeFieldNumber;
const int BroadcastMessageReq::kTargetServicesFieldNumber;
#endif  // !_MSC_VER

BroadcastMessageReq::BroadcastMessageReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.BroadcastMessageReq)
}

void BroadcastMessageReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  header_ = const_cast< ::IM::Server::MessageHeader*>(
      ::IM::Server::MessageHeader::internal_default_instance());
#else
  header_ = const_cast< ::IM::Server::MessageHeader*>(&::IM::Server::MessageHeader::default_instance());
#endif
}

BroadcastMessageReq::BroadcastMessageReq(const BroadcastMessageReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.BroadcastMessageReq)
}

void BroadcastMessageReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BroadcastMessageReq::~BroadcastMessageReq() {
  // @@protoc_insertion_point(destructor:IM.Server.BroadcastMessageReq)
  SharedDtor();
}

void BroadcastMessageReq::SharedDtor() {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_serialize_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete header_;
  }
}

void BroadcastMessageReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BroadcastMessageReq& BroadcastMessageReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

BroadcastMessageReq* BroadcastMessageReq::default_instance_ = NULL;

BroadcastMessageReq* BroadcastMessageReq::New() const {
  return new BroadcastMessageReq;
}

void BroadcastMessageReq::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_header()) {
      if (header_ != NULL) header_->::IM::Server::MessageHeader::Clear();
    }
    if (has_message_serialize()) {
      if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_serialize_->clear();
      }
    }
  }
  target_services_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BroadcastMessageReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.BroadcastMessageReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.Server.MessageHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_serialize;
        break;
      }

      // optional bytes message_serialize = 2;
      case 2: {
        if (tag == 18) {
         parse_message_serialize:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_serialize()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_target_services;
        break;
      }

      // repeated uint32 target_services = 3;
      case 3: {
        if (tag == 24) {
         parse_target_services:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_target_services())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_target_services())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_target_services;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.BroadcastMessageReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.BroadcastMessageReq)
  return false;
#undef DO_
}

void BroadcastMessageReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.BroadcastMessageReq)
  // required .IM.Server.MessageHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->header(), output);
  }

  // optional bytes message_serialize = 2;
  if (has_message_serialize()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message_serialize(), output);
  }

  // repeated uint32 target_services = 3;
  for (int i = 0; i < this->target_services_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->target_services(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.BroadcastMessageReq)
}

int BroadcastMessageReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.Server.MessageHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional bytes message_serialize = 2;
    if (has_message_serialize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_serialize());
    }

  }
  // repeated uint32 target_services = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->target_services_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->target_services(i));
    }
    total_size += 1 * this->target_services_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastMessageReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BroadcastMessageReq*>(&from));
}

void BroadcastMessageReq::MergeFrom(const BroadcastMessageReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_services_.MergeFrom(from.target_services_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::IM::Server::MessageHeader::MergeFrom(from.header());
    }
    if (from.has_message_serialize()) {
      set_message_serialize(from.message_serialize());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BroadcastMessageReq::CopyFrom(const BroadcastMessageReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastMessageReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void BroadcastMessageReq::Swap(BroadcastMessageReq* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(message_serialize_, other->message_serialize_);
    target_services_.Swap(&other->target_services_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BroadcastMessageReq::GetTypeName() const {
  return "IM.Server.BroadcastMessageReq";
}


// ===================================================================

#ifndef _MSC_VER
const int BroadcastMessageRsp::kResultCodeFieldNumber;
#endif  // !_MSC_VER

BroadcastMessageRsp::BroadcastMessageRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.BroadcastMessageRsp)
}

void BroadcastMessageRsp::InitAsDefaultInstance() {
}

BroadcastMessageRsp::BroadcastMessageRsp(const BroadcastMessageRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.BroadcastMessageRsp)
}

void BroadcastMessageRsp::SharedCtor() {
  _cached_size_ = 0;
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BroadcastMessageRsp::~BroadcastMessageRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.BroadcastMessageRsp)
  SharedDtor();
}

void BroadcastMessageRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BroadcastMessageRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BroadcastMessageRsp& BroadcastMessageRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

BroadcastMessageRsp* BroadcastMessageRsp::default_instance_ = NULL;

BroadcastMessageRsp* BroadcastMessageRsp::New() const {
  return new BroadcastMessageRsp;
}

void BroadcastMessageRsp::Clear() {
  result_code_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BroadcastMessageRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.BroadcastMessageRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.ResultType result_code = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ResultType_IsValid(value)) {
            set_result_code(static_cast< ::IM::BaseDefine::ResultType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.BroadcastMessageRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.BroadcastMessageRsp)
  return false;
#undef DO_
}

void BroadcastMessageRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.BroadcastMessageRsp)
  // required .IM.BaseDefine.ResultType result_code = 1;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.BroadcastMessageRsp)
}

int BroadcastMessageRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.ResultType result_code = 1;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastMessageRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BroadcastMessageRsp*>(&from));
}

void BroadcastMessageRsp::MergeFrom(const BroadcastMessageRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BroadcastMessageRsp::CopyFrom(const BroadcastMessageRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastMessageRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BroadcastMessageRsp::Swap(BroadcastMessageRsp* other) {
  if (other != this) {
    std::swap(result_code_, other->result_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BroadcastMessageRsp::GetTypeName() const {
  return "IM.Server.BroadcastMessageRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int BroadcastPush::kHeaderFieldNumber;
const int BroadcastPush::kMessageSerializeFieldNumber;
#endif  // !_MSC_VER

BroadcastPush::BroadcastPush()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.BroadcastPush)
}

void BroadcastPush::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  header_ = const_cast< ::IM::Server::MessageHeader*>(
      ::IM::Server::MessageHeader::internal_default_instance());
#else
  header_ = const_cast< ::IM::Server::MessageHeader*>(&::IM::Server::MessageHeader::default_instance());
#endif
}

BroadcastPush::BroadcastPush(const BroadcastPush& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.BroadcastPush)
}

void BroadcastPush::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  message_serialize_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BroadcastPush::~BroadcastPush() {
  // @@protoc_insertion_point(destructor:IM.Server.BroadcastPush)
  SharedDtor();
}

void BroadcastPush::SharedDtor() {
  if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_serialize_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete header_;
  }
}

void BroadcastPush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BroadcastPush& BroadcastPush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

BroadcastPush* BroadcastPush::default_instance_ = NULL;

BroadcastPush* BroadcastPush::New() const {
  return new BroadcastPush;
}

void BroadcastPush::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_header()) {
      if (header_ != NULL) header_->::IM::Server::MessageHeader::Clear();
    }
    if (has_message_serialize()) {
      if (message_serialize_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        message_serialize_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BroadcastPush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.BroadcastPush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.Server.MessageHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_message_serialize;
        break;
      }

      // optional bytes message_serialize = 2;
      case 2: {
        if (tag == 18) {
         parse_message_serialize:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_serialize()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.BroadcastPush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.BroadcastPush)
  return false;
#undef DO_
}

void BroadcastPush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.BroadcastPush)
  // required .IM.Server.MessageHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->header(), output);
  }

  // optional bytes message_serialize = 2;
  if (has_message_serialize()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message_serialize(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.BroadcastPush)
}

int BroadcastPush::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.Server.MessageHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }

    // optional bytes message_serialize = 2;
    if (has_message_serialize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_serialize());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastPush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BroadcastPush*>(&from));
}

void BroadcastPush::MergeFrom(const BroadcastPush& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::IM::Server::MessageHeader::MergeFrom(from.header());
    }
    if (from.has_message_serialize()) {
      set_message_serialize(from.message_serialize());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BroadcastPush::CopyFrom(const BroadcastPush& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastPush::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void BroadcastPush::Swap(BroadcastPush* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(message_serialize_, other->message_serialize_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BroadcastPush::GetTypeName() const {
  return "IM.Server.BroadcastPush";
}


// ===================================================================

#ifndef _MSC_VER
const int ConnNode::kIpFieldNumber;
const int ConnNode::kPortFieldNumber;
const int ConnNode::kMaxLoadFieldNumber;
const int ConnNode::kCurLoadFieldNumber;
const int ConnNode::kIsSslFieldNumber;
#endif  // !_MSC_VER

ConnNode::ConnNode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ConnNode)
}

void ConnNode::InitAsDefaultInstance() {
}

ConnNode::ConnNode(const ConnNode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ConnNode)
}

void ConnNode::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  max_load_ = 0u;
  cur_load_ = 0u;
  is_ssl_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnNode::~ConnNode() {
  // @@protoc_insertion_point(destructor:IM.Server.ConnNode)
  SharedDtor();
}

void ConnNode::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConnNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConnNode& ConnNode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ConnNode* ConnNode::default_instance_ = NULL;

ConnNode* ConnNode::New() const {
  return new ConnNode;
}

void ConnNode::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ConnNode*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(port_, is_ssl_);
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConnNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ConnNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_max_load;
        break;
      }

      // required uint32 max_load = 3;
      case 3: {
        if (tag == 24) {
         parse_max_load:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_load_)));
          set_has_max_load();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cur_load;
        break;
      }

      // required uint32 cur_load = 4;
      case 4: {
        if (tag == 32) {
         parse_cur_load:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_load_)));
          set_has_cur_load();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_is_ssl;
        break;
      }

      // required uint32 is_ssl = 5;
      case 5: {
        if (tag == 40) {
         parse_is_ssl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_ssl_)));
          set_has_is_ssl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ConnNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ConnNode)
  return false;
#undef DO_
}

void ConnNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ConnNode)
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  // required uint32 max_load = 3;
  if (has_max_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->max_load(), output);
  }

  // required uint32 cur_load = 4;
  if (has_cur_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cur_load(), output);
  }

  // required uint32 is_ssl = 5;
  if (has_is_ssl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->is_ssl(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ConnNode)
}

int ConnNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required uint32 max_load = 3;
    if (has_max_load()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_load());
    }

    // required uint32 cur_load = 4;
    if (has_cur_load()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_load());
    }

    // required uint32 is_ssl = 5;
    if (has_is_ssl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_ssl());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConnNode*>(&from));
}

void ConnNode::MergeFrom(const ConnNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_max_load()) {
      set_max_load(from.max_load());
    }
    if (from.has_cur_load()) {
      set_cur_load(from.cur_load());
    }
    if (from.has_is_ssl()) {
      set_is_ssl(from.is_ssl());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConnNode::CopyFrom(const ConnNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void ConnNode::Swap(ConnNode* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(max_load_, other->max_load_);
    std::swap(cur_load_, other->cur_load_);
    std::swap(is_ssl_, other->is_ssl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConnNode::GetTypeName() const {
  return "IM.Server.ConnNode";
}


// ===================================================================

#ifndef _MSC_VER
const int SrvAddrNode::kIpFieldNumber;
const int SrvAddrNode::kPortFieldNumber;
const int SrvAddrNode::kIsSslFieldNumber;
#endif  // !_MSC_VER

SrvAddrNode::SrvAddrNode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.SrvAddrNode)
}

void SrvAddrNode::InitAsDefaultInstance() {
}

SrvAddrNode::SrvAddrNode(const SrvAddrNode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.SrvAddrNode)
}

void SrvAddrNode::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  is_ssl_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SrvAddrNode::~SrvAddrNode() {
  // @@protoc_insertion_point(destructor:IM.Server.SrvAddrNode)
  SharedDtor();
}

void SrvAddrNode::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SrvAddrNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SrvAddrNode& SrvAddrNode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

SrvAddrNode* SrvAddrNode::default_instance_ = NULL;

SrvAddrNode* SrvAddrNode::New() const {
  return new SrvAddrNode;
}

void SrvAddrNode::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SrvAddrNode*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(port_, is_ssl_);
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SrvAddrNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.SrvAddrNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_is_ssl;
        break;
      }

      // required uint32 is_ssl = 3;
      case 3: {
        if (tag == 24) {
         parse_is_ssl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_ssl_)));
          set_has_is_ssl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.SrvAddrNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.SrvAddrNode)
  return false;
#undef DO_
}

void SrvAddrNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.SrvAddrNode)
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  // required uint32 is_ssl = 3;
  if (has_is_ssl()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->is_ssl(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.SrvAddrNode)
}

int SrvAddrNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // required uint32 is_ssl = 3;
    if (has_is_ssl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_ssl());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SrvAddrNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SrvAddrNode*>(&from));
}

void SrvAddrNode::MergeFrom(const SrvAddrNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_is_ssl()) {
      set_is_ssl(from.is_ssl());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SrvAddrNode::CopyFrom(const SrvAddrNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SrvAddrNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SrvAddrNode::Swap(SrvAddrNode* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(is_ssl_, other->is_ssl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SrvAddrNode::GetTypeName() const {
  return "IM.Server.SrvAddrNode";
}


// ===================================================================

#ifndef _MSC_VER
const int ConnSrvStatusReport::kConnNodeListFieldNumber;
#endif  // !_MSC_VER

ConnSrvStatusReport::ConnSrvStatusReport()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ConnSrvStatusReport)
}

void ConnSrvStatusReport::InitAsDefaultInstance() {
}

ConnSrvStatusReport::ConnSrvStatusReport(const ConnSrvStatusReport& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ConnSrvStatusReport)
}

void ConnSrvStatusReport::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnSrvStatusReport::~ConnSrvStatusReport() {
  // @@protoc_insertion_point(destructor:IM.Server.ConnSrvStatusReport)
  SharedDtor();
}

void ConnSrvStatusReport::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConnSrvStatusReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConnSrvStatusReport& ConnSrvStatusReport::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ConnSrvStatusReport* ConnSrvStatusReport::default_instance_ = NULL;

ConnSrvStatusReport* ConnSrvStatusReport::New() const {
  return new ConnSrvStatusReport;
}

void ConnSrvStatusReport::Clear() {
  connnodelist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConnSrvStatusReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ConnSrvStatusReport)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.Server.ConnNode ConnNodeList = 1;
      case 1: {
        if (tag == 10) {
         parse_ConnNodeList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_connnodelist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ConnNodeList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ConnSrvStatusReport)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ConnSrvStatusReport)
  return false;
#undef DO_
}

void ConnSrvStatusReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ConnSrvStatusReport)
  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  for (int i = 0; i < this->connnodelist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->connnodelist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ConnSrvStatusReport)
}

int ConnSrvStatusReport::ByteSize() const {
  int total_size = 0;

  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  total_size += 1 * this->connnodelist_size();
  for (int i = 0; i < this->connnodelist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->connnodelist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnSrvStatusReport::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConnSrvStatusReport*>(&from));
}

void ConnSrvStatusReport::MergeFrom(const ConnSrvStatusReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  connnodelist_.MergeFrom(from.connnodelist_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConnSrvStatusReport::CopyFrom(const ConnSrvStatusReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnSrvStatusReport::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->connnodelist())) return false;
  return true;
}

void ConnSrvStatusReport::Swap(ConnSrvStatusReport* other) {
  if (other != this) {
    connnodelist_.Swap(&other->connnodelist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConnSrvStatusReport::GetTypeName() const {
  return "IM.Server.ConnSrvStatusReport";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ConnSrvListStatusReq::ConnSrvListStatusReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ConnSrvListStatusReq)
}

void ConnSrvListStatusReq::InitAsDefaultInstance() {
}

ConnSrvListStatusReq::ConnSrvListStatusReq(const ConnSrvListStatusReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ConnSrvListStatusReq)
}

void ConnSrvListStatusReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnSrvListStatusReq::~ConnSrvListStatusReq() {
  // @@protoc_insertion_point(destructor:IM.Server.ConnSrvListStatusReq)
  SharedDtor();
}

void ConnSrvListStatusReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConnSrvListStatusReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConnSrvListStatusReq& ConnSrvListStatusReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ConnSrvListStatusReq* ConnSrvListStatusReq::default_instance_ = NULL;

ConnSrvListStatusReq* ConnSrvListStatusReq::New() const {
  return new ConnSrvListStatusReq;
}

void ConnSrvListStatusReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConnSrvListStatusReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ConnSrvListStatusReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ConnSrvListStatusReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ConnSrvListStatusReq)
  return false;
#undef DO_
}

void ConnSrvListStatusReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ConnSrvListStatusReq)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ConnSrvListStatusReq)
}

int ConnSrvListStatusReq::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnSrvListStatusReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConnSrvListStatusReq*>(&from));
}

void ConnSrvListStatusReq::MergeFrom(const ConnSrvListStatusReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConnSrvListStatusReq::CopyFrom(const ConnSrvListStatusReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnSrvListStatusReq::IsInitialized() const {

  return true;
}

void ConnSrvListStatusReq::Swap(ConnSrvListStatusReq* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConnSrvListStatusReq::GetTypeName() const {
  return "IM.Server.ConnSrvListStatusReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ConnSrvListStatusPush::kConnNodeListFieldNumber;
const int ConnSrvListStatusPush::kFileSrvListFieldNumber;
const int ConnSrvListStatusPush::kCommentSrvListFieldNumber;
#endif  // !_MSC_VER

ConnSrvListStatusPush::ConnSrvListStatusPush()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ConnSrvListStatusPush)
}

void ConnSrvListStatusPush::InitAsDefaultInstance() {
}

ConnSrvListStatusPush::ConnSrvListStatusPush(const ConnSrvListStatusPush& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ConnSrvListStatusPush)
}

void ConnSrvListStatusPush::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConnSrvListStatusPush::~ConnSrvListStatusPush() {
  // @@protoc_insertion_point(destructor:IM.Server.ConnSrvListStatusPush)
  SharedDtor();
}

void ConnSrvListStatusPush::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConnSrvListStatusPush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConnSrvListStatusPush& ConnSrvListStatusPush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ConnSrvListStatusPush* ConnSrvListStatusPush::default_instance_ = NULL;

ConnSrvListStatusPush* ConnSrvListStatusPush::New() const {
  return new ConnSrvListStatusPush;
}

void ConnSrvListStatusPush::Clear() {
  connnodelist_.Clear();
  filesrvlist_.Clear();
  commentsrvlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConnSrvListStatusPush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ConnSrvListStatusPush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.Server.ConnNode ConnNodeList = 1;
      case 1: {
        if (tag == 10) {
         parse_ConnNodeList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_connnodelist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ConnNodeList;
        if (input->ExpectTag(18)) goto parse_FileSrvList;
        break;
      }

      // repeated .IM.Server.SrvAddrNode FileSrvList = 2;
      case 2: {
        if (tag == 18) {
         parse_FileSrvList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_filesrvlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_FileSrvList;
        if (input->ExpectTag(34)) goto parse_CommentSrvList;
        break;
      }

      // repeated .IM.Server.SrvAddrNode CommentSrvList = 4;
      case 4: {
        if (tag == 34) {
         parse_CommentSrvList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_commentsrvlist()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_CommentSrvList;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ConnSrvListStatusPush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ConnSrvListStatusPush)
  return false;
#undef DO_
}

void ConnSrvListStatusPush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ConnSrvListStatusPush)
  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  for (int i = 0; i < this->connnodelist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->connnodelist(i), output);
  }

  // repeated .IM.Server.SrvAddrNode FileSrvList = 2;
  for (int i = 0; i < this->filesrvlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->filesrvlist(i), output);
  }

  // repeated .IM.Server.SrvAddrNode CommentSrvList = 4;
  for (int i = 0; i < this->commentsrvlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->commentsrvlist(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ConnSrvListStatusPush)
}

int ConnSrvListStatusPush::ByteSize() const {
  int total_size = 0;

  // repeated .IM.Server.ConnNode ConnNodeList = 1;
  total_size += 1 * this->connnodelist_size();
  for (int i = 0; i < this->connnodelist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->connnodelist(i));
  }

  // repeated .IM.Server.SrvAddrNode FileSrvList = 2;
  total_size += 1 * this->filesrvlist_size();
  for (int i = 0; i < this->filesrvlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->filesrvlist(i));
  }

  // repeated .IM.Server.SrvAddrNode CommentSrvList = 4;
  total_size += 1 * this->commentsrvlist_size();
  for (int i = 0; i < this->commentsrvlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->commentsrvlist(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnSrvListStatusPush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConnSrvListStatusPush*>(&from));
}

void ConnSrvListStatusPush::MergeFrom(const ConnSrvListStatusPush& from) {
  GOOGLE_CHECK_NE(&from, this);
  connnodelist_.MergeFrom(from.connnodelist_);
  filesrvlist_.MergeFrom(from.filesrvlist_);
  commentsrvlist_.MergeFrom(from.commentsrvlist_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConnSrvListStatusPush::CopyFrom(const ConnSrvListStatusPush& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnSrvListStatusPush::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->connnodelist())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->filesrvlist())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->commentsrvlist())) return false;
  return true;
}

void ConnSrvListStatusPush::Swap(ConnSrvListStatusPush* other) {
  if (other != this) {
    connnodelist_.Swap(&other->connnodelist_);
    filesrvlist_.Swap(&other->filesrvlist_);
    commentsrvlist_.Swap(&other->commentsrvlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConnSrvListStatusPush::GetTypeName() const {
  return "IM.Server.ConnSrvListStatusPush";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ServerStopPush::ServerStopPush()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerStopPush)
}

void ServerStopPush::InitAsDefaultInstance() {
}

ServerStopPush::ServerStopPush(const ServerStopPush& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerStopPush)
}

void ServerStopPush::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerStopPush::~ServerStopPush() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerStopPush)
  SharedDtor();
}

void ServerStopPush::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerStopPush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerStopPush& ServerStopPush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerStopPush* ServerStopPush::default_instance_ = NULL;

ServerStopPush* ServerStopPush::New() const {
  return new ServerStopPush;
}

void ServerStopPush::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerStopPush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerStopPush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerStopPush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerStopPush)
  return false;
#undef DO_
}

void ServerStopPush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerStopPush)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerStopPush)
}

int ServerStopPush::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerStopPush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerStopPush*>(&from));
}

void ServerStopPush::MergeFrom(const ServerStopPush& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerStopPush::CopyFrom(const ServerStopPush& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerStopPush::IsInitialized() const {

  return true;
}

void ServerStopPush::Swap(ServerStopPush* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerStopPush::GetTypeName() const {
  return "IM.Server.ServerStopPush";
}


// ===================================================================

#ifndef _MSC_VER
const int ServerLocalCacheRefreshNotify::kParamFieldNumber;
#endif  // !_MSC_VER

ServerLocalCacheRefreshNotify::ServerLocalCacheRefreshNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.ServerLocalCacheRefreshNotify)
}

void ServerLocalCacheRefreshNotify::InitAsDefaultInstance() {
}

ServerLocalCacheRefreshNotify::ServerLocalCacheRefreshNotify(const ServerLocalCacheRefreshNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Server.ServerLocalCacheRefreshNotify)
}

void ServerLocalCacheRefreshNotify::SharedCtor() {
  _cached_size_ = 0;
  param_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerLocalCacheRefreshNotify::~ServerLocalCacheRefreshNotify() {
  // @@protoc_insertion_point(destructor:IM.Server.ServerLocalCacheRefreshNotify)
  SharedDtor();
}

void ServerLocalCacheRefreshNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServerLocalCacheRefreshNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerLocalCacheRefreshNotify& ServerLocalCacheRefreshNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eRouter_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eRouter_2eproto();
#endif
  return *default_instance_;
}

ServerLocalCacheRefreshNotify* ServerLocalCacheRefreshNotify::default_instance_ = NULL;

ServerLocalCacheRefreshNotify* ServerLocalCacheRefreshNotify::New() const {
  return new ServerLocalCacheRefreshNotify;
}

void ServerLocalCacheRefreshNotify::Clear() {
  param_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ServerLocalCacheRefreshNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Server.ServerLocalCacheRefreshNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 param = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &param_)));
          set_has_param();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.ServerLocalCacheRefreshNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.ServerLocalCacheRefreshNotify)
  return false;
#undef DO_
}

void ServerLocalCacheRefreshNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.ServerLocalCacheRefreshNotify)
  // required uint32 param = 1;
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->param(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Server.ServerLocalCacheRefreshNotify)
}

int ServerLocalCacheRefreshNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 param = 1;
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->param());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerLocalCacheRefreshNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerLocalCacheRefreshNotify*>(&from));
}

void ServerLocalCacheRefreshNotify::MergeFrom(const ServerLocalCacheRefreshNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_param()) {
      set_param(from.param());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ServerLocalCacheRefreshNotify::CopyFrom(const ServerLocalCacheRefreshNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerLocalCacheRefreshNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ServerLocalCacheRefreshNotify::Swap(ServerLocalCacheRefreshNotify* other) {
  if (other != this) {
    std::swap(param_, other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServerLocalCacheRefreshNotify::GetTypeName() const {
  return "IM.Server.ServerLocalCacheRefreshNotify";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace IM

// @@protoc_insertion_point(global_scope)
