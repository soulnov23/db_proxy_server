// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.Message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace Message {

void protobuf_ShutdownFile_IM_2eMessage_2eproto() {
  delete IMMsg::default_instance_;
  delete GTCMsg::default_instance_;
  delete IMMsgRecvAck::default_instance_;
  delete IMMsgOptNotify::default_instance_;
  delete IMMsgReceiptListReq::default_instance_;
  delete IMMsgReceiptListRsp::default_instance_;
  delete IMOfflineMsgCntReq::default_instance_;
  delete IMOfflineMsgCntRsp::default_instance_;
  delete IMGetMsgDataListReq::default_instance_;
  delete IMGetMsgDataListRsp::default_instance_;
  delete IMGetLatestMsgIdReq::default_instance_;
  delete IMGetLatestMsgIdRsp::default_instance_;
  delete IMGetMsgByIdReq::default_instance_;
  delete IMGetMsgByIdRsp::default_instance_;
  delete IMP2PCmdMsg::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eMessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::IM::BaseDefine::protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  IMMsg::default_instance_ = new IMMsg();
  GTCMsg::default_instance_ = new GTCMsg();
  IMMsgRecvAck::default_instance_ = new IMMsgRecvAck();
  IMMsgOptNotify::default_instance_ = new IMMsgOptNotify();
  IMMsgReceiptListReq::default_instance_ = new IMMsgReceiptListReq();
  IMMsgReceiptListRsp::default_instance_ = new IMMsgReceiptListRsp();
  IMOfflineMsgCntReq::default_instance_ = new IMOfflineMsgCntReq();
  IMOfflineMsgCntRsp::default_instance_ = new IMOfflineMsgCntRsp();
  IMGetMsgDataListReq::default_instance_ = new IMGetMsgDataListReq();
  IMGetMsgDataListRsp::default_instance_ = new IMGetMsgDataListRsp();
  IMGetLatestMsgIdReq::default_instance_ = new IMGetLatestMsgIdReq();
  IMGetLatestMsgIdRsp::default_instance_ = new IMGetLatestMsgIdRsp();
  IMGetMsgByIdReq::default_instance_ = new IMGetMsgByIdReq();
  IMGetMsgByIdRsp::default_instance_ = new IMGetMsgByIdRsp();
  IMP2PCmdMsg::default_instance_ = new IMP2PCmdMsg();
  IMMsg::default_instance_->InitAsDefaultInstance();
  GTCMsg::default_instance_->InitAsDefaultInstance();
  IMMsgRecvAck::default_instance_->InitAsDefaultInstance();
  IMMsgOptNotify::default_instance_->InitAsDefaultInstance();
  IMMsgReceiptListReq::default_instance_->InitAsDefaultInstance();
  IMMsgReceiptListRsp::default_instance_->InitAsDefaultInstance();
  IMOfflineMsgCntReq::default_instance_->InitAsDefaultInstance();
  IMOfflineMsgCntRsp::default_instance_->InitAsDefaultInstance();
  IMGetMsgDataListReq::default_instance_->InitAsDefaultInstance();
  IMGetMsgDataListRsp::default_instance_->InitAsDefaultInstance();
  IMGetLatestMsgIdReq::default_instance_->InitAsDefaultInstance();
  IMGetLatestMsgIdRsp::default_instance_->InitAsDefaultInstance();
  IMGetMsgByIdReq::default_instance_->InitAsDefaultInstance();
  IMGetMsgByIdRsp::default_instance_->InitAsDefaultInstance();
  IMP2PCmdMsg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eMessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eMessage_2eproto_once_);
void protobuf_AddDesc_IM_2eMessage_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eMessage_2eproto_once_,
                 &protobuf_AddDesc_IM_2eMessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eMessage_2eproto {
  StaticDescriptorInitializer_IM_2eMessage_2eproto() {
    protobuf_AddDesc_IM_2eMessage_2eproto();
  }
} static_descriptor_initializer_IM_2eMessage_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int IMMsg::kMsgDataFieldNumber;
const int IMMsg::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMMsg::IMMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMMsg)
}

void IMMsg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  msg_data_ = const_cast< ::IM::BaseDefine::MsgData*>(
      ::IM::BaseDefine::MsgData::internal_default_instance());
#else
  msg_data_ = const_cast< ::IM::BaseDefine::MsgData*>(&::IM::BaseDefine::MsgData::default_instance());
#endif
}

IMMsg::IMMsg(const IMMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMMsg)
}

void IMMsg::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  msg_data_ = NULL;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsg::~IMMsg() {
  // @@protoc_insertion_point(destructor:IM.Message.IMMsg)
  SharedDtor();
}

void IMMsg::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete msg_data_;
  }
}

void IMMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsg& IMMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMMsg* IMMsg::default_instance_ = NULL;

IMMsg* IMMsg::New() const {
  return new IMMsg;
}

void IMMsg::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_msg_data()) {
      if (msg_data_ != NULL) msg_data_->::IM::BaseDefine::MsgData::Clear();
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.BaseDefine.MsgData msg_data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 11;
      case 11: {
        if (tag == 90) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMMsg)
  return false;
#undef DO_
}

void IMMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMMsg)
  // required .IM.BaseDefine.MsgData msg_data = 1;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->msg_data(), output);
  }

  // optional bytes attach_data = 11;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMMsg)
}

int IMMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.BaseDefine.MsgData msg_data = 1;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_data());
    }

    // optional bytes attach_data = 11;
    if (has_attach_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsg*>(&from));
}

void IMMsg::MergeFrom(const IMMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_data()) {
      mutable_msg_data()->::IM::BaseDefine::MsgData::MergeFrom(from.msg_data());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsg::CopyFrom(const IMMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_msg_data()) {
    if (!this->msg_data().IsInitialized()) return false;
  }
  return true;
}

void IMMsg::Swap(IMMsg* other) {
  if (other != this) {
    std::swap(msg_data_, other->msg_data_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsg::GetTypeName() const {
  return "IM.Message.IMMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int GTCMsg::kMsgFieldNumber;
const int GTCMsg::kSocketIdFieldNumber;
#endif  // !_MSC_VER

GTCMsg::GTCMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.GTCMsg)
}

void GTCMsg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  msg_ = const_cast< ::IM::Message::IMMsg*>(
      ::IM::Message::IMMsg::internal_default_instance());
#else
  msg_ = const_cast< ::IM::Message::IMMsg*>(&::IM::Message::IMMsg::default_instance());
#endif
}

GTCMsg::GTCMsg(const GTCMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.GTCMsg)
}

void GTCMsg::SharedCtor() {
  _cached_size_ = 0;
  msg_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GTCMsg::~GTCMsg() {
  // @@protoc_insertion_point(destructor:IM.Message.GTCMsg)
  SharedDtor();
}

void GTCMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete msg_;
  }
}

void GTCMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GTCMsg& GTCMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

GTCMsg* GTCMsg::default_instance_ = NULL;

GTCMsg* GTCMsg::New() const {
  return new GTCMsg;
}

void GTCMsg::Clear() {
  if (has_msg()) {
    if (msg_ != NULL) msg_->::IM::Message::IMMsg::Clear();
  }
  socket_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GTCMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.GTCMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .IM.Message.IMMsg msg = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_socket_id;
        break;
      }

      // repeated uint32 socket_id = 2;
      case 2: {
        if (tag == 16) {
         parse_socket_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_socket_id())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_socket_id())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_socket_id;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.GTCMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.GTCMsg)
  return false;
#undef DO_
}

void GTCMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.GTCMsg)
  // required .IM.Message.IMMsg msg = 1;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->msg(), output);
  }

  // repeated uint32 socket_id = 2;
  for (int i = 0; i < this->socket_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->socket_id(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.GTCMsg)
}

int GTCMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .IM.Message.IMMsg msg = 1;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg());
    }

  }
  // repeated uint32 socket_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->socket_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->socket_id(i));
    }
    total_size += 1 * this->socket_id_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GTCMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GTCMsg*>(&from));
}

void GTCMsg::MergeFrom(const GTCMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  socket_id_.MergeFrom(from.socket_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg()) {
      mutable_msg()->::IM::Message::IMMsg::MergeFrom(from.msg());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GTCMsg::CopyFrom(const GTCMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GTCMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_msg()) {
    if (!this->msg().IsInitialized()) return false;
  }
  return true;
}

void GTCMsg::Swap(GTCMsg* other) {
  if (other != this) {
    std::swap(msg_, other->msg_);
    socket_id_.Swap(&other->socket_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GTCMsg::GetTypeName() const {
  return "IM.Message.GTCMsg";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgRecvAck::kFromCompanyIdFieldNumber;
const int IMMsgRecvAck::kFromUserIdFieldNumber;
const int IMMsgRecvAck::kToCompanyIdFieldNumber;
const int IMMsgRecvAck::kToUserIdFieldNumber;
const int IMMsgRecvAck::kSessionTypeFieldNumber;
const int IMMsgRecvAck::kMsgIdFieldNumber;
const int IMMsgRecvAck::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMMsgRecvAck::IMMsgRecvAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMMsgRecvAck)
}

void IMMsgRecvAck::InitAsDefaultInstance() {
}

IMMsgRecvAck::IMMsgRecvAck(const IMMsgRecvAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMMsgRecvAck)
}

void IMMsgRecvAck::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  session_type_ = 1;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgRecvAck::~IMMsgRecvAck() {
  // @@protoc_insertion_point(destructor:IM.Message.IMMsgRecvAck)
  SharedDtor();
}

void IMMsgRecvAck::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgRecvAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgRecvAck& IMMsgRecvAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMMsgRecvAck* IMMsgRecvAck::default_instance_ = NULL;

IMMsgRecvAck* IMMsgRecvAck::New() const {
  return new IMMsgRecvAck;
}

void IMMsgRecvAck::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMMsgRecvAck*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(from_company_id_, to_user_id_);
    session_type_ = 1;
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_id_->clear();
      }
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsgRecvAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMMsgRecvAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 5;
      case 5: {
        if (tag == 40) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_id;
        break;
      }

      // required string msg_id = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 7;
      case 7: {
        if (tag == 58) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMMsgRecvAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMMsgRecvAck)
  return false;
#undef DO_
}

void IMMsgRecvAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMMsgRecvAck)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 3;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 4;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 5;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->session_type(), output);
  }

  // required string msg_id = 6;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->msg_id(), output);
  }

  // optional bytes attach_data = 7;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMMsgRecvAck)
}

int IMMsgRecvAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 3;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 4;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 5;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required string msg_id = 6;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_id());
    }

    // optional bytes attach_data = 7;
    if (has_attach_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgRecvAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgRecvAck*>(&from));
}

void IMMsgRecvAck::MergeFrom(const IMMsgRecvAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsgRecvAck::CopyFrom(const IMMsgRecvAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgRecvAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMMsgRecvAck::Swap(IMMsgRecvAck* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgRecvAck::GetTypeName() const {
  return "IM.Message.IMMsgRecvAck";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgOptNotify::kFromCompanyIdFieldNumber;
const int IMMsgOptNotify::kFromUserIdFieldNumber;
const int IMMsgOptNotify::kToCompanyIdFieldNumber;
const int IMMsgOptNotify::kToUserIdFieldNumber;
const int IMMsgOptNotify::kSessionTypeFieldNumber;
const int IMMsgOptNotify::kMsgIdFieldNumber;
const int IMMsgOptNotify::kMsgPropertyFieldNumber;
const int IMMsgOptNotify::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMMsgOptNotify::IMMsgOptNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMMsgOptNotify)
}

void IMMsgOptNotify::InitAsDefaultInstance() {
}

IMMsgOptNotify::IMMsgOptNotify(const IMMsgOptNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMMsgOptNotify)
}

void IMMsgOptNotify::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  session_type_ = 1;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_property_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgOptNotify::~IMMsgOptNotify() {
  // @@protoc_insertion_point(destructor:IM.Message.IMMsgOptNotify)
  SharedDtor();
}

void IMMsgOptNotify::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgOptNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgOptNotify& IMMsgOptNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMMsgOptNotify* IMMsgOptNotify::default_instance_ = NULL;

IMMsgOptNotify* IMMsgOptNotify::New() const {
  return new IMMsgOptNotify;
}

void IMMsgOptNotify::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMMsgOptNotify*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(from_company_id_, to_user_id_);
    session_type_ = 1;
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_id_->clear();
      }
    }
    msg_property_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsgOptNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMMsgOptNotify)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 5;
      case 5: {
        if (tag == 40) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_id;
        break;
      }

      // required string msg_id = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_msg_property;
        break;
      }

      // required .IM.BaseDefine.MsgProperty msg_property = 7;
      case 7: {
        if (tag == 56) {
         parse_msg_property:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgProperty_IsValid(value)) {
            set_msg_property(static_cast< ::IM::BaseDefine::MsgProperty >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 8;
      case 8: {
        if (tag == 66) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMMsgOptNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMMsgOptNotify)
  return false;
#undef DO_
}

void IMMsgOptNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMMsgOptNotify)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 3;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 4;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 5;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->session_type(), output);
  }

  // required string msg_id = 6;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->msg_id(), output);
  }

  // required .IM.BaseDefine.MsgProperty msg_property = 7;
  if (has_msg_property()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->msg_property(), output);
  }

  // optional bytes attach_data = 8;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMMsgOptNotify)
}

int IMMsgOptNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 3;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 4;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 5;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required string msg_id = 6;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_id());
    }

    // required .IM.BaseDefine.MsgProperty msg_property = 7;
    if (has_msg_property()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_property());
    }

    // optional bytes attach_data = 8;
    if (has_attach_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgOptNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgOptNotify*>(&from));
}

void IMMsgOptNotify::MergeFrom(const IMMsgOptNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_msg_property()) {
      set_msg_property(from.msg_property());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsgOptNotify::CopyFrom(const IMMsgOptNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgOptNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void IMMsgOptNotify::Swap(IMMsgOptNotify* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(msg_property_, other->msg_property_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgOptNotify::GetTypeName() const {
  return "IM.Message.IMMsgOptNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgReceiptListReq::kCompanyIdFieldNumber;
const int IMMsgReceiptListReq::kUserIdFieldNumber;
const int IMMsgReceiptListReq::kGroupCompanyIdFieldNumber;
const int IMMsgReceiptListReq::kGroupIdFieldNumber;
const int IMMsgReceiptListReq::kMsgIdFieldNumber;
const int IMMsgReceiptListReq::kUpdateTimeFieldNumber;
const int IMMsgReceiptListReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMMsgReceiptListReq::IMMsgReceiptListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMMsgReceiptListReq)
}

void IMMsgReceiptListReq::InitAsDefaultInstance() {
}

IMMsgReceiptListReq::IMMsgReceiptListReq(const IMMsgReceiptListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMMsgReceiptListReq)
}

void IMMsgReceiptListReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  company_id_ = 0u;
  user_id_ = 0u;
  group_company_id_ = 0u;
  group_id_ = 0u;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  update_time_ = GOOGLE_ULONGLONG(0);
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgReceiptListReq::~IMMsgReceiptListReq() {
  // @@protoc_insertion_point(destructor:IM.Message.IMMsgReceiptListReq)
  SharedDtor();
}

void IMMsgReceiptListReq::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgReceiptListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgReceiptListReq& IMMsgReceiptListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMMsgReceiptListReq* IMMsgReceiptListReq::default_instance_ = NULL;

IMMsgReceiptListReq* IMMsgReceiptListReq::New() const {
  return new IMMsgReceiptListReq;
}

void IMMsgReceiptListReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMMsgReceiptListReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(company_id_, group_id_);
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_id_->clear();
      }
    }
    update_time_ = GOOGLE_ULONGLONG(0);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsgReceiptListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMMsgReceiptListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_group_company_id;
        break;
      }

      // required uint32 group_company_id = 3;
      case 3: {
        if (tag == 24) {
         parse_group_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_company_id_)));
          set_has_group_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 4;
      case 4: {
        if (tag == 32) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_msg_id;
        break;
      }

      // required string msg_id = 5;
      case 5: {
        if (tag == 42) {
         parse_msg_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 7;
      case 7: {
        if (tag == 56) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMMsgReceiptListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMMsgReceiptListReq)
  return false;
#undef DO_
}

void IMMsgReceiptListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMMsgReceiptListReq)
  // required uint32 company_id = 1;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->company_id(), output);
  }

  // required uint32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required uint32 group_company_id = 3;
  if (has_group_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->group_company_id(), output);
  }

  // required uint32 group_id = 4;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->group_id(), output);
  }

  // required string msg_id = 5;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->msg_id(), output);
  }

  // required uint64 update_time = 7;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->update_time(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMMsgReceiptListReq)
}

int IMMsgReceiptListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 company_id = 1;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // required uint32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 group_company_id = 3;
    if (has_group_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_company_id());
    }

    // required uint32 group_id = 4;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required string msg_id = 5;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_id());
    }

    // required uint64 update_time = 7;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgReceiptListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgReceiptListReq*>(&from));
}

void IMMsgReceiptListReq::MergeFrom(const IMMsgReceiptListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_group_company_id()) {
      set_group_company_id(from.group_company_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsgReceiptListReq::CopyFrom(const IMMsgReceiptListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgReceiptListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMMsgReceiptListReq::Swap(IMMsgReceiptListReq* other) {
  if (other != this) {
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(group_company_id_, other->group_company_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(msg_id_, other->msg_id_);
    std::swap(update_time_, other->update_time_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgReceiptListReq::GetTypeName() const {
  return "IM.Message.IMMsgReceiptListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMMsgReceiptListRsp::kMsgIdFieldNumber;
const int IMMsgReceiptListRsp::kGroupCompanyIdFieldNumber;
const int IMMsgReceiptListRsp::kGroupIdFieldNumber;
const int IMMsgReceiptListRsp::kReceiptUserListFieldNumber;
const int IMMsgReceiptListRsp::kIsMoreDataFieldNumber;
const int IMMsgReceiptListRsp::kUpdateTimeFieldNumber;
const int IMMsgReceiptListRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMMsgReceiptListRsp::IMMsgReceiptListRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMMsgReceiptListRsp)
}

void IMMsgReceiptListRsp::InitAsDefaultInstance() {
}

IMMsgReceiptListRsp::IMMsgReceiptListRsp(const IMMsgReceiptListRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMMsgReceiptListRsp)
}

void IMMsgReceiptListRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_company_id_ = 0u;
  group_id_ = 0u;
  is_more_data_ = 0u;
  update_time_ = GOOGLE_ULONGLONG(0);
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMMsgReceiptListRsp::~IMMsgReceiptListRsp() {
  // @@protoc_insertion_point(destructor:IM.Message.IMMsgReceiptListRsp)
  SharedDtor();
}

void IMMsgReceiptListRsp::SharedDtor() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMMsgReceiptListRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMMsgReceiptListRsp& IMMsgReceiptListRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMMsgReceiptListRsp* IMMsgReceiptListRsp::default_instance_ = NULL;

IMMsgReceiptListRsp* IMMsgReceiptListRsp::New() const {
  return new IMMsgReceiptListRsp;
}

void IMMsgReceiptListRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMMsgReceiptListRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 119) {
    ZR_(group_company_id_, group_id_);
    if (has_msg_id()) {
      if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_id_->clear();
      }
    }
    is_more_data_ = 0u;
    update_time_ = GOOGLE_ULONGLONG(0);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  receipt_user_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMMsgReceiptListRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMMsgReceiptListRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string msg_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_group_company_id;
        break;
      }

      // required uint32 group_company_id = 2;
      case 2: {
        if (tag == 16) {
         parse_group_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_company_id_)));
          set_has_group_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 3;
      case 3: {
        if (tag == 24) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_receipt_user_list;
        break;
      }

      // repeated .IM.BaseDefine.UserIdItem receipt_user_list = 4;
      case 4: {
        if (tag == 34) {
         parse_receipt_user_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_receipt_user_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_receipt_user_list;
        if (input->ExpectTag(40)) goto parse_is_more_data;
        break;
      }

      // required uint32 is_more_data = 5;
      case 5: {
        if (tag == 40) {
         parse_is_more_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_more_data_)));
          set_has_is_more_data();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_update_time;
        break;
      }

      // required uint64 update_time = 6;
      case 6: {
        if (tag == 48) {
         parse_update_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &update_time_)));
          set_has_update_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMMsgReceiptListRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMMsgReceiptListRsp)
  return false;
#undef DO_
}

void IMMsgReceiptListRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMMsgReceiptListRsp)
  // required string msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->msg_id(), output);
  }

  // required uint32 group_company_id = 2;
  if (has_group_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group_company_id(), output);
  }

  // required uint32 group_id = 3;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->group_id(), output);
  }

  // repeated .IM.BaseDefine.UserIdItem receipt_user_list = 4;
  for (int i = 0; i < this->receipt_user_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->receipt_user_list(i), output);
  }

  // required uint32 is_more_data = 5;
  if (has_is_more_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->is_more_data(), output);
  }

  // required uint64 update_time = 6;
  if (has_update_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->update_time(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMMsgReceiptListRsp)
}

int IMMsgReceiptListRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg_id());
    }

    // required uint32 group_company_id = 2;
    if (has_group_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_company_id());
    }

    // required uint32 group_id = 3;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 is_more_data = 5;
    if (has_is_more_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_more_data());
    }

    // required uint64 update_time = 6;
    if (has_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->update_time());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.UserIdItem receipt_user_list = 4;
  total_size += 1 * this->receipt_user_list_size();
  for (int i = 0; i < this->receipt_user_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->receipt_user_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMMsgReceiptListRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgReceiptListRsp*>(&from));
}

void IMMsgReceiptListRsp::MergeFrom(const IMMsgReceiptListRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  receipt_user_list_.MergeFrom(from.receipt_user_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_group_company_id()) {
      set_group_company_id(from.group_company_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_is_more_data()) {
      set_is_more_data(from.is_more_data());
    }
    if (from.has_update_time()) {
      set_update_time(from.update_time());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMMsgReceiptListRsp::CopyFrom(const IMMsgReceiptListRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgReceiptListRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->receipt_user_list())) return false;
  return true;
}

void IMMsgReceiptListRsp::Swap(IMMsgReceiptListRsp* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(group_company_id_, other->group_company_id_);
    std::swap(group_id_, other->group_id_);
    receipt_user_list_.Swap(&other->receipt_user_list_);
    std::swap(is_more_data_, other->is_more_data_);
    std::swap(update_time_, other->update_time_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMMsgReceiptListRsp::GetTypeName() const {
  return "IM.Message.IMMsgReceiptListRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOfflineMsgCntReq::kFromCompanyIdFieldNumber;
const int IMOfflineMsgCntReq::kFromUserIdFieldNumber;
const int IMOfflineMsgCntReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOfflineMsgCntReq::IMOfflineMsgCntReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMOfflineMsgCntReq)
}

void IMOfflineMsgCntReq::InitAsDefaultInstance() {
}

IMOfflineMsgCntReq::IMOfflineMsgCntReq(const IMOfflineMsgCntReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMOfflineMsgCntReq)
}

void IMOfflineMsgCntReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOfflineMsgCntReq::~IMOfflineMsgCntReq() {
  // @@protoc_insertion_point(destructor:IM.Message.IMOfflineMsgCntReq)
  SharedDtor();
}

void IMOfflineMsgCntReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOfflineMsgCntReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOfflineMsgCntReq& IMOfflineMsgCntReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMOfflineMsgCntReq* IMOfflineMsgCntReq::default_instance_ = NULL;

IMOfflineMsgCntReq* IMOfflineMsgCntReq::New() const {
  return new IMOfflineMsgCntReq;
}

void IMOfflineMsgCntReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMOfflineMsgCntReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(from_company_id_, from_user_id_);
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOfflineMsgCntReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMOfflineMsgCntReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMOfflineMsgCntReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMOfflineMsgCntReq)
  return false;
#undef DO_
}

void IMOfflineMsgCntReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMOfflineMsgCntReq)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMOfflineMsgCntReq)
}

int IMOfflineMsgCntReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOfflineMsgCntReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOfflineMsgCntReq*>(&from));
}

void IMOfflineMsgCntReq::MergeFrom(const IMOfflineMsgCntReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOfflineMsgCntReq::CopyFrom(const IMOfflineMsgCntReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOfflineMsgCntReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IMOfflineMsgCntReq::Swap(IMOfflineMsgCntReq* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOfflineMsgCntReq::GetTypeName() const {
  return "IM.Message.IMOfflineMsgCntReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMOfflineMsgCntRsp::kOfflineMsgListFieldNumber;
const int IMOfflineMsgCntRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMOfflineMsgCntRsp::IMOfflineMsgCntRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMOfflineMsgCntRsp)
}

void IMOfflineMsgCntRsp::InitAsDefaultInstance() {
}

IMOfflineMsgCntRsp::IMOfflineMsgCntRsp(const IMOfflineMsgCntRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMOfflineMsgCntRsp)
}

void IMOfflineMsgCntRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMOfflineMsgCntRsp::~IMOfflineMsgCntRsp() {
  // @@protoc_insertion_point(destructor:IM.Message.IMOfflineMsgCntRsp)
  SharedDtor();
}

void IMOfflineMsgCntRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMOfflineMsgCntRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMOfflineMsgCntRsp& IMOfflineMsgCntRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMOfflineMsgCntRsp* IMOfflineMsgCntRsp::default_instance_ = NULL;

IMOfflineMsgCntRsp* IMOfflineMsgCntRsp::New() const {
  return new IMOfflineMsgCntRsp;
}

void IMOfflineMsgCntRsp::Clear() {
  if (has_attach_data()) {
    if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      attach_data_->clear();
    }
  }
  offline_msg_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMOfflineMsgCntRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMOfflineMsgCntRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.OfflineMsgCntInfo offline_msg_list = 1;
      case 1: {
        if (tag == 10) {
         parse_offline_msg_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_offline_msg_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_offline_msg_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMOfflineMsgCntRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMOfflineMsgCntRsp)
  return false;
#undef DO_
}

void IMOfflineMsgCntRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMOfflineMsgCntRsp)
  // repeated .IM.BaseDefine.OfflineMsgCntInfo offline_msg_list = 1;
  for (int i = 0; i < this->offline_msg_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->offline_msg_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMOfflineMsgCntRsp)
}

int IMOfflineMsgCntRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.OfflineMsgCntInfo offline_msg_list = 1;
  total_size += 1 * this->offline_msg_list_size();
  for (int i = 0; i < this->offline_msg_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->offline_msg_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMOfflineMsgCntRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOfflineMsgCntRsp*>(&from));
}

void IMOfflineMsgCntRsp::MergeFrom(const IMOfflineMsgCntRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  offline_msg_list_.MergeFrom(from.offline_msg_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMOfflineMsgCntRsp::CopyFrom(const IMOfflineMsgCntRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOfflineMsgCntRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->offline_msg_list())) return false;
  return true;
}

void IMOfflineMsgCntRsp::Swap(IMOfflineMsgCntRsp* other) {
  if (other != this) {
    offline_msg_list_.Swap(&other->offline_msg_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMOfflineMsgCntRsp::GetTypeName() const {
  return "IM.Message.IMOfflineMsgCntRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetMsgDataListReq::kFromCompanyIdFieldNumber;
const int IMGetMsgDataListReq::kFromUserIdFieldNumber;
const int IMGetMsgDataListReq::kToCompanyIdFieldNumber;
const int IMGetMsgDataListReq::kToUserIdFieldNumber;
const int IMGetMsgDataListReq::kSessionTypeFieldNumber;
const int IMGetMsgDataListReq::kLatestMsgTimeFieldNumber;
const int IMGetMsgDataListReq::kEndMsgTimeFieldNumber;
const int IMGetMsgDataListReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetMsgDataListReq::IMGetMsgDataListReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetMsgDataListReq)
}

void IMGetMsgDataListReq::InitAsDefaultInstance() {
}

IMGetMsgDataListReq::IMGetMsgDataListReq(const IMGetMsgDataListReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetMsgDataListReq)
}

void IMGetMsgDataListReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  session_type_ = 1;
  latest_msg_time_ = GOOGLE_ULONGLONG(0);
  end_msg_time_ = GOOGLE_ULONGLONG(0);
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetMsgDataListReq::~IMGetMsgDataListReq() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetMsgDataListReq)
  SharedDtor();
}

void IMGetMsgDataListReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetMsgDataListReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetMsgDataListReq& IMGetMsgDataListReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetMsgDataListReq* IMGetMsgDataListReq::default_instance_ = NULL;

IMGetMsgDataListReq* IMGetMsgDataListReq::New() const {
  return new IMGetMsgDataListReq;
}

void IMGetMsgDataListReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetMsgDataListReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(from_company_id_, end_msg_time_);
    session_type_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetMsgDataListReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetMsgDataListReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 5;
      case 5: {
        if (tag == 40) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 6;
      case 6: {
        if (tag == 48) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_latest_msg_time;
        break;
      }

      // required uint64 latest_msg_time = 7;
      case 7: {
        if (tag == 56) {
         parse_latest_msg_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &latest_msg_time_)));
          set_has_latest_msg_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_end_msg_time;
        break;
      }

      // optional uint64 end_msg_time = 8;
      case 8: {
        if (tag == 64) {
         parse_end_msg_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &end_msg_time_)));
          set_has_end_msg_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetMsgDataListReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetMsgDataListReq)
  return false;
#undef DO_
}

void IMGetMsgDataListReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetMsgDataListReq)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 4;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 5;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 6;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->session_type(), output);
  }

  // required uint64 latest_msg_time = 7;
  if (has_latest_msg_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->latest_msg_time(), output);
  }

  // optional uint64 end_msg_time = 8;
  if (has_end_msg_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->end_msg_time(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetMsgDataListReq)
}

int IMGetMsgDataListReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 4;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 5;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 6;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint64 latest_msg_time = 7;
    if (has_latest_msg_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->latest_msg_time());
    }

    // optional uint64 end_msg_time = 8;
    if (has_end_msg_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->end_msg_time());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetMsgDataListReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetMsgDataListReq*>(&from));
}

void IMGetMsgDataListReq::MergeFrom(const IMGetMsgDataListReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_latest_msg_time()) {
      set_latest_msg_time(from.latest_msg_time());
    }
    if (from.has_end_msg_time()) {
      set_end_msg_time(from.end_msg_time());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetMsgDataListReq::CopyFrom(const IMGetMsgDataListReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetMsgDataListReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMGetMsgDataListReq::Swap(IMGetMsgDataListReq* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(latest_msg_time_, other->latest_msg_time_);
    std::swap(end_msg_time_, other->end_msg_time_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetMsgDataListReq::GetTypeName() const {
  return "IM.Message.IMGetMsgDataListReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetMsgDataListRsp::kIsMoreDataFieldNumber;
const int IMGetMsgDataListRsp::kMsgDataListFieldNumber;
const int IMGetMsgDataListRsp::kCompanyIdFieldNumber;
const int IMGetMsgDataListRsp::kUserIdFieldNumber;
const int IMGetMsgDataListRsp::kSessionTypeFieldNumber;
const int IMGetMsgDataListRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetMsgDataListRsp::IMGetMsgDataListRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetMsgDataListRsp)
}

void IMGetMsgDataListRsp::InitAsDefaultInstance() {
}

IMGetMsgDataListRsp::IMGetMsgDataListRsp(const IMGetMsgDataListRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetMsgDataListRsp)
}

void IMGetMsgDataListRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  is_more_data_ = 0u;
  company_id_ = 0u;
  user_id_ = 0u;
  session_type_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetMsgDataListRsp::~IMGetMsgDataListRsp() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetMsgDataListRsp)
  SharedDtor();
}

void IMGetMsgDataListRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetMsgDataListRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetMsgDataListRsp& IMGetMsgDataListRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetMsgDataListRsp* IMGetMsgDataListRsp::default_instance_ = NULL;

IMGetMsgDataListRsp* IMGetMsgDataListRsp::New() const {
  return new IMGetMsgDataListRsp;
}

void IMGetMsgDataListRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetMsgDataListRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 61) {
    ZR_(is_more_data_, user_id_);
    session_type_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  msg_data_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetMsgDataListRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetMsgDataListRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 is_more_data = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &is_more_data_)));
          set_has_is_more_data();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg_data_list;
        break;
      }

      // repeated .IM.BaseDefine.MsgData msg_data_list = 2;
      case 2: {
        if (tag == 18) {
         parse_msg_data_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_msg_data_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg_data_list;
        if (input->ExpectTag(24)) goto parse_company_id;
        break;
      }

      // optional uint32 company_id = 3;
      case 3: {
        if (tag == 24) {
         parse_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &company_id_)));
          set_has_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_user_id;
        break;
      }

      // optional uint32 user_id = 4;
      case 4: {
        if (tag == 32) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_session_type;
        break;
      }

      // optional .IM.BaseDefine.SessionType session_type = 5;
      case 5: {
        if (tag == 40) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetMsgDataListRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetMsgDataListRsp)
  return false;
#undef DO_
}

void IMGetMsgDataListRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetMsgDataListRsp)
  // required uint32 is_more_data = 1;
  if (has_is_more_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->is_more_data(), output);
  }

  // repeated .IM.BaseDefine.MsgData msg_data_list = 2;
  for (int i = 0; i < this->msg_data_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->msg_data_list(i), output);
  }

  // optional uint32 company_id = 3;
  if (has_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->company_id(), output);
  }

  // optional uint32 user_id = 4;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->user_id(), output);
  }

  // optional .IM.BaseDefine.SessionType session_type = 5;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->session_type(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetMsgDataListRsp)
}

int IMGetMsgDataListRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 is_more_data = 1;
    if (has_is_more_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->is_more_data());
    }

    // optional uint32 company_id = 3;
    if (has_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->company_id());
    }

    // optional uint32 user_id = 4;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // optional .IM.BaseDefine.SessionType session_type = 5;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.MsgData msg_data_list = 2;
  total_size += 1 * this->msg_data_list_size();
  for (int i = 0; i < this->msg_data_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->msg_data_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetMsgDataListRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetMsgDataListRsp*>(&from));
}

void IMGetMsgDataListRsp::MergeFrom(const IMGetMsgDataListRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  msg_data_list_.MergeFrom(from.msg_data_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_more_data()) {
      set_is_more_data(from.is_more_data());
    }
    if (from.has_company_id()) {
      set_company_id(from.company_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetMsgDataListRsp::CopyFrom(const IMGetMsgDataListRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetMsgDataListRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->msg_data_list())) return false;
  return true;
}

void IMGetMsgDataListRsp::Swap(IMGetMsgDataListRsp* other) {
  if (other != this) {
    std::swap(is_more_data_, other->is_more_data_);
    msg_data_list_.Swap(&other->msg_data_list_);
    std::swap(company_id_, other->company_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetMsgDataListRsp::GetTypeName() const {
  return "IM.Message.IMGetMsgDataListRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetLatestMsgIdReq::kFromCompanyIdFieldNumber;
const int IMGetLatestMsgIdReq::kFromUserIdFieldNumber;
const int IMGetLatestMsgIdReq::kSessionTypeFieldNumber;
const int IMGetLatestMsgIdReq::kToCompanyIdFieldNumber;
const int IMGetLatestMsgIdReq::kToUserIdFieldNumber;
const int IMGetLatestMsgIdReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetLatestMsgIdReq::IMGetLatestMsgIdReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetLatestMsgIdReq)
}

void IMGetLatestMsgIdReq::InitAsDefaultInstance() {
}

IMGetLatestMsgIdReq::IMGetLatestMsgIdReq(const IMGetLatestMsgIdReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetLatestMsgIdReq)
}

void IMGetLatestMsgIdReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  session_type_ = 1;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetLatestMsgIdReq::~IMGetLatestMsgIdReq() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetLatestMsgIdReq)
  SharedDtor();
}

void IMGetLatestMsgIdReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetLatestMsgIdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetLatestMsgIdReq& IMGetLatestMsgIdReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetLatestMsgIdReq* IMGetLatestMsgIdReq::default_instance_ = NULL;

IMGetLatestMsgIdReq* IMGetLatestMsgIdReq::New() const {
  return new IMGetLatestMsgIdReq;
}

void IMGetLatestMsgIdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetLatestMsgIdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(from_company_id_, from_user_id_);
    session_type_ = 1;
    to_company_id_ = 0u;
    to_user_id_ = 0u;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetLatestMsgIdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetLatestMsgIdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 3;
      case 3: {
        if (tag == 24) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 5;
      case 5: {
        if (tag == 40) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetLatestMsgIdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetLatestMsgIdReq)
  return false;
#undef DO_
}

void IMGetLatestMsgIdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetLatestMsgIdReq)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 3;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->session_type(), output);
  }

  // required uint32 to_company_id = 4;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 5;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->to_user_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetLatestMsgIdReq)
}

int IMGetLatestMsgIdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 3;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint32 to_company_id = 4;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 5;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetLatestMsgIdReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetLatestMsgIdReq*>(&from));
}

void IMGetLatestMsgIdReq::MergeFrom(const IMGetLatestMsgIdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetLatestMsgIdReq::CopyFrom(const IMGetLatestMsgIdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetLatestMsgIdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMGetLatestMsgIdReq::Swap(IMGetLatestMsgIdReq* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetLatestMsgIdReq::GetTypeName() const {
  return "IM.Message.IMGetLatestMsgIdReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetLatestMsgIdRsp::kFromCompanyIdFieldNumber;
const int IMGetLatestMsgIdRsp::kFromUserIdFieldNumber;
const int IMGetLatestMsgIdRsp::kSessionTypeFieldNumber;
const int IMGetLatestMsgIdRsp::kToCompanyIdFieldNumber;
const int IMGetLatestMsgIdRsp::kToUserIdFieldNumber;
const int IMGetLatestMsgIdRsp::kLatestMsgIdFieldNumber;
const int IMGetLatestMsgIdRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetLatestMsgIdRsp::IMGetLatestMsgIdRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetLatestMsgIdRsp)
}

void IMGetLatestMsgIdRsp::InitAsDefaultInstance() {
}

IMGetLatestMsgIdRsp::IMGetLatestMsgIdRsp(const IMGetLatestMsgIdRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetLatestMsgIdRsp)
}

void IMGetLatestMsgIdRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  session_type_ = 1;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  latest_msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetLatestMsgIdRsp::~IMGetLatestMsgIdRsp() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetLatestMsgIdRsp)
  SharedDtor();
}

void IMGetLatestMsgIdRsp::SharedDtor() {
  if (latest_msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_id_;
  }
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetLatestMsgIdRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetLatestMsgIdRsp& IMGetLatestMsgIdRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetLatestMsgIdRsp* IMGetLatestMsgIdRsp::default_instance_ = NULL;

IMGetLatestMsgIdRsp* IMGetLatestMsgIdRsp::New() const {
  return new IMGetLatestMsgIdRsp;
}

void IMGetLatestMsgIdRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetLatestMsgIdRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(from_company_id_, from_user_id_);
    session_type_ = 1;
    to_company_id_ = 0u;
    to_user_id_ = 0u;
    if (has_latest_msg_id()) {
      if (latest_msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        latest_msg_id_->clear();
      }
    }
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetLatestMsgIdRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetLatestMsgIdRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 3;
      case 3: {
        if (tag == 24) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 5;
      case 5: {
        if (tag == 40) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_latest_msg_id;
        break;
      }

      // required string latest_msg_id = 6;
      case 6: {
        if (tag == 50) {
         parse_latest_msg_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_latest_msg_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetLatestMsgIdRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetLatestMsgIdRsp)
  return false;
#undef DO_
}

void IMGetLatestMsgIdRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetLatestMsgIdRsp)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 3;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->session_type(), output);
  }

  // required uint32 to_company_id = 4;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 5;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->to_user_id(), output);
  }

  // required string latest_msg_id = 6;
  if (has_latest_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->latest_msg_id(), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetLatestMsgIdRsp)
}

int IMGetLatestMsgIdRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 3;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint32 to_company_id = 4;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 5;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required string latest_msg_id = 6;
    if (has_latest_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->latest_msg_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetLatestMsgIdRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetLatestMsgIdRsp*>(&from));
}

void IMGetLatestMsgIdRsp::MergeFrom(const IMGetLatestMsgIdRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_latest_msg_id()) {
      set_latest_msg_id(from.latest_msg_id());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetLatestMsgIdRsp::CopyFrom(const IMGetLatestMsgIdRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetLatestMsgIdRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void IMGetLatestMsgIdRsp::Swap(IMGetLatestMsgIdRsp* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(latest_msg_id_, other->latest_msg_id_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetLatestMsgIdRsp::GetTypeName() const {
  return "IM.Message.IMGetLatestMsgIdRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetMsgByIdReq::kFromCompanyIdFieldNumber;
const int IMGetMsgByIdReq::kFromUserIdFieldNumber;
const int IMGetMsgByIdReq::kToCompanyIdFieldNumber;
const int IMGetMsgByIdReq::kToUserIdFieldNumber;
const int IMGetMsgByIdReq::kSessionTypeFieldNumber;
const int IMGetMsgByIdReq::kMsgIdListFieldNumber;
const int IMGetMsgByIdReq::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetMsgByIdReq::IMGetMsgByIdReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetMsgByIdReq)
}

void IMGetMsgByIdReq::InitAsDefaultInstance() {
}

IMGetMsgByIdReq::IMGetMsgByIdReq(const IMGetMsgByIdReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetMsgByIdReq)
}

void IMGetMsgByIdReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  session_type_ = 1;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetMsgByIdReq::~IMGetMsgByIdReq() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetMsgByIdReq)
  SharedDtor();
}

void IMGetMsgByIdReq::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetMsgByIdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetMsgByIdReq& IMGetMsgByIdReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetMsgByIdReq* IMGetMsgByIdReq::default_instance_ = NULL;

IMGetMsgByIdReq* IMGetMsgByIdReq::New() const {
  return new IMGetMsgByIdReq;
}

void IMGetMsgByIdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMGetMsgByIdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 95) {
    ZR_(from_company_id_, to_user_id_);
    session_type_ = 1;
    if (has_attach_data()) {
      if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        attach_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  msg_id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetMsgByIdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetMsgByIdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 5;
      case 5: {
        if (tag == 40) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 6;
      case 6: {
        if (tag == 48) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_msg_id_list;
        break;
      }

      // repeated string msg_id_list = 7;
      case 7: {
        if (tag == 58) {
         parse_msg_id_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_msg_id_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_msg_id_list;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetMsgByIdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetMsgByIdReq)
  return false;
#undef DO_
}

void IMGetMsgByIdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetMsgByIdReq)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 4;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 5;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 6;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->session_type(), output);
  }

  // repeated string msg_id_list = 7;
  for (int i = 0; i < this->msg_id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->msg_id_list(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetMsgByIdReq)
}

int IMGetMsgByIdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 4;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 5;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 6;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated string msg_id_list = 7;
  total_size += 1 * this->msg_id_list_size();
  for (int i = 0; i < this->msg_id_list_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->msg_id_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetMsgByIdReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetMsgByIdReq*>(&from));
}

void IMGetMsgByIdReq::MergeFrom(const IMGetMsgByIdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  msg_id_list_.MergeFrom(from.msg_id_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetMsgByIdReq::CopyFrom(const IMGetMsgByIdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetMsgByIdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMGetMsgByIdReq::Swap(IMGetMsgByIdReq* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(session_type_, other->session_type_);
    msg_id_list_.Swap(&other->msg_id_list_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetMsgByIdReq::GetTypeName() const {
  return "IM.Message.IMGetMsgByIdReq";
}


// ===================================================================

#ifndef _MSC_VER
const int IMGetMsgByIdRsp::kMsgDataFieldNumber;
const int IMGetMsgByIdRsp::kAttachDataFieldNumber;
#endif  // !_MSC_VER

IMGetMsgByIdRsp::IMGetMsgByIdRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMGetMsgByIdRsp)
}

void IMGetMsgByIdRsp::InitAsDefaultInstance() {
}

IMGetMsgByIdRsp::IMGetMsgByIdRsp(const IMGetMsgByIdRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMGetMsgByIdRsp)
}

void IMGetMsgByIdRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMGetMsgByIdRsp::~IMGetMsgByIdRsp() {
  // @@protoc_insertion_point(destructor:IM.Message.IMGetMsgByIdRsp)
  SharedDtor();
}

void IMGetMsgByIdRsp::SharedDtor() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMGetMsgByIdRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMGetMsgByIdRsp& IMGetMsgByIdRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMGetMsgByIdRsp* IMGetMsgByIdRsp::default_instance_ = NULL;

IMGetMsgByIdRsp* IMGetMsgByIdRsp::New() const {
  return new IMGetMsgByIdRsp;
}

void IMGetMsgByIdRsp::Clear() {
  if (has_attach_data()) {
    if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      attach_data_->clear();
    }
  }
  msg_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMGetMsgByIdRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMGetMsgByIdRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.MsgData msg_data = 1;
      case 1: {
        if (tag == 10) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_msg_data;
        if (input->ExpectTag(162)) goto parse_attach_data;
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (tag == 162) {
         parse_attach_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMGetMsgByIdRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMGetMsgByIdRsp)
  return false;
#undef DO_
}

void IMGetMsgByIdRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMGetMsgByIdRsp)
  // repeated .IM.BaseDefine.MsgData msg_data = 1;
  for (int i = 0; i < this->msg_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->msg_data(i), output);
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMGetMsgByIdRsp)
}

int IMGetMsgByIdRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  // repeated .IM.BaseDefine.MsgData msg_data = 1;
  total_size += 1 * this->msg_data_size();
  for (int i = 0; i < this->msg_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->msg_data(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMGetMsgByIdRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetMsgByIdRsp*>(&from));
}

void IMGetMsgByIdRsp::MergeFrom(const IMGetMsgByIdRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  msg_data_.MergeFrom(from.msg_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_attach_data()) {
      set_attach_data(from.attach_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMGetMsgByIdRsp::CopyFrom(const IMGetMsgByIdRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetMsgByIdRsp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->msg_data())) return false;
  return true;
}

void IMGetMsgByIdRsp::Swap(IMGetMsgByIdRsp* other) {
  if (other != this) {
    msg_data_.Swap(&other->msg_data_);
    std::swap(attach_data_, other->attach_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMGetMsgByIdRsp::GetTypeName() const {
  return "IM.Message.IMGetMsgByIdRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int IMP2PCmdMsg::kFromCompanyIdFieldNumber;
const int IMP2PCmdMsg::kFromUserIdFieldNumber;
const int IMP2PCmdMsg::kToCompanyIdFieldNumber;
const int IMP2PCmdMsg::kToUserIdFieldNumber;
const int IMP2PCmdMsg::kP2PMsgTypeFieldNumber;
#endif  // !_MSC_VER

IMP2PCmdMsg::IMP2PCmdMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Message.IMP2PCmdMsg)
}

void IMP2PCmdMsg::InitAsDefaultInstance() {
}

IMP2PCmdMsg::IMP2PCmdMsg(const IMP2PCmdMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.Message.IMP2PCmdMsg)
}

void IMP2PCmdMsg::SharedCtor() {
  _cached_size_ = 0;
  from_company_id_ = 0u;
  from_user_id_ = 0u;
  to_company_id_ = 0u;
  to_user_id_ = 0u;
  p2p_msg_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IMP2PCmdMsg::~IMP2PCmdMsg() {
  // @@protoc_insertion_point(destructor:IM.Message.IMP2PCmdMsg)
  SharedDtor();
}

void IMP2PCmdMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IMP2PCmdMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IMP2PCmdMsg& IMP2PCmdMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eMessage_2eproto();
#endif
  return *default_instance_;
}

IMP2PCmdMsg* IMP2PCmdMsg::default_instance_ = NULL;

IMP2PCmdMsg* IMP2PCmdMsg::New() const {
  return new IMP2PCmdMsg;
}

void IMP2PCmdMsg::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<IMP2PCmdMsg*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(from_company_id_, to_user_id_);
    p2p_msg_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IMP2PCmdMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.Message.IMP2PCmdMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_company_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_company_id_)));
          set_has_from_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_user_id;
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_to_company_id;
        break;
      }

      // required uint32 to_company_id = 3;
      case 3: {
        if (tag == 24) {
         parse_to_company_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_company_id_)));
          set_has_to_company_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_to_user_id;
        break;
      }

      // required uint32 to_user_id = 4;
      case 4: {
        if (tag == 32) {
         parse_to_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
          set_has_to_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_p2p_msg_type;
        break;
      }

      // required .IM.BaseDefine.P2PMsgCmdType p2p_msg_type = 5;
      case 5: {
        if (tag == 40) {
         parse_p2p_msg_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::P2PMsgCmdType_IsValid(value)) {
            set_p2p_msg_type(static_cast< ::IM::BaseDefine::P2PMsgCmdType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Message.IMP2PCmdMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Message.IMP2PCmdMsg)
  return false;
#undef DO_
}

void IMP2PCmdMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Message.IMP2PCmdMsg)
  // required uint32 from_company_id = 1;
  if (has_from_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_company_id(), output);
  }

  // required uint32 from_user_id = 2;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_company_id = 3;
  if (has_to_company_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_company_id(), output);
  }

  // required uint32 to_user_id = 4;
  if (has_to_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->to_user_id(), output);
  }

  // required .IM.BaseDefine.P2PMsgCmdType p2p_msg_type = 5;
  if (has_p2p_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->p2p_msg_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.Message.IMP2PCmdMsg)
}

int IMP2PCmdMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_company_id = 1;
    if (has_from_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_company_id());
    }

    // required uint32 from_user_id = 2;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required uint32 to_company_id = 3;
    if (has_to_company_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_company_id());
    }

    // required uint32 to_user_id = 4;
    if (has_to_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->to_user_id());
    }

    // required .IM.BaseDefine.P2PMsgCmdType p2p_msg_type = 5;
    if (has_p2p_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->p2p_msg_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IMP2PCmdMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMP2PCmdMsg*>(&from));
}

void IMP2PCmdMsg::MergeFrom(const IMP2PCmdMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_company_id()) {
      set_from_company_id(from.from_company_id());
    }
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_to_company_id()) {
      set_to_company_id(from.to_company_id());
    }
    if (from.has_to_user_id()) {
      set_to_user_id(from.to_user_id());
    }
    if (from.has_p2p_msg_type()) {
      set_p2p_msg_type(from.p2p_msg_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IMP2PCmdMsg::CopyFrom(const IMP2PCmdMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMP2PCmdMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void IMP2PCmdMsg::Swap(IMP2PCmdMsg* other) {
  if (other != this) {
    std::swap(from_company_id_, other->from_company_id_);
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(to_company_id_, other->to_company_id_);
    std::swap(to_user_id_, other->to_user_id_);
    std::swap(p2p_msg_type_, other->p2p_msg_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IMP2PCmdMsg::GetTypeName() const {
  return "IM.Message.IMP2PCmdMsg";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Message
}  // namespace IM

// @@protoc_insertion_point(global_scope)
