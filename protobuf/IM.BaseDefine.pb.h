// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#ifndef PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
#define PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace BaseDefine {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

class IpAddr;
class UserInfo;
class RecentContactInfo;
class RecentFixTop;
class FrequentContactInfo;
class UserStat;
class UserIdItem;
class ServerUserStat;
class MsgFont;
class MsgItem;
class MsgData;
class OfflineMsgCntInfo;
class GroupListItem;
class GroupMemberItem;
class GroupInfo;
class UserTokenInfo;
class PushResult;
class ShieldStatus;
class OfflineFileInfo;
class PushShieldStatus;
class IMBuddyReqInfo;
class IMSinglePullNotify;
class IMGroupPullNotify;
class IMUserAuthority;
class IMUserRole;

enum ServiceID {
  SID_LOGIN = 1,
  SID_PERSONAL_SERVER = 2,
  SID_GROUP = 3,
  SID_FILE = 4,
  SID_SWITCH_SERVICE = 5,
  SID_OTHER = 6,
  SID_INTERNAL = 7,
  SID_STATUS = 32,
  SID_ORG = 33,
  SID_ROUTER = 34,
  SID_USER_STATE = 35,
  SID_S2S_BROADCAST = 36,
  SID_EXT_MSG = 65,
  SID_EXT_GROUP = 66,
  SID_CONN = 96,
  SID_DISPATCH = 97,
  SID_DB_PROXY = 98,
  SID_CLIENT_HTTP = 99,
  SID_FILE_SSL = 100,
  SID_CONN_SSL = 101,
  SID_MSGPUSH_SERVER = 102
};
bool ServiceID_IsValid(int value);
const ServiceID ServiceID_MIN = SID_LOGIN;
const ServiceID ServiceID_MAX = SID_MSGPUSH_SERVER;
const int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

enum LoginCmdID {
  CID_LOGIN_REQ_CONNECTIONSERVER = 257,
  CID_LOGIN_RES_CONNECTIONSERVER = 258,
  CID_LOGIN_REQ_USERLOGIN = 259,
  CID_LOGIN_RES_USERLOGIN = 260,
  CID_LOGIN_REQ_LOGINOUT = 261,
  CID_LOGIN_RES_LOGINOUT = 262,
  CID_LOGIN_KICK_USER = 263,
  CID_LOGIN_REQ_KICK_OTHERCLIENT = 264,
  CID_LOGIN_RES_KICK_OTHERCLIENT = 265,
  CID_LOGIN_REQ_DEVICETOKEN = 266,
  CID_LOGIN_RES_DEVICETOKEN = 267,
  CID_LOGIN_REQ_PUSH_SHIELD = 268,
  CID_LOGIN_RES_PUSH_SHIELD = 269,
  CID_LOGIN_REQ_QUERY_PUSH_SHIELD = 270,
  CID_LOGIN_RES_QUERY_PUSH_SHIELD = 271,
  CID_LOGIN_SOCKET_DROP_NOTIFY_REQ = 272,
  CID_LOGIN_SOCKET_DROP_NOTIFY_RSP = 273,
  CID_LOGIN_MODIFY_PSWD_REQ = 274,
  CID_LOGIN_MODIFY_PSWD_RSP = 275,
  CID_LOGIN_MODIFY_USER_STAT_REQ = 276,
  CID_LOGIN_ROLE_AUTHORITY_REQ = 277,
  CID_LOGIN_ROLE_AUTHORITY_RSP = 278
};
bool LoginCmdID_IsValid(int value);
const LoginCmdID LoginCmdID_MIN = CID_LOGIN_REQ_CONNECTIONSERVER;
const LoginCmdID LoginCmdID_MAX = CID_LOGIN_ROLE_AUTHORITY_RSP;
const int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

enum BuddyListCmdID {
  CID_BUDDY_LIST_RECENT_CONTACT_LIST_REQUEST = 513,
  CID_BUDDY_LIST_RECENT_CONTACT_LIST_RESPONSE = 514,
  CID_BUDDY_LIST_RECENT_CONTACT_UPDATE_REQUEST = 515,
  CID_BUDDY_LIST_RECENT_CONTACT_UPDATE_RESPONSE = 516,
  CID_BUDDY_LIST_FREQUENT_CONTACT_LIST_REQUEST = 517,
  CID_BUDDY_LIST_FREQUENT_CONTACT_LIST_RESPONSE = 518,
  CID_BUDDY_LIST_SINGLE_USER_INFO_REQUEST = 519,
  CID_BUDDY_LIST_USER_INFO_RESPONSE = 520,
  CID_BUDDY_LIST_ALL_USER_REQUEST = 521,
  CID_BUDDY_LIST_ALL_USER_RESPONSE = 522,
  CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY = 526,
  CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 527,
  CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 528,
  CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY = 529,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST = 530,
  CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE = 531,
  CID_BUDDY_LIST_MODIFY_USER_INFO_REQUEST = 532,
  CID_BUDDY_LIST_MODIFY_USER_INFO_RESPONSE = 533,
  CID_BUDDY_LIST_OPT_REQUEST = 534,
  CID_BUDDY_LIST_OPT_RESPONSE = 535,
  CID_BUDDY_LIST_MODIFY_NICKNAME_REQUEST = 536,
  CID_BUDDY_LIST_REMARK_RESPONSE = 537,
  CID_BUDDY_LIST_REQUEST_LIST_REQUEST = 538,
  CID_BUDDY_LIST_REQUEST_LIST_RESPONSE = 539,
  CID_BUDDY_LIST_USER_STATUS_NOTIFY = 541,
  CID_BUDDY_LIST_SERVER_TYPE_NOTIFY = 542,
  CID_BUDDY_LISTITEM_REQ = 544,
  CID_BUDDY_LISTITEM_RSP = 545,
  CID_BUDDY_LISTFIXTOP_REQ = 546,
  CID_BUDDY_LISTFIXTOP_RSP = 547
};
bool BuddyListCmdID_IsValid(int value);
const BuddyListCmdID BuddyListCmdID_MIN = CID_BUDDY_LIST_RECENT_CONTACT_LIST_REQUEST;
const BuddyListCmdID BuddyListCmdID_MAX = CID_BUDDY_LISTFIXTOP_RSP;
const int BuddyListCmdID_ARRAYSIZE = BuddyListCmdID_MAX + 1;

enum MessageCmdID {
  CID_MSG_DATA = 769,
  CID_MSG_DATA_ACK = 770,
  CID_MSG_DATA_OPT_NOTIFY = 771,
  CID_MSG_RECEIPT_COUNT_REQ = 772,
  CID_MSG_RECEIPT_COUNT_RSP = 773,
  CID_MSG_RECEIPT_LIST_REQ = 774,
  CID_MSG_RECEIPT_LIST_RSP = 775,
  CID_MSG_SERVER_TIME_REQ = 776,
  CID_MSG_SERVER_TIME_RSP = 777,
  CID_MSG_OFFLINE_COUNT_REQ = 778,
  CID_MSG_OFFLINE_COUNT_RSP = 779,
  CID_GMSG_OFFLINE_COUNT_REQ = 793,
  CID_GMSG_OFFLINE_COUNT_RSP = 794,
  CID_MSG_DATA_LIST_REQ = 780,
  CID_MSG_DATA_LIST_RSP = 781,
  CID_MSG_OFFLINE_LIST_REQ = 782,
  CID_MSG_OFFLINE_LIST_RSP = 783,
  CID_MSG_GET_LATEST_MSG_ID_REQ = 784,
  CID_MSG_GET_LATEST_MSG_ID_RSP = 785,
  CID_MSG_GET_BY_MSG_ID_REQ = 786,
  CID_MSG_GET_BY_MSG_ID_RES = 787,
  CID_MSG_TYPING = 788,
  CID_MSG_TYPED = 789,
  CID_MSG_DATA_OFFLINE = 790,
  CID_MSG_DATA_ONLINE = 791,
  CID_MSG_P2P = 792,
  CID_MSG_DATA_DEL = 795
};
bool MessageCmdID_IsValid(int value);
const MessageCmdID MessageCmdID_MIN = CID_MSG_DATA;
const MessageCmdID MessageCmdID_MAX = CID_MSG_DATA_DEL;
const int MessageCmdID_ARRAYSIZE = MessageCmdID_MAX + 1;

enum GroupCmdID {
  CID_GROUP_LIST_REQ = 1025,
  CID_GROUP_LIST_RSP = 1026,
  CID_GROUP_INFO_REQ = 1027,
  CID_GROUP_INFO_RSP = 1028,
  CID_GROUP_MEMBER_REQ = 1029,
  CID_GROUP_MEMBER_RSP = 1030,
  CID_GROUP_CREATE_REQ = 1031,
  CID_GROUP_CREATE_RSP = 1032,
  CID_GROUP_DISSOLVE_REQ = 1033,
  CID_GROUP_DISSOLVE_RSP = 1034,
  CID_GROUP_OPT_NOTIFY = 1035,
  CID_GROUP_CHANGE_MEMBER_REQ = 1036,
  CID_GROUP_CHANGE_MEMBER_RSP = 1037,
  CID_GROUP_CHANGE_MEMBER_NOTIFY = 1038,
  CID_GROUP_MSG_ID_REQ = 1041,
  CID_GROUP_MSG_ID_RSP = 1042,
  CID_GROUP_INFO_MODIFY_REQ = 1043,
  CID_GROUP_INFO_MODIFY_RSP = 1044,
  CID_GROUP_INFO_MODIFY_NOTIFY = 1045,
  CID_GROUP_MSG_NOTIFY = 1046,
  CID_GROUP_LISTITEM_SET_REQ = 1047,
  CID_GROUP_LISTITEM_SET_RSP = 1048,
  CID_GROUP_OWNER_SET_REQ = 1049,
  CID_GROUP_OWNER_SET_RSP = 1050,
  CID_GROUP_OWNER_SET_NOTIFY = 1051,
  CID_GROUP_DISTURB_OPT_REQ = 1052,
  CID_GROUP_DISTURB_OPT_RSP = 1053,
  CID_USER_STATE_GROUP_SUBS_REQ = 1056,
  CID_USER_STATE_GROUP_UNSUBS_REQ = 1057,
  CID_USER_STATE_ORGNODE_SUBS_REQ = 1058,
  CID_USER_STATE_ORGNODE_UNSUBS_REQ = 16675,
  CID_USER_STATE_CHANGED_NOTIFY = 16676,
  CID_USER_STATE_ORGTREE_SUBS_REQ = 16677,
  CID_USER_STATE_ORGTREE_UNSUBS_REQ = 16678,
  CID_USER_STATE_ORGTREE_NOTIFY = 16679
};
bool GroupCmdID_IsValid(int value);
const GroupCmdID GroupCmdID_MIN = CID_GROUP_LIST_REQ;
const GroupCmdID GroupCmdID_MAX = CID_USER_STATE_ORGTREE_NOTIFY;
const int GroupCmdID_ARRAYSIZE = GroupCmdID_MAX + 1;

enum FileCmdID {
  CID_FILE_LOGIN_REQ = 1281,
  CID_FILE_LOGIN_RES = 1282,
  CID_FILE_STATE = 1283,
  CID_FILE_PULL_DATA_REQ = 1284,
  CID_FILE_PULL_DATA_RSP = 1285,
  CID_FILE_REQUEST = 1286,
  CID_FILE_RESPONSE = 1287,
  CID_FILE_NOTIFY = 1288,
  CID_FILE_HAS_OFFLINE_REQ = 1289,
  CID_FILE_HAS_OFFLINE_RES = 1290,
  CID_FILE_ADD_OFFLINE_REQ = 1291,
  CID_FILE_DEL_OFFLINE_REQ = 1292
};
bool FileCmdID_IsValid(int value);
const FileCmdID FileCmdID_MIN = CID_FILE_LOGIN_REQ;
const FileCmdID FileCmdID_MAX = CID_FILE_DEL_OFFLINE_REQ;
const int FileCmdID_ARRAYSIZE = FileCmdID_MAX + 1;

enum RouterCmdID {
  CID_ROUTER_CLIENT_REGISTER_REQ = 8705,
  CID_ROUTER_CLIENT_REGISTER_RSP = 8706,
  CID_ROUTER_CLIENT_GET_SERVICES_REQ = 8707,
  CID_ROUTER_CLIENT_GET_SERVICES_RSP = 8708,
  CID_ROUTER_UPDATE_CLIENT_REQ = 8709,
  CID_ROUTER_UPDATE_CLIENT_RSP = 8710,
  CID_ROUTER_PUSH_SERVER_STATUS = 8711,
  CID_ROUTER_CLIENT_BROADCAST_REQ = 8712,
  CID_ROUTER_CLIENT_BROADCAST_RSP = 8713,
  CID_ROUTER_PUSH_BROADCAST_MESSAGE = 8714,
  CID_ROUTER_CONN_SRV_STAT_REPORT_REQ = 8715,
  CID_ROUTER_CONN_SRV_LIST_STAT_REQ = 8716,
  CID_ROUTER_CONN_SRV_LIST_STAT_PUSH = 8717,
  CID_ROUTER_NODE_STOP_PUSH = 8718,
  CID_ROUTER_LOCALCACHE_REFRESH_NOTIFY = 8719
};
bool RouterCmdID_IsValid(int value);
const RouterCmdID RouterCmdID_MIN = CID_ROUTER_CLIENT_REGISTER_REQ;
const RouterCmdID RouterCmdID_MAX = CID_ROUTER_LOCALCACHE_REFRESH_NOTIFY;
const int RouterCmdID_ARRAYSIZE = RouterCmdID_MAX + 1;

enum SwitchServiceCmdID {
  CID_SWITCH_P2P_CMD = 1537
};
bool SwitchServiceCmdID_IsValid(int value);
const SwitchServiceCmdID SwitchServiceCmdID_MIN = CID_SWITCH_P2P_CMD;
const SwitchServiceCmdID SwitchServiceCmdID_MAX = CID_SWITCH_P2P_CMD;
const int SwitchServiceCmdID_ARRAYSIZE = SwitchServiceCmdID_MAX + 1;

enum OtherCmdID {
  CID_OTHER_HEARTBEAT = 1793,
  CID_OTHER_STOP_RECV_PACKET = 1794,
  CID_OTHER_VALIDATE_REQ = 1795,
  CID_OTHER_VALIDATE_RSP = 1796,
  CID_OTHER_GET_DEVICE_TOKEN_REQ = 1797,
  CID_OTHER_GET_DEVICE_TOKEN_RSP = 1798,
  CID_OTHER_ROLE_SET = 1799,
  CID_OTHER_ONLINE_USER_INFO = 1800,
  CID_OTHER_MSG_SERV_INFO = 1801,
  CID_OTHER_USER_STATUS_UPDATE = 1802,
  CID_OTHER_USER_CNT_UPDATE = 1803,
  CID_OTHER_SERVER_KICK_USER = 1805,
  CID_OTHER_LOGIN_STATUS_NOTIFY = 1806,
  CID_OTHER_PUSH_TO_USER_REQ = 1807,
  CID_OTHER_PUSH_TO_USER_RSP = 1808,
  CID_OTHER_GET_SHIELD_REQ = 1809,
  CID_OTHER_GET_SHIELD_RSP = 1810,
  CID_OTHER_FILE_TRANSFER_REQ = 1841,
  CID_OTHER_FILE_TRANSFER_RSP = 1842,
  CID_OTHER_FILE_SERVER_IP_REQ = 1843,
  CID_OTHER_FILE_SERVER_IP_RSP = 1844,
  CID_OTHER_GET_BUDDY_CONGFIG_REQUEST = 1817,
  CID_OTHER_GET_BUDDY_CONGFIG_RESPONSE = 1818,
  CID_OTHER_REQ_TO_MYSQL_REQ = 1819,
  CID_OTHER_REQ_TO_MYSQL_RSP = 1820,
  CID_OTHER_USER_STAT_BROADCAST = 1821,
  CID_OTHER_BUDDY_OPT_STORA_REQ = 1822,
  CID_OTHER_BUDDY_OPT_STORA_RSP = 1823,
  CID_OTHER_BUDDY_STORAGE_REQ = 1825,
  CID_OTHER_BUDDY_STORAGE_RSP = 1826,
  CID_OTHER_RECENT_CONTACT_STORAGE_REQ = 1827,
  CID_OTHER_RECENT_CONTACT_STORAGE_RSP = 1828,
  CID_OTHER_BUDDY_REQINFO_STORAGE = 1829,
  CID_OTHER_DEL_RECENT_CONTCAT = 1830,
  CID_OTHER_ALTER_PSWD_REQ = 1831,
  CID_OTHER_ALTER_PSWD_RSP = 1832,
  CID_OTHER_REPORT_ONLINE_INFO = 1833,
  CID_OTHER_REPORT_MSG_INFO = 1834,
  CID_OTHER_GET_USER_ROLE_REQ = 1835,
  CID_OTHER_GET_USER_ROLE_RSP = 1836,
  CID_OTHER_AUTHENTICATION_REQ = 1837,
  CID_OTHER_AUTHENTICATION_RSP = 1838
};
bool OtherCmdID_IsValid(int value);
const OtherCmdID OtherCmdID_MIN = CID_OTHER_HEARTBEAT;
const OtherCmdID OtherCmdID_MAX = CID_OTHER_FILE_SERVER_IP_RSP;
const int OtherCmdID_ARRAYSIZE = OtherCmdID_MAX + 1;

enum UserStateCmdID {
  S_CID_USER_STATE_UPDATE_REQ = 2049,
  S_CID_USER_STAT_PUSH_REQ = 2050,
  CID_USER_STATE_SERVER_PULL_STATUS = 2051,
  CID_USER_STATE_REQ = 2052,
  CID_USER_STATE_RSP = 2053,
  CID_USER_STATE_UPDATE_REQ = 2054,
  CID_USER_STATE_START_REQ = 2064,
  CID_USER_STATE_TMPUSER_SUBS_REQ = 2065,
  CID_USER_STATE_TMPUSER_UNSUBS_REQ = 2066,
  CID_USER_STATE_TMPGRP_SUBS_REQ = 2080,
  CID_USER_STATE_TMPGRP_UNSUBS_REQ = 2082,
  CID_USER_STATE_TMPORGTREE_SUBS_REQ = 2096,
  CID_USER_STATE_TMPORGTREE_UNSUBS_REQ = 2098,
  CID_COMPANY_ORG_UPDATE_NOTIFY = 2112
};
bool UserStateCmdID_IsValid(int value);
const UserStateCmdID UserStateCmdID_MIN = S_CID_USER_STATE_UPDATE_REQ;
const UserStateCmdID UserStateCmdID_MAX = CID_COMPANY_ORG_UPDATE_NOTIFY;
const int UserStateCmdID_ARRAYSIZE = UserStateCmdID_MAX + 1;

enum DBProxyCmdID {
  S_CID_DB_COMPANY_INFO_REQ = 2305,
  S_CID_DB_COMPANY_INFO_RSP = 2306,
  S_CID_DB_USER_INFO_REQ = 2307,
  S_CID_DB_USER_INFO_RSP = 2308,
  S_CID_DB_USER_FRIEND_LIST_REQ = 2309,
  S_CID_DB_USER_FRIEND_LIST_RSP = 2310,
  S_CID_DB_USER_FRIEND_VER_REQ = 2311,
  S_CID_DB_USER_FRIEND_VER_RSP = 2312,
  S_CID_DB_USER_GROUP_LIST_REQ = 2313,
  S_CID_DB_USER_GROUP_LIST_RSP = 2314,
  S_CID_DB_GROUP_MEMBER_REQ = 2315,
  S_CID_DB_GROUP_MEMBER_RSP = 2316,
  S_CID_DB_COMPANY_USER_LIST_REQ = 2317,
  S_CID_DB_COMPANY_USER_LIST_RSP = 2318,
  S_CID_DB_ORGTREE_REQ = 2321,
  S_CID_DB_ORGTREE_RSP = 2322,
  S_CID_DB_ORG_UPDATE_REQ = 2323,
  S_CID_DB_ORG_UPDATE_RSP = 2324
};
bool DBProxyCmdID_IsValid(int value);
const DBProxyCmdID DBProxyCmdID_MIN = S_CID_DB_COMPANY_INFO_REQ;
const DBProxyCmdID DBProxyCmdID_MAX = S_CID_DB_ORG_UPDATE_RSP;
const int DBProxyCmdID_ARRAYSIZE = DBProxyCmdID_MAX + 1;

enum OptResultCode {
  OPT_RESULT_SUCCESS = 1,
  OPT_RESULT_FAIL = 2
};
bool OptResultCode_IsValid(int value);
const OptResultCode OptResultCode_MIN = OPT_RESULT_SUCCESS;
const OptResultCode OptResultCode_MAX = OPT_RESULT_FAIL;
const int OptResultCode_ARRAYSIZE = OptResultCode_MAX + 1;

enum ResultType {
  REFUSE_REASON_NO_MSG_SERVER = 1,
  REFUSE_REASON_MSG_SERVER_FULL = 2,
  REFUSE_REASON_NO_DB_SERVER = 3,
  REFUSE_REASON_NO_LOGIN_SERVER = 4,
  REFUSE_REASON_NO_ROUTE_SERVER = 5,
  SERVER_REG_SUCCESSED = 6,
  SERVER_REG_FAILED = 7,
  RESULT_REQ_SUCCESSED = 8
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = REFUSE_REASON_NO_MSG_SERVER;
const ResultType ResultType_MAX = RESULT_REQ_SUCCESSED;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

enum LoginResultCode {
  RESULT_LOGIN_SUCCESSED = 1,
  RESULT_LOGIN_USER_OR_PWS_ERROR = 2,
  RESULT_LOGIN_VALIDATE_ERROR = 3,
  RESULT_LOGIN_LOGOUT_SUCCESSED = 4
};
bool LoginResultCode_IsValid(int value);
const LoginResultCode LoginResultCode_MIN = RESULT_LOGIN_SUCCESSED;
const LoginResultCode LoginResultCode_MAX = RESULT_LOGIN_LOGOUT_SUCCESSED;
const int LoginResultCode_ARRAYSIZE = LoginResultCode_MAX + 1;

enum KickReasonType {
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_OTHER_KICK = 2
};
bool KickReasonType_IsValid(int value);
const KickReasonType KickReasonType_MIN = KICK_REASON_DUPLICATE_USER;
const KickReasonType KickReasonType_MAX = KICK_REASON_OTHER_KICK;
const int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

enum OnlineListType {
  ONLINE_LIST_TYPE_FRIEND_LIST = 1
};
bool OnlineListType_IsValid(int value);
const OnlineListType OnlineListType_MIN = ONLINE_LIST_TYPE_FRIEND_LIST;
const OnlineListType OnlineListType_MAX = ONLINE_LIST_TYPE_FRIEND_LIST;
const int OnlineListType_ARRAYSIZE = OnlineListType_MAX + 1;

enum UserStatType {
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3
};
bool UserStatType_IsValid(int value);
const UserStatType UserStatType_MIN = USER_STATUS_ONLINE;
const UserStatType UserStatType_MAX = USER_STATUS_LEAVE;
const int UserStatType_ARRAYSIZE = UserStatType_MAX + 1;

enum SessionType {
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_MULTICHAT = 2,
  SESSION_TYPE_ORGGROUP = 3
};
bool SessionType_IsValid(int value);
const SessionType SessionType_MIN = SESSION_TYPE_SINGLE;
const SessionType SessionType_MAX = SESSION_TYPE_ORGGROUP;
const int SessionType_ARRAYSIZE = SessionType_MAX + 1;

enum BuddyOptType {
  OPT_ADD_FRQUENT_CONTACT = 1,
  OPT_DEL_FRQUENT_CONTACT = 2,
  OPT_DEL_RECENT_CONTACT = 3,
  OPT_SINGLE_ADD_FRQUENT_CONTACT = 4,
  OPT_DEL_RECENT_CONTACT_GROUP = 5
};
bool BuddyOptType_IsValid(int value);
const BuddyOptType BuddyOptType_MIN = OPT_ADD_FRQUENT_CONTACT;
const BuddyOptType BuddyOptType_MAX = OPT_DEL_RECENT_CONTACT_GROUP;
const int BuddyOptType_ARRAYSIZE = BuddyOptType_MAX + 1;

enum MsgType {
  MSG_TYPE_TEXT = 1,
  MSG_TYPE_AUDIO = 2,
  MSG_TYPE_FILE = 3,
  MSG_TYPE_DIR = 4,
  MSG_TYPE_PIC = 5,
  MSG_TYPE_VIDEO = 6,
  MSG_TYPE_EXTEND = 7,
  MSG_TYPE_APP_CUSTOM = 80
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_TYPE_TEXT;
const MsgType MsgType_MAX = MSG_TYPE_APP_CUSTOM;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum MsgProperty {
  MSG_PTOPERTY_NONE = 1,
  MSG_PROPERTY_RECEIPT = 2,
  MSG_PROPERTY_URGENT = 3,
  MSG_PROPERTY_QUOTE = 4,
  MSG_PROPERTY_RECALL = 5
};
bool MsgProperty_IsValid(int value);
const MsgProperty MsgProperty_MIN = MSG_PTOPERTY_NONE;
const MsgProperty MsgProperty_MAX = MSG_PROPERTY_RECALL;
const int MsgProperty_ARRAYSIZE = MsgProperty_MAX + 1;

enum P2PMsgCmdType {
  P2P_MSG_TYPE_SHAKE = 1,
  P2P_MSG_TYPE_TYPE = 2
};
bool P2PMsgCmdType_IsValid(int value);
const P2PMsgCmdType P2PMsgCmdType_MIN = P2P_MSG_TYPE_SHAKE;
const P2PMsgCmdType P2PMsgCmdType_MAX = P2P_MSG_TYPE_TYPE;
const int P2PMsgCmdType_ARRAYSIZE = P2PMsgCmdType_MAX + 1;

enum ClientType {
  CLIENT_TYPE_PC = 1,
  CLIENT_TYPE_WINDOWS = 5,
  CLIENT_TYPE_MAC = 9,
  CLIENT_TYPE_MOBILE = 2,
  CLIENT_TYPE_IOS = 6,
  CLIENT_TYPE_ANDROID = 16,
  CLIENT_TYPE_WP = 20
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT_TYPE_PC;
const ClientType ClientType_MAX = CLIENT_TYPE_WP;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

enum GroupType {
  GROUP_TYPE_MULTICHAT = 1,
  GROUP_TYPE_ORG = 2
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = GROUP_TYPE_MULTICHAT;
const GroupType GroupType_MAX = GROUP_TYPE_ORG;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

enum GroupMemberOptType {
  GROUP_MEMBER_OPT_ADD = 1,
  GROUP_MEMBER_OPT_DEL = 2,
  GROUP_MEMBER_OPT_MODIFY = 3
};
bool GroupMemberOptType_IsValid(int value);
const GroupMemberOptType GroupMemberOptType_MIN = GROUP_MEMBER_OPT_ADD;
const GroupMemberOptType GroupMemberOptType_MAX = GROUP_MEMBER_OPT_MODIFY;
const int GroupMemberOptType_ARRAYSIZE = GroupMemberOptType_MAX + 1;

enum ListItemOptType {
  LIST_ITEM_SHOW = 1,
  LIST_ITEM_HIDE = 2,
  LIST_ITEM_FIXTOP = 3,
  LIST_ITEM_UNFIXTOP = 4
};
bool ListItemOptType_IsValid(int value);
const ListItemOptType ListItemOptType_MIN = LIST_ITEM_SHOW;
const ListItemOptType ListItemOptType_MAX = LIST_ITEM_UNFIXTOP;
const int ListItemOptType_ARRAYSIZE = ListItemOptType_MAX + 1;

enum TransferFileType {
  FILE_TYPE_ONLINE = 1,
  FILE_TYPE_OFFLINE = 2
};
bool TransferFileType_IsValid(int value);
const TransferFileType TransferFileType_MIN = FILE_TYPE_ONLINE;
const TransferFileType TransferFileType_MAX = FILE_TYPE_OFFLINE;
const int TransferFileType_ARRAYSIZE = TransferFileType_MAX + 1;

enum ClientFileState {
  CLIENT_FILE_PEER_READY = 0,
  CLIENT_FILE_CANCEL = 1,
  CLIENT_FILE_REFUSE = 2,
  CLIENT_FILE_DONE = 3
};
bool ClientFileState_IsValid(int value);
const ClientFileState ClientFileState_MIN = CLIENT_FILE_PEER_READY;
const ClientFileState ClientFileState_MAX = CLIENT_FILE_DONE;
const int ClientFileState_ARRAYSIZE = ClientFileState_MAX + 1;

enum ClientFileRole {
  CLIENT_REALTIME_SENDER = 1,
  CLIENT_REALTIME_RECVER = 2,
  CLIENT_OFFLINE_UPLOAD = 3,
  CLIENT_OFFLINE_DOWNLOAD = 4
};
bool ClientFileRole_IsValid(int value);
const ClientFileRole ClientFileRole_MIN = CLIENT_REALTIME_SENDER;
const ClientFileRole ClientFileRole_MAX = CLIENT_OFFLINE_DOWNLOAD;
const int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

enum FileServerError {
  FILE_SERVER_ERRNO_OK = 0,
  FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
  FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
  FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
  FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
  FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
  FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
  FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
  FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
  FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
  FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
  FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
  FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12
};
bool FileServerError_IsValid(int value);
const FileServerError FileServerError_MIN = FILE_SERVER_ERRNO_OK;
const FileServerError FileServerError_MAX = FILE_SERVER_ERRNO_PULL_DATA_FINISHED;
const int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

enum ServerNotifyType {
  NOTIFY_TYPE_CONTACT = 1,
  NOTIFY_TYPE_GROUP = 2,
  NOTIFY_TYPE_RECENT = 3
};
bool ServerNotifyType_IsValid(int value);
const ServerNotifyType ServerNotifyType_MIN = NOTIFY_TYPE_CONTACT;
const ServerNotifyType ServerNotifyType_MAX = NOTIFY_TYPE_RECENT;
const int ServerNotifyType_ARRAYSIZE = ServerNotifyType_MAX + 1;

// ===================================================================

class IpAddr : public ::google::protobuf::MessageLite {
 public:
  IpAddr();
  virtual ~IpAddr();

  IpAddr(const IpAddr& from);

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IpAddr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IpAddr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IpAddr* other);

  // implements Message ----------------------------------------------

  IpAddr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IpAddr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IpAddr* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 user_gender = 3;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 3;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required string user_nick_name = 4;
  inline bool has_user_nick_name() const;
  inline void clear_user_nick_name();
  static const int kUserNickNameFieldNumber = 4;
  inline const ::std::string& user_nick_name() const;
  inline void set_user_nick_name(const ::std::string& value);
  inline void set_user_nick_name(const char* value);
  inline void set_user_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_user_nick_name();
  inline ::std::string* release_user_nick_name();
  inline void set_allocated_user_nick_name(::std::string* user_nick_name);

  // required string avatar_url = 5;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 5;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // required uint64 avatar_update_time = 6;
  inline bool has_avatar_update_time() const;
  inline void clear_avatar_update_time();
  static const int kAvatarUpdateTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 avatar_update_time() const;
  inline void set_avatar_update_time(::google::protobuf::uint64 value);

  // required string email = 7;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 7;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string user_real_name = 8;
  inline bool has_user_real_name() const;
  inline void clear_user_real_name();
  static const int kUserRealNameFieldNumber = 8;
  inline const ::std::string& user_real_name() const;
  inline void set_user_real_name(const ::std::string& value);
  inline void set_user_real_name(const char* value);
  inline void set_user_real_name(const char* value, size_t size);
  inline ::std::string* mutable_user_real_name();
  inline ::std::string* release_user_real_name();
  inline void set_allocated_user_real_name(::std::string* user_real_name);

  // required string user_mobile = 9;
  inline bool has_user_mobile() const;
  inline void clear_user_mobile();
  static const int kUserMobileFieldNumber = 9;
  inline const ::std::string& user_mobile() const;
  inline void set_user_mobile(const ::std::string& value);
  inline void set_user_mobile(const char* value);
  inline void set_user_mobile(const char* value, size_t size);
  inline ::std::string* mutable_user_mobile();
  inline ::std::string* release_user_mobile();
  inline void set_allocated_user_mobile(::std::string* user_mobile);

  // required string user_tel = 10;
  inline bool has_user_tel() const;
  inline void clear_user_tel();
  static const int kUserTelFieldNumber = 10;
  inline const ::std::string& user_tel() const;
  inline void set_user_tel(const ::std::string& value);
  inline void set_user_tel(const char* value);
  inline void set_user_tel(const char* value, size_t size);
  inline ::std::string* mutable_user_tel();
  inline ::std::string* release_user_tel();
  inline void set_allocated_user_tel(::std::string* user_tel);

  // required string user_english_name = 11;
  inline bool has_user_english_name() const;
  inline void clear_user_english_name();
  static const int kUserEnglishNameFieldNumber = 11;
  inline const ::std::string& user_english_name() const;
  inline void set_user_english_name(const ::std::string& value);
  inline void set_user_english_name(const char* value);
  inline void set_user_english_name(const char* value, size_t size);
  inline ::std::string* mutable_user_english_name();
  inline ::std::string* release_user_english_name();
  inline void set_allocated_user_english_name(::std::string* user_english_name);

  // required uint32 status = 12;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 12;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // required uint32 user_borndate = 13;
  inline bool has_user_borndate() const;
  inline void clear_user_borndate();
  static const int kUserBorndateFieldNumber = 13;
  inline ::google::protobuf::uint32 user_borndate() const;
  inline void set_user_borndate(::google::protobuf::uint32 value);

  // required uint64 update_time = 14;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 14;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // required uint32 work_id = 15;
  inline bool has_work_id() const;
  inline void clear_work_id();
  static const int kWorkIdFieldNumber = 15;
  inline ::google::protobuf::uint32 work_id() const;
  inline void set_work_id(::google::protobuf::uint32 value);

  // required string pos_json = 16;
  inline bool has_pos_json() const;
  inline void clear_pos_json();
  static const int kPosJsonFieldNumber = 16;
  inline const ::std::string& pos_json() const;
  inline void set_pos_json(const ::std::string& value);
  inline void set_pos_json(const char* value);
  inline void set_pos_json(const char* value, size_t size);
  inline ::std::string* mutable_pos_json();
  inline ::std::string* release_pos_json();
  inline void set_allocated_pos_json(::std::string* pos_json);

  // optional string sign_info = 17;
  inline bool has_sign_info() const;
  inline void clear_sign_info();
  static const int kSignInfoFieldNumber = 17;
  inline const ::std::string& sign_info() const;
  inline void set_sign_info(const ::std::string& value);
  inline void set_sign_info(const char* value);
  inline void set_sign_info(const char* value, size_t size);
  inline ::std::string* mutable_sign_info();
  inline ::std::string* release_sign_info();
  inline void set_allocated_sign_info(::std::string* sign_info);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_user_nick_name();
  inline void clear_has_user_nick_name();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_avatar_update_time();
  inline void clear_has_avatar_update_time();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_user_real_name();
  inline void clear_has_user_real_name();
  inline void set_has_user_mobile();
  inline void clear_has_user_mobile();
  inline void set_has_user_tel();
  inline void clear_has_user_tel();
  inline void set_has_user_english_name();
  inline void clear_has_user_english_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_user_borndate();
  inline void clear_has_user_borndate();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_work_id();
  inline void clear_has_work_id();
  inline void set_has_pos_json();
  inline void clear_has_pos_json();
  inline void set_has_sign_info();
  inline void clear_has_sign_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* user_nick_name_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint64 avatar_update_time_;
  ::std::string* email_;
  ::google::protobuf::uint32 user_gender_;
  ::google::protobuf::uint32 status_;
  ::std::string* user_real_name_;
  ::std::string* user_mobile_;
  ::std::string* user_tel_;
  ::std::string* user_english_name_;
  ::google::protobuf::uint64 update_time_;
  ::google::protobuf::uint32 user_borndate_;
  ::google::protobuf::uint32 work_id_;
  ::std::string* pos_json_;
  ::std::string* sign_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class RecentContactInfo : public ::google::protobuf::MessageLite {
 public:
  RecentContactInfo();
  virtual ~RecentContactInfo();

  RecentContactInfo(const RecentContactInfo& from);

  inline RecentContactInfo& operator=(const RecentContactInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RecentContactInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RecentContactInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RecentContactInfo* other);

  // implements Message ----------------------------------------------

  RecentContactInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RecentContactInfo& from);
  void MergeFrom(const RecentContactInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 contact_id = 2;
  inline bool has_contact_id() const;
  inline void clear_contact_id();
  static const int kContactIdFieldNumber = 2;
  inline ::google::protobuf::uint32 contact_id() const;
  inline void set_contact_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 3;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 3;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint64 contact_info_update_time = 4;
  inline bool has_contact_info_update_time() const;
  inline void clear_contact_info_update_time();
  static const int kContactInfoUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 contact_info_update_time() const;
  inline void set_contact_info_update_time(::google::protobuf::uint64 value);

  // required string contact_name = 5;
  inline bool has_contact_name() const;
  inline void clear_contact_name();
  static const int kContactNameFieldNumber = 5;
  inline const ::std::string& contact_name() const;
  inline void set_contact_name(const ::std::string& value);
  inline void set_contact_name(const char* value);
  inline void set_contact_name(const char* value, size_t size);
  inline ::std::string* mutable_contact_name();
  inline ::std::string* release_contact_name();
  inline void set_allocated_contact_name(::std::string* contact_name);

  // required string contact_remark = 6;
  inline bool has_contact_remark() const;
  inline void clear_contact_remark();
  static const int kContactRemarkFieldNumber = 6;
  inline const ::std::string& contact_remark() const;
  inline void set_contact_remark(const ::std::string& value);
  inline void set_contact_remark(const char* value);
  inline void set_contact_remark(const char* value, size_t size);
  inline ::std::string* mutable_contact_remark();
  inline ::std::string* release_contact_remark();
  inline void set_allocated_contact_remark(::std::string* contact_remark);

  // required uint32 user_gender = 7;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 7;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required bool is_fixtop = 8;
  inline bool has_is_fixtop() const;
  inline void clear_is_fixtop();
  static const int kIsFixtopFieldNumber = 8;
  inline bool is_fixtop() const;
  inline void set_is_fixtop(bool value);

  // required uint32 top_order = 9;
  inline bool has_top_order() const;
  inline void clear_top_order();
  static const int kTopOrderFieldNumber = 9;
  inline ::google::protobuf::uint32 top_order() const;
  inline void set_top_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.RecentContactInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_contact_id();
  inline void clear_has_contact_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_contact_info_update_time();
  inline void clear_has_contact_info_update_time();
  inline void set_has_contact_name();
  inline void clear_has_contact_name();
  inline void set_has_contact_remark();
  inline void clear_has_contact_remark();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_is_fixtop();
  inline void clear_has_is_fixtop();
  inline void set_has_top_order();
  inline void clear_has_top_order();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 contact_id_;
  ::google::protobuf::uint64 contact_info_update_time_;
  ::std::string* contact_name_;
  int session_type_;
  ::google::protobuf::uint32 user_gender_;
  ::std::string* contact_remark_;
  bool is_fixtop_;
  ::google::protobuf::uint32 top_order_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static RecentContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class RecentFixTop : public ::google::protobuf::MessageLite {
 public:
  RecentFixTop();
  virtual ~RecentFixTop();

  RecentFixTop(const RecentFixTop& from);

  inline RecentFixTop& operator=(const RecentFixTop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RecentFixTop& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RecentFixTop* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RecentFixTop* other);

  // implements Message ----------------------------------------------

  RecentFixTop* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RecentFixTop& from);
  void MergeFrom(const RecentFixTop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint64 update_time = 3;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // required string contact_remark = 4;
  inline bool has_contact_remark() const;
  inline void clear_contact_remark();
  static const int kContactRemarkFieldNumber = 4;
  inline const ::std::string& contact_remark() const;
  inline void set_contact_remark(const ::std::string& value);
  inline void set_contact_remark(const char* value);
  inline void set_contact_remark(const char* value, size_t size);
  inline ::std::string* mutable_contact_remark();
  inline ::std::string* release_contact_remark();
  inline void set_allocated_contact_remark(::std::string* contact_remark);

  // required uint32 user_gender = 5;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 5;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required uint32 top_order = 6;
  inline bool has_top_order() const;
  inline void clear_top_order();
  static const int kTopOrderFieldNumber = 6;
  inline ::google::protobuf::uint32 top_order() const;
  inline void set_top_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.RecentFixTop)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_contact_remark();
  inline void clear_has_contact_remark();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_top_order();
  inline void clear_has_top_order();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint64 update_time_;
  ::std::string* contact_remark_;
  ::google::protobuf::uint32 user_gender_;
  ::google::protobuf::uint32 top_order_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static RecentFixTop* default_instance_;
};
// -------------------------------------------------------------------

class FrequentContactInfo : public ::google::protobuf::MessageLite {
 public:
  FrequentContactInfo();
  virtual ~FrequentContactInfo();

  FrequentContactInfo(const FrequentContactInfo& from);

  inline FrequentContactInfo& operator=(const FrequentContactInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FrequentContactInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FrequentContactInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FrequentContactInfo* other);

  // implements Message ----------------------------------------------

  FrequentContactInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FrequentContactInfo& from);
  void MergeFrom(const FrequentContactInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 contact_id = 2;
  inline bool has_contact_id() const;
  inline void clear_contact_id();
  static const int kContactIdFieldNumber = 2;
  inline ::google::protobuf::uint32 contact_id() const;
  inline void set_contact_id(::google::protobuf::uint32 value);

  // required string contact_name = 3;
  inline bool has_contact_name() const;
  inline void clear_contact_name();
  static const int kContactNameFieldNumber = 3;
  inline const ::std::string& contact_name() const;
  inline void set_contact_name(const ::std::string& value);
  inline void set_contact_name(const char* value);
  inline void set_contact_name(const char* value, size_t size);
  inline ::std::string* mutable_contact_name();
  inline ::std::string* release_contact_name();
  inline void set_allocated_contact_name(::std::string* contact_name);

  // required string contact_nick_name = 4;
  inline bool has_contact_nick_name() const;
  inline void clear_contact_nick_name();
  static const int kContactNickNameFieldNumber = 4;
  inline const ::std::string& contact_nick_name() const;
  inline void set_contact_nick_name(const ::std::string& value);
  inline void set_contact_nick_name(const char* value);
  inline void set_contact_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_contact_nick_name();
  inline ::std::string* release_contact_nick_name();
  inline void set_allocated_contact_nick_name(::std::string* contact_nick_name);

  // required string avatar_url = 5;
  inline bool has_avatar_url() const;
  inline void clear_avatar_url();
  static const int kAvatarUrlFieldNumber = 5;
  inline const ::std::string& avatar_url() const;
  inline void set_avatar_url(const ::std::string& value);
  inline void set_avatar_url(const char* value);
  inline void set_avatar_url(const char* value, size_t size);
  inline ::std::string* mutable_avatar_url();
  inline ::std::string* release_avatar_url();
  inline void set_allocated_avatar_url(::std::string* avatar_url);

  // required uint32 user_gender = 6;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 6;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required uint64 last_update_time = 7;
  inline bool has_last_update_time() const;
  inline void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 last_update_time() const;
  inline void set_last_update_time(::google::protobuf::uint64 value);

  // required bool is_delete = 8;
  inline bool has_is_delete() const;
  inline void clear_is_delete();
  static const int kIsDeleteFieldNumber = 8;
  inline bool is_delete() const;
  inline void set_is_delete(bool value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.FrequentContactInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_contact_id();
  inline void clear_has_contact_id();
  inline void set_has_contact_name();
  inline void clear_has_contact_name();
  inline void set_has_contact_nick_name();
  inline void clear_has_contact_nick_name();
  inline void set_has_avatar_url();
  inline void clear_has_avatar_url();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_last_update_time();
  inline void clear_has_last_update_time();
  inline void set_has_is_delete();
  inline void clear_has_is_delete();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 contact_id_;
  ::std::string* contact_name_;
  ::std::string* contact_nick_name_;
  ::std::string* avatar_url_;
  ::google::protobuf::uint64 last_update_time_;
  ::google::protobuf::uint32 user_gender_;
  bool is_delete_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static FrequentContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserStat : public ::google::protobuf::MessageLite {
 public:
  UserStat();
  virtual ~UserStat();

  UserStat(const UserStat& from);

  inline UserStat& operator=(const UserStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStat* other);

  // implements Message ----------------------------------------------

  UserStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStat& from);
  void MergeFrom(const UserStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::IM::BaseDefine::UserStatType status() const;
  inline void set_status(::IM::BaseDefine::UserStatType value);

  // optional string custom_status = 20;
  inline bool has_custom_status() const;
  inline void clear_custom_status();
  static const int kCustomStatusFieldNumber = 20;
  inline const ::std::string& custom_status() const;
  inline void set_custom_status(const ::std::string& value);
  inline void set_custom_status(const char* value);
  inline void set_custom_status(const char* value, size_t size);
  inline ::std::string* mutable_custom_status();
  inline ::std::string* release_custom_status();
  inline void set_allocated_custom_status(::std::string* custom_status);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserStat)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_custom_status();
  inline void clear_has_custom_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* custom_status_;
  int status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserStat* default_instance_;
};
// -------------------------------------------------------------------

class UserIdItem : public ::google::protobuf::MessageLite {
 public:
  UserIdItem();
  virtual ~UserIdItem();

  UserIdItem(const UserIdItem& from);

  inline UserIdItem& operator=(const UserIdItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserIdItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserIdItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserIdItem* other);

  // implements Message ----------------------------------------------

  UserIdItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserIdItem& from);
  void MergeFrom(const UserIdItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserIdItem)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserIdItem* default_instance_;
};
// -------------------------------------------------------------------

class ServerUserStat : public ::google::protobuf::MessageLite {
 public:
  ServerUserStat();
  virtual ~ServerUserStat();

  ServerUserStat(const ServerUserStat& from);

  inline ServerUserStat& operator=(const ServerUserStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ServerUserStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServerUserStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServerUserStat* other);

  // implements Message ----------------------------------------------

  ServerUserStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServerUserStat& from);
  void MergeFrom(const ServerUserStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::IM::BaseDefine::UserStatType status() const;
  inline void set_status(::IM::BaseDefine::UserStatType value);

  // required .IM.BaseDefine.ClientType client_type = 4;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 4;
  inline ::IM::BaseDefine::ClientType client_type() const;
  inline void set_client_type(::IM::BaseDefine::ClientType value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ServerUserStat)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_client_type();
  inline void clear_has_client_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  int status_;
  int client_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ServerUserStat* default_instance_;
};
// -------------------------------------------------------------------

class MsgFont : public ::google::protobuf::MessageLite {
 public:
  MsgFont();
  virtual ~MsgFont();

  MsgFont(const MsgFont& from);

  inline MsgFont& operator=(const MsgFont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgFont& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgFont* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgFont* other);

  // implements Message ----------------------------------------------

  MsgFont* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgFont& from);
  void MergeFrom(const MsgFont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string font_name = 1;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 1;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  inline ::std::string* release_font_name();
  inline void set_allocated_font_name(::std::string* font_name);

  // required uint32 font_size = 2;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 font_size() const;
  inline void set_font_size(::google::protobuf::uint32 value);

  // required uint32 font_color = 3;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 3;
  inline ::google::protobuf::uint32 font_color() const;
  inline void set_font_color(::google::protobuf::uint32 value);

  // required uint32 font_style = 4;
  inline bool has_font_style() const;
  inline void clear_font_style();
  static const int kFontStyleFieldNumber = 4;
  inline ::google::protobuf::uint32 font_style() const;
  inline void set_font_style(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgFont)
 private:
  inline void set_has_font_name();
  inline void clear_has_font_name();
  inline void set_has_font_size();
  inline void clear_has_font_size();
  inline void set_has_font_color();
  inline void clear_has_font_color();
  inline void set_has_font_style();
  inline void clear_has_font_style();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* font_name_;
  ::google::protobuf::uint32 font_size_;
  ::google::protobuf::uint32 font_color_;
  ::google::protobuf::uint32 font_style_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static MsgFont* default_instance_;
};
// -------------------------------------------------------------------

class MsgItem : public ::google::protobuf::MessageLite {
 public:
  MsgItem();
  virtual ~MsgItem();

  MsgItem(const MsgItem& from);

  inline MsgItem& operator=(const MsgItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgItem* other);

  // implements Message ----------------------------------------------

  MsgItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgItem& from);
  void MergeFrom(const MsgItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .IM.BaseDefine.MsgType msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::IM::BaseDefine::MsgType msg_type() const;
  inline void set_msg_type(::IM::BaseDefine::MsgType value);

  // required string msg_data = 2;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 2;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const char* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgItem)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_data_;
  int msg_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static MsgItem* default_instance_;
};
// -------------------------------------------------------------------

class MsgData : public ::google::protobuf::MessageLite {
 public:
  MsgData();
  virtual ~MsgData();

  MsgData(const MsgData& from);

  inline MsgData& operator=(const MsgData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgData* other);

  // implements Message ----------------------------------------------

  MsgData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgData& from);
  void MergeFrom(const MsgData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline const ::std::string& msg_id() const;
  inline void set_msg_id(const ::std::string& value);
  inline void set_msg_id(const char* value);
  inline void set_msg_id(const char* value, size_t size);
  inline ::std::string* mutable_msg_id();
  inline ::std::string* release_msg_id();
  inline void set_allocated_msg_id(::std::string* msg_id);

  // required uint32 from_company_id = 2;
  inline bool has_from_company_id() const;
  inline void clear_from_company_id();
  static const int kFromCompanyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_company_id() const;
  inline void set_from_company_id(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 3;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_company_id = 4;
  inline bool has_to_company_id() const;
  inline void clear_to_company_id();
  static const int kToCompanyIdFieldNumber = 4;
  inline ::google::protobuf::uint32 to_company_id() const;
  inline void set_to_company_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 5;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 5;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 6;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 6;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint64 create_time = 7;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // repeated .IM.BaseDefine.MsgItem msg_content = 8;
  inline int msg_content_size() const;
  inline void clear_msg_content();
  static const int kMsgContentFieldNumber = 8;
  inline const ::IM::BaseDefine::MsgItem& msg_content(int index) const;
  inline ::IM::BaseDefine::MsgItem* mutable_msg_content(int index);
  inline ::IM::BaseDefine::MsgItem* add_msg_content();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::MsgItem >&
      msg_content() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::MsgItem >*
      mutable_msg_content();

  // required .IM.BaseDefine.MsgFont msg_font = 9;
  inline bool has_msg_font() const;
  inline void clear_msg_font();
  static const int kMsgFontFieldNumber = 9;
  inline const ::IM::BaseDefine::MsgFont& msg_font() const;
  inline ::IM::BaseDefine::MsgFont* mutable_msg_font();
  inline ::IM::BaseDefine::MsgFont* release_msg_font();
  inline void set_allocated_msg_font(::IM::BaseDefine::MsgFont* msg_font);

  // required uint32 msg_status = 10;
  inline bool has_msg_status() const;
  inline void clear_msg_status();
  static const int kMsgStatusFieldNumber = 10;
  inline ::google::protobuf::uint32 msg_status() const;
  inline void set_msg_status(::google::protobuf::uint32 value);

  // optional .IM.BaseDefine.MsgProperty msg_property = 11;
  inline bool has_msg_property() const;
  inline void clear_msg_property();
  static const int kMsgPropertyFieldNumber = 11;
  inline ::IM::BaseDefine::MsgProperty msg_property() const;
  inline void set_msg_property(::IM::BaseDefine::MsgProperty value);

  // repeated .IM.BaseDefine.UserIdItem force_push_ids_list = 15;
  inline int force_push_ids_list_size() const;
  inline void clear_force_push_ids_list();
  static const int kForcePushIdsListFieldNumber = 15;
  inline const ::IM::BaseDefine::UserIdItem& force_push_ids_list(int index) const;
  inline ::IM::BaseDefine::UserIdItem* mutable_force_push_ids_list(int index);
  inline ::IM::BaseDefine::UserIdItem* add_force_push_ids_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserIdItem >&
      force_push_ids_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserIdItem >*
      mutable_force_push_ids_list();

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgData)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_from_company_id();
  inline void clear_has_from_company_id();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_company_id();
  inline void clear_has_to_company_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_msg_font();
  inline void clear_has_msg_font();
  inline void set_has_msg_status();
  inline void clear_has_msg_status();
  inline void set_has_msg_property();
  inline void clear_has_msg_property();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msg_id_;
  ::google::protobuf::uint32 from_company_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_company_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint64 create_time_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::MsgItem > msg_content_;
  int session_type_;
  ::google::protobuf::uint32 msg_status_;
  ::IM::BaseDefine::MsgFont* msg_font_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserIdItem > force_push_ids_list_;
  int msg_property_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static MsgData* default_instance_;
};
// -------------------------------------------------------------------

class OfflineMsgCntInfo : public ::google::protobuf::MessageLite {
 public:
  OfflineMsgCntInfo();
  virtual ~OfflineMsgCntInfo();

  OfflineMsgCntInfo(const OfflineMsgCntInfo& from);

  inline OfflineMsgCntInfo& operator=(const OfflineMsgCntInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OfflineMsgCntInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineMsgCntInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineMsgCntInfo* other);

  // implements Message ----------------------------------------------

  OfflineMsgCntInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineMsgCntInfo& from);
  void MergeFrom(const OfflineMsgCntInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msg_cnt = 1;
  inline bool has_msg_cnt() const;
  inline void clear_msg_cnt();
  static const int kMsgCntFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_cnt() const;
  inline void set_msg_cnt(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.MsgData lastest_msg_data = 2;
  inline bool has_lastest_msg_data() const;
  inline void clear_lastest_msg_data();
  static const int kLastestMsgDataFieldNumber = 2;
  inline const ::IM::BaseDefine::MsgData& lastest_msg_data() const;
  inline ::IM::BaseDefine::MsgData* mutable_lastest_msg_data();
  inline ::IM::BaseDefine::MsgData* release_lastest_msg_data();
  inline void set_allocated_lastest_msg_data(::IM::BaseDefine::MsgData* lastest_msg_data);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.OfflineMsgCntInfo)
 private:
  inline void set_has_msg_cnt();
  inline void clear_has_msg_cnt();
  inline void set_has_lastest_msg_data();
  inline void clear_has_lastest_msg_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::IM::BaseDefine::MsgData* lastest_msg_data_;
  ::google::protobuf::uint32 msg_cnt_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static OfflineMsgCntInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupListItem : public ::google::protobuf::MessageLite {
 public:
  GroupListItem();
  virtual ~GroupListItem();

  GroupListItem(const GroupListItem& from);

  inline GroupListItem& operator=(const GroupListItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupListItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupListItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupListItem* other);

  // implements Message ----------------------------------------------

  GroupListItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupListItem& from);
  void MergeFrom(const GroupListItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupType group_type = 3;
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 3;
  inline ::IM::BaseDefine::GroupType group_type() const;
  inline void set_group_type(::IM::BaseDefine::GroupType value);

  // required uint64 update_time = 4;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupListItem)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint64 update_time_;
  int group_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupListItem* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberItem : public ::google::protobuf::MessageLite {
 public:
  GroupMemberItem();
  virtual ~GroupMemberItem();

  GroupMemberItem(const GroupMemberItem& from);

  inline GroupMemberItem& operator=(const GroupMemberItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupMemberItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupMemberItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupMemberItem* other);

  // implements Message ----------------------------------------------

  GroupMemberItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupMemberItem& from);
  void MergeFrom(const GroupMemberItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 member_id = 2;
  inline bool has_member_id() const;
  inline void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  inline ::google::protobuf::uint32 member_id() const;
  inline void set_member_id(::google::protobuf::uint32 value);

  // required string member_name = 3;
  inline bool has_member_name() const;
  inline void clear_member_name();
  static const int kMemberNameFieldNumber = 3;
  inline const ::std::string& member_name() const;
  inline void set_member_name(const ::std::string& value);
  inline void set_member_name(const char* value);
  inline void set_member_name(const char* value, size_t size);
  inline ::std::string* mutable_member_name();
  inline ::std::string* release_member_name();
  inline void set_allocated_member_name(::std::string* member_name);

  // required uint32 member_role = 4;
  inline bool has_member_role() const;
  inline void clear_member_role();
  static const int kMemberRoleFieldNumber = 4;
  inline ::google::protobuf::uint32 member_role() const;
  inline void set_member_role(::google::protobuf::uint32 value);

  // required bool is_delete = 5;
  inline bool has_is_delete() const;
  inline void clear_is_delete();
  static const int kIsDeleteFieldNumber = 5;
  inline bool is_delete() const;
  inline void set_is_delete(bool value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupMemberItem)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_member_id();
  inline void clear_has_member_id();
  inline void set_has_member_name();
  inline void clear_has_member_name();
  inline void set_has_member_role();
  inline void clear_has_member_role();
  inline void set_has_is_delete();
  inline void clear_has_is_delete();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 member_id_;
  ::std::string* member_name_;
  ::google::protobuf::uint32 member_role_;
  bool is_delete_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberItem* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::MessageLite {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupInfo* other);

  // implements Message ----------------------------------------------

  GroupInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint64 update_time = 3;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // required string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional string group_avatar = 5;
  inline bool has_group_avatar() const;
  inline void clear_group_avatar();
  static const int kGroupAvatarFieldNumber = 5;
  inline const ::std::string& group_avatar() const;
  inline void set_group_avatar(const ::std::string& value);
  inline void set_group_avatar(const char* value);
  inline void set_group_avatar(const char* value, size_t size);
  inline ::std::string* mutable_group_avatar();
  inline ::std::string* release_group_avatar();
  inline void set_allocated_group_avatar(::std::string* group_avatar);

  // required uint32 group_creator_id = 6;
  inline bool has_group_creator_id() const;
  inline void clear_group_creator_id();
  static const int kGroupCreatorIdFieldNumber = 6;
  inline ::google::protobuf::uint32 group_creator_id() const;
  inline void set_group_creator_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupType group_type = 7;
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 7;
  inline ::IM::BaseDefine::GroupType group_type() const;
  inline void set_group_type(::IM::BaseDefine::GroupType value);

  // optional uint32 shield_status = 8;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 8;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // required uint32 group_member_count = 9;
  inline bool has_group_member_count() const;
  inline void clear_group_member_count();
  static const int kGroupMemberCountFieldNumber = 9;
  inline ::google::protobuf::uint32 group_member_count() const;
  inline void set_group_member_count(::google::protobuf::uint32 value);

  // optional bool is_delete = 10;
  inline bool has_is_delete() const;
  inline void clear_is_delete();
  static const int kIsDeleteFieldNumber = 10;
  inline bool is_delete() const;
  inline void set_is_delete(bool value);

  // optional uint32 fixtop_priority = 11;
  inline bool has_fixtop_priority() const;
  inline void clear_fixtop_priority();
  static const int kFixtopPriorityFieldNumber = 11;
  inline ::google::protobuf::uint32 fixtop_priority() const;
  inline void set_fixtop_priority(::google::protobuf::uint32 value);

  // optional uint32 show = 12;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 12;
  inline ::google::protobuf::uint32 show() const;
  inline void set_show(::google::protobuf::uint32 value);

  // optional string topic = 13;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 13;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // optional bool not_disturb = 14;
  inline bool has_not_disturb() const;
  inline void clear_not_disturb();
  static const int kNotDisturbFieldNumber = 14;
  inline bool not_disturb() const;
  inline void set_not_disturb(bool value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_avatar();
  inline void clear_has_group_avatar();
  inline void set_has_group_creator_id();
  inline void clear_has_group_creator_id();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();
  inline void set_has_group_member_count();
  inline void clear_has_group_member_count();
  inline void set_has_is_delete();
  inline void clear_has_is_delete();
  inline void set_has_fixtop_priority();
  inline void clear_has_fixtop_priority();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_not_disturb();
  inline void clear_has_not_disturb();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint64 update_time_;
  ::std::string* group_name_;
  ::std::string* group_avatar_;
  ::google::protobuf::uint32 group_creator_id_;
  int group_type_;
  ::google::protobuf::uint32 shield_status_;
  ::google::protobuf::uint32 group_member_count_;
  ::google::protobuf::uint32 fixtop_priority_;
  ::google::protobuf::uint32 show_;
  ::std::string* topic_;
  bool is_delete_;
  bool not_disturb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenInfo : public ::google::protobuf::MessageLite {
 public:
  UserTokenInfo();
  virtual ~UserTokenInfo();

  UserTokenInfo(const UserTokenInfo& from);

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserTokenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserTokenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserTokenInfo* other);

  // implements Message ----------------------------------------------

  UserTokenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserTokenInfo& from);
  void MergeFrom(const UserTokenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.ClientType user_type = 3;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 3;
  inline ::IM::BaseDefine::ClientType user_type() const;
  inline void set_user_type(::IM::BaseDefine::ClientType value);

  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint32 push_count = 5;
  inline bool has_push_count() const;
  inline void clear_push_count();
  static const int kPushCountFieldNumber = 5;
  inline ::google::protobuf::uint32 push_count() const;
  inline void set_push_count(::google::protobuf::uint32 value);

  // required uint32 push_type = 6;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 push_type() const;
  inline void set_push_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserTokenInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_push_count();
  inline void clear_has_push_count();
  inline void set_has_push_type();
  inline void clear_has_push_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::std::string* token_;
  int user_type_;
  ::google::protobuf::uint32 push_count_;
  ::google::protobuf::uint32 push_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserTokenInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushResult : public ::google::protobuf::MessageLite {
 public:
  PushResult();
  virtual ~PushResult();

  PushResult(const PushResult& from);

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushResult* other);

  // implements Message ----------------------------------------------

  PushResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushResult& from);
  void MergeFrom(const PushResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_token = 1;
  inline bool has_user_token() const;
  inline void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  inline const ::std::string& user_token() const;
  inline void set_user_token(const ::std::string& value);
  inline void set_user_token(const char* value);
  inline void set_user_token(const char* value, size_t size);
  inline ::std::string* mutable_user_token();
  inline ::std::string* release_user_token();
  inline void set_allocated_user_token(::std::string* user_token);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushResult)
 private:
  inline void set_has_user_token();
  inline void clear_has_user_token();
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_token_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static PushResult* default_instance_;
};
// -------------------------------------------------------------------

class ShieldStatus : public ::google::protobuf::MessageLite {
 public:
  ShieldStatus();
  virtual ~ShieldStatus();

  ShieldStatus(const ShieldStatus& from);

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShieldStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShieldStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShieldStatus* other);

  // implements Message ----------------------------------------------

  ShieldStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShieldStatus& from);
  void MergeFrom(const ShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 4;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ShieldStatus)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class OfflineFileInfo : public ::google::protobuf::MessageLite {
 public:
  OfflineFileInfo();
  virtual ~OfflineFileInfo();

  OfflineFileInfo(const OfflineFileInfo& from);

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OfflineFileInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineFileInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineFileInfo* other);

  // implements Message ----------------------------------------------

  OfflineFileInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineFileInfo& from);
  void MergeFrom(const OfflineFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 2;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required string task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 4;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 5;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.OfflineFileInfo)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::std::string* task_id_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static OfflineFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushShieldStatus : public ::google::protobuf::MessageLite {
 public:
  PushShieldStatus();
  virtual ~PushShieldStatus();

  PushShieldStatus(const PushShieldStatus& from);

  inline PushShieldStatus& operator=(const PushShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushShieldStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushShieldStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushShieldStatus* other);

  // implements Message ----------------------------------------------

  PushShieldStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushShieldStatus& from);
  void MergeFrom(const PushShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 company_id = 1;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 3;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushShieldStatus)
 private:
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static PushShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class IMBuddyReqInfo : public ::google::protobuf::MessageLite {
 public:
  IMBuddyReqInfo();
  virtual ~IMBuddyReqInfo();

  IMBuddyReqInfo(const IMBuddyReqInfo& from);

  inline IMBuddyReqInfo& operator=(const IMBuddyReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMBuddyReqInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMBuddyReqInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMBuddyReqInfo* other);

  // implements Message ----------------------------------------------

  IMBuddyReqInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMBuddyReqInfo& from);
  void MergeFrom(const IMBuddyReqInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 company_id = 2;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 dest_user_id = 3;
  inline bool has_dest_user_id() const;
  inline void clear_dest_user_id();
  static const int kDestUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 dest_user_id() const;
  inline void set_dest_user_id(::google::protobuf::uint32 value);

  // required uint32 dest_company_id = 4;
  inline bool has_dest_company_id() const;
  inline void clear_dest_company_id();
  static const int kDestCompanyIdFieldNumber = 4;
  inline ::google::protobuf::uint32 dest_company_id() const;
  inline void set_dest_company_id(::google::protobuf::uint32 value);

  // required uint32 req_stat = 5;
  inline bool has_req_stat() const;
  inline void clear_req_stat();
  static const int kReqStatFieldNumber = 5;
  inline ::google::protobuf::uint32 req_stat() const;
  inline void set_req_stat(::google::protobuf::uint32 value);

  // required uint64 req_time = 6;
  inline bool has_req_time() const;
  inline void clear_req_time();
  static const int kReqTimeFieldNumber = 6;
  inline ::google::protobuf::uint64 req_time() const;
  inline void set_req_time(::google::protobuf::uint64 value);

  // required string remark = 7;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 7;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IMBuddyReqInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_dest_user_id();
  inline void clear_has_dest_user_id();
  inline void set_has_dest_company_id();
  inline void clear_has_dest_company_id();
  inline void set_has_req_stat();
  inline void clear_has_req_stat();
  inline void set_has_req_time();
  inline void clear_has_req_time();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 dest_user_id_;
  ::google::protobuf::uint32 dest_company_id_;
  ::google::protobuf::uint64 req_time_;
  ::std::string* remark_;
  ::google::protobuf::uint32 req_stat_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IMBuddyReqInfo* default_instance_;
};
// -------------------------------------------------------------------

class IMSinglePullNotify : public ::google::protobuf::MessageLite {
 public:
  IMSinglePullNotify();
  virtual ~IMSinglePullNotify();

  IMSinglePullNotify(const IMSinglePullNotify& from);

  inline IMSinglePullNotify& operator=(const IMSinglePullNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSinglePullNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSinglePullNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSinglePullNotify* other);

  // implements Message ----------------------------------------------

  IMSinglePullNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSinglePullNotify& from);
  void MergeFrom(const IMSinglePullNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IMSinglePullNotify)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IMSinglePullNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMGroupPullNotify : public ::google::protobuf::MessageLite {
 public:
  IMGroupPullNotify();
  virtual ~IMGroupPullNotify();

  IMGroupPullNotify(const IMGroupPullNotify& from);

  inline IMGroupPullNotify& operator=(const IMGroupPullNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGroupPullNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGroupPullNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGroupPullNotify* other);

  // implements Message ----------------------------------------------

  IMGroupPullNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGroupPullNotify& from);
  void MergeFrom(const IMGroupPullNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 company_id = 2;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 company_id() const;
  inline void set_company_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 3;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IMGroupPullNotify)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 company_id_;
  ::google::protobuf::uint32 group_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IMGroupPullNotify* default_instance_;
};
// -------------------------------------------------------------------

class IMUserAuthority : public ::google::protobuf::MessageLite {
 public:
  IMUserAuthority();
  virtual ~IMUserAuthority();

  IMUserAuthority(const IMUserAuthority& from);

  inline IMUserAuthority& operator=(const IMUserAuthority& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserAuthority& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserAuthority* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserAuthority* other);

  // implements Message ----------------------------------------------

  IMUserAuthority* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserAuthority& from);
  void MergeFrom(const IMUserAuthority& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 auth_id = 1;
  inline bool has_auth_id() const;
  inline void clear_auth_id();
  static const int kAuthIdFieldNumber = 1;
  inline ::google::protobuf::uint32 auth_id() const;
  inline void set_auth_id(::google::protobuf::uint32 value);

  // required string auth_value = 2;
  inline bool has_auth_value() const;
  inline void clear_auth_value();
  static const int kAuthValueFieldNumber = 2;
  inline const ::std::string& auth_value() const;
  inline void set_auth_value(const ::std::string& value);
  inline void set_auth_value(const char* value);
  inline void set_auth_value(const char* value, size_t size);
  inline ::std::string* mutable_auth_value();
  inline ::std::string* release_auth_value();
  inline void set_allocated_auth_value(::std::string* auth_value);

  // optional string ext_value1 = 3;
  inline bool has_ext_value1() const;
  inline void clear_ext_value1();
  static const int kExtValue1FieldNumber = 3;
  inline const ::std::string& ext_value1() const;
  inline void set_ext_value1(const ::std::string& value);
  inline void set_ext_value1(const char* value);
  inline void set_ext_value1(const char* value, size_t size);
  inline ::std::string* mutable_ext_value1();
  inline ::std::string* release_ext_value1();
  inline void set_allocated_ext_value1(::std::string* ext_value1);

  // optional string ext_value2 = 4;
  inline bool has_ext_value2() const;
  inline void clear_ext_value2();
  static const int kExtValue2FieldNumber = 4;
  inline const ::std::string& ext_value2() const;
  inline void set_ext_value2(const ::std::string& value);
  inline void set_ext_value2(const char* value);
  inline void set_ext_value2(const char* value, size_t size);
  inline ::std::string* mutable_ext_value2();
  inline ::std::string* release_ext_value2();
  inline void set_allocated_ext_value2(::std::string* ext_value2);

  // optional string ext_value3 = 5;
  inline bool has_ext_value3() const;
  inline void clear_ext_value3();
  static const int kExtValue3FieldNumber = 5;
  inline const ::std::string& ext_value3() const;
  inline void set_ext_value3(const ::std::string& value);
  inline void set_ext_value3(const char* value);
  inline void set_ext_value3(const char* value, size_t size);
  inline ::std::string* mutable_ext_value3();
  inline ::std::string* release_ext_value3();
  inline void set_allocated_ext_value3(::std::string* ext_value3);

  // optional string ext_value4 = 6;
  inline bool has_ext_value4() const;
  inline void clear_ext_value4();
  static const int kExtValue4FieldNumber = 6;
  inline const ::std::string& ext_value4() const;
  inline void set_ext_value4(const ::std::string& value);
  inline void set_ext_value4(const char* value);
  inline void set_ext_value4(const char* value, size_t size);
  inline ::std::string* mutable_ext_value4();
  inline ::std::string* release_ext_value4();
  inline void set_allocated_ext_value4(::std::string* ext_value4);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IMUserAuthority)
 private:
  inline void set_has_auth_id();
  inline void clear_has_auth_id();
  inline void set_has_auth_value();
  inline void clear_has_auth_value();
  inline void set_has_ext_value1();
  inline void clear_has_ext_value1();
  inline void set_has_ext_value2();
  inline void clear_has_ext_value2();
  inline void set_has_ext_value3();
  inline void clear_has_ext_value3();
  inline void set_has_ext_value4();
  inline void clear_has_ext_value4();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* auth_value_;
  ::std::string* ext_value1_;
  ::std::string* ext_value2_;
  ::std::string* ext_value3_;
  ::std::string* ext_value4_;
  ::google::protobuf::uint32 auth_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IMUserAuthority* default_instance_;
};
// -------------------------------------------------------------------

class IMUserRole : public ::google::protobuf::MessageLite {
 public:
  IMUserRole();
  virtual ~IMUserRole();

  IMUserRole(const IMUserRole& from);

  inline IMUserRole& operator=(const IMUserRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMUserRole& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMUserRole* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMUserRole* other);

  // implements Message ----------------------------------------------

  IMUserRole* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMUserRole& from);
  void MergeFrom(const IMUserRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // required string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // repeated .IM.BaseDefine.IMUserAuthority authority = 3;
  inline int authority_size() const;
  inline void clear_authority();
  static const int kAuthorityFieldNumber = 3;
  inline const ::IM::BaseDefine::IMUserAuthority& authority(int index) const;
  inline ::IM::BaseDefine::IMUserAuthority* mutable_authority(int index);
  inline ::IM::BaseDefine::IMUserAuthority* add_authority();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IMUserAuthority >&
      authority() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IMUserAuthority >*
      mutable_authority();

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IMUserRole)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* role_name_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IMUserAuthority > authority_;
  ::google::protobuf::uint32 role_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IMUserRole* default_instance_;
};
// ===================================================================


// ===================================================================

// IpAddr

// required string ip = 1;
inline bool IpAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IpAddr::ip() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.ip)
  return *ip_;
}
inline void IpAddr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IpAddr.ip)
}
inline ::std::string* IpAddr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IpAddr.ip)
  return ip_;
}
inline ::std::string* IpAddr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpAddr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IpAddr.ip)
}

// required uint32 port = 2;
inline bool IpAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddr::port() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.port)
  return port_;
}
inline void IpAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// required uint32 company_id = 1;
inline bool UserInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 UserInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.company_id)
  return company_id_;
}
inline void UserInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.company_id)
}

// required uint32 user_id = 2;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_id)
  return user_id_;
}
inline void UserInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_id)
}

// required uint32 user_gender = 3;
inline bool UserInfo::has_user_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_user_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 UserInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_gender)
  return user_gender_;
}
inline void UserInfo::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_gender)
}

// required string user_nick_name = 4;
inline bool UserInfo::has_user_nick_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_user_nick_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_user_nick_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_user_nick_name() {
  if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_->clear();
  }
  clear_has_user_nick_name();
}
inline const ::std::string& UserInfo::user_nick_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_nick_name)
  return *user_nick_name_;
}
inline void UserInfo::set_user_nick_name(const ::std::string& value) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_nick_name)
}
inline void UserInfo::set_user_nick_name(const char* value) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_nick_name)
}
inline void UserInfo::set_user_nick_name(const char* value, size_t size) {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  user_nick_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_nick_name)
}
inline ::std::string* UserInfo::mutable_user_nick_name() {
  set_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nick_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_nick_name)
  return user_nick_name_;
}
inline ::std::string* UserInfo::release_user_nick_name() {
  clear_has_user_nick_name();
  if (user_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_nick_name_;
    user_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_nick_name(::std::string* user_nick_name) {
  if (user_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nick_name_;
  }
  if (user_nick_name) {
    set_has_user_nick_name();
    user_nick_name_ = user_nick_name;
  } else {
    clear_has_user_nick_name();
    user_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_nick_name)
}

// required string avatar_url = 5;
inline bool UserInfo::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& UserInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.avatar_url)
  return *avatar_url_;
}
inline void UserInfo::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.avatar_url)
}
inline void UserInfo::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.avatar_url)
}
inline void UserInfo::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.avatar_url)
}
inline ::std::string* UserInfo::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.avatar_url)
  return avatar_url_;
}
inline ::std::string* UserInfo::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.avatar_url)
}

// required uint64 avatar_update_time = 6;
inline bool UserInfo::has_avatar_update_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_avatar_update_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_avatar_update_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_avatar_update_time() {
  avatar_update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_avatar_update_time();
}
inline ::google::protobuf::uint64 UserInfo::avatar_update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.avatar_update_time)
  return avatar_update_time_;
}
inline void UserInfo::set_avatar_update_time(::google::protobuf::uint64 value) {
  set_has_avatar_update_time();
  avatar_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.avatar_update_time)
}

// required string email = 7;
inline bool UserInfo::has_email() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_email() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserInfo::email() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.email)
  return *email_;
}
inline void UserInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.email)
}
inline void UserInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.email)
}
inline void UserInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.email)
}
inline ::std::string* UserInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.email)
  return email_;
}
inline ::std::string* UserInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.email)
}

// required string user_real_name = 8;
inline bool UserInfo::has_user_real_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_user_real_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_user_real_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_user_real_name() {
  if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_->clear();
  }
  clear_has_user_real_name();
}
inline const ::std::string& UserInfo::user_real_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_real_name)
  return *user_real_name_;
}
inline void UserInfo::set_user_real_name(const ::std::string& value) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_real_name)
}
inline void UserInfo::set_user_real_name(const char* value) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_real_name)
}
inline void UserInfo::set_user_real_name(const char* value, size_t size) {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  user_real_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_real_name)
}
inline ::std::string* UserInfo::mutable_user_real_name() {
  set_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_real_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_real_name)
  return user_real_name_;
}
inline ::std::string* UserInfo::release_user_real_name() {
  clear_has_user_real_name();
  if (user_real_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_real_name_;
    user_real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_real_name(::std::string* user_real_name) {
  if (user_real_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_real_name_;
  }
  if (user_real_name) {
    set_has_user_real_name();
    user_real_name_ = user_real_name;
  } else {
    clear_has_user_real_name();
    user_real_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_real_name)
}

// required string user_mobile = 9;
inline bool UserInfo::has_user_mobile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_user_mobile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_user_mobile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_user_mobile() {
  if (user_mobile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_mobile_->clear();
  }
  clear_has_user_mobile();
}
inline const ::std::string& UserInfo::user_mobile() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_mobile)
  return *user_mobile_;
}
inline void UserInfo::set_user_mobile(const ::std::string& value) {
  set_has_user_mobile();
  if (user_mobile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_mobile_ = new ::std::string;
  }
  user_mobile_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_mobile)
}
inline void UserInfo::set_user_mobile(const char* value) {
  set_has_user_mobile();
  if (user_mobile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_mobile_ = new ::std::string;
  }
  user_mobile_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_mobile)
}
inline void UserInfo::set_user_mobile(const char* value, size_t size) {
  set_has_user_mobile();
  if (user_mobile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_mobile_ = new ::std::string;
  }
  user_mobile_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_mobile)
}
inline ::std::string* UserInfo::mutable_user_mobile() {
  set_has_user_mobile();
  if (user_mobile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_mobile_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_mobile)
  return user_mobile_;
}
inline ::std::string* UserInfo::release_user_mobile() {
  clear_has_user_mobile();
  if (user_mobile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_mobile_;
    user_mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_mobile(::std::string* user_mobile) {
  if (user_mobile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_mobile_;
  }
  if (user_mobile) {
    set_has_user_mobile();
    user_mobile_ = user_mobile;
  } else {
    clear_has_user_mobile();
    user_mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_mobile)
}

// required string user_tel = 10;
inline bool UserInfo::has_user_tel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_user_tel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_user_tel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_user_tel() {
  if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_->clear();
  }
  clear_has_user_tel();
}
inline const ::std::string& UserInfo::user_tel() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_tel)
  return *user_tel_;
}
inline void UserInfo::set_user_tel(const ::std::string& value) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_tel)
}
inline void UserInfo::set_user_tel(const char* value) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_tel)
}
inline void UserInfo::set_user_tel(const char* value, size_t size) {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  user_tel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_tel)
}
inline ::std::string* UserInfo::mutable_user_tel() {
  set_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_tel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_tel)
  return user_tel_;
}
inline ::std::string* UserInfo::release_user_tel() {
  clear_has_user_tel();
  if (user_tel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_tel_;
    user_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_tel(::std::string* user_tel) {
  if (user_tel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_tel_;
  }
  if (user_tel) {
    set_has_user_tel();
    user_tel_ = user_tel;
  } else {
    clear_has_user_tel();
    user_tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_tel)
}

// required string user_english_name = 11;
inline bool UserInfo::has_user_english_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_user_english_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_user_english_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_user_english_name() {
  if (user_english_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_english_name_->clear();
  }
  clear_has_user_english_name();
}
inline const ::std::string& UserInfo::user_english_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_english_name)
  return *user_english_name_;
}
inline void UserInfo::set_user_english_name(const ::std::string& value) {
  set_has_user_english_name();
  if (user_english_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_english_name_ = new ::std::string;
  }
  user_english_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_english_name)
}
inline void UserInfo::set_user_english_name(const char* value) {
  set_has_user_english_name();
  if (user_english_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_english_name_ = new ::std::string;
  }
  user_english_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_english_name)
}
inline void UserInfo::set_user_english_name(const char* value, size_t size) {
  set_has_user_english_name();
  if (user_english_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_english_name_ = new ::std::string;
  }
  user_english_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_english_name)
}
inline ::std::string* UserInfo::mutable_user_english_name() {
  set_has_user_english_name();
  if (user_english_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_english_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_english_name)
  return user_english_name_;
}
inline ::std::string* UserInfo::release_user_english_name() {
  clear_has_user_english_name();
  if (user_english_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_english_name_;
    user_english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_english_name(::std::string* user_english_name) {
  if (user_english_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_english_name_;
  }
  if (user_english_name) {
    set_has_user_english_name();
    user_english_name_ = user_english_name;
  } else {
    clear_has_user_english_name();
    user_english_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_english_name)
}

// required uint32 status = 12;
inline bool UserInfo::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 UserInfo::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.status)
  return status_;
}
inline void UserInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.status)
}

// required uint32 user_borndate = 13;
inline bool UserInfo::has_user_borndate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_user_borndate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfo::clear_has_user_borndate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfo::clear_user_borndate() {
  user_borndate_ = 0u;
  clear_has_user_borndate();
}
inline ::google::protobuf::uint32 UserInfo::user_borndate() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_borndate)
  return user_borndate_;
}
inline void UserInfo::set_user_borndate(::google::protobuf::uint32 value) {
  set_has_user_borndate();
  user_borndate_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_borndate)
}

// required uint64 update_time = 14;
inline bool UserInfo::has_update_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_update_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfo::clear_has_update_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfo::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 UserInfo::update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.update_time)
  return update_time_;
}
inline void UserInfo::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.update_time)
}

// required uint32 work_id = 15;
inline bool UserInfo::has_work_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_work_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfo::clear_has_work_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfo::clear_work_id() {
  work_id_ = 0u;
  clear_has_work_id();
}
inline ::google::protobuf::uint32 UserInfo::work_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.work_id)
  return work_id_;
}
inline void UserInfo::set_work_id(::google::protobuf::uint32 value) {
  set_has_work_id();
  work_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.work_id)
}

// required string pos_json = 16;
inline bool UserInfo::has_pos_json() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserInfo::set_has_pos_json() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserInfo::clear_has_pos_json() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserInfo::clear_pos_json() {
  if (pos_json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pos_json_->clear();
  }
  clear_has_pos_json();
}
inline const ::std::string& UserInfo::pos_json() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.pos_json)
  return *pos_json_;
}
inline void UserInfo::set_pos_json(const ::std::string& value) {
  set_has_pos_json();
  if (pos_json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pos_json_ = new ::std::string;
  }
  pos_json_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.pos_json)
}
inline void UserInfo::set_pos_json(const char* value) {
  set_has_pos_json();
  if (pos_json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pos_json_ = new ::std::string;
  }
  pos_json_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.pos_json)
}
inline void UserInfo::set_pos_json(const char* value, size_t size) {
  set_has_pos_json();
  if (pos_json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pos_json_ = new ::std::string;
  }
  pos_json_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.pos_json)
}
inline ::std::string* UserInfo::mutable_pos_json() {
  set_has_pos_json();
  if (pos_json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pos_json_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.pos_json)
  return pos_json_;
}
inline ::std::string* UserInfo::release_pos_json() {
  clear_has_pos_json();
  if (pos_json_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pos_json_;
    pos_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_pos_json(::std::string* pos_json) {
  if (pos_json_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pos_json_;
  }
  if (pos_json) {
    set_has_pos_json();
    pos_json_ = pos_json;
  } else {
    clear_has_pos_json();
    pos_json_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.pos_json)
}

// optional string sign_info = 17;
inline bool UserInfo::has_sign_info() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserInfo::set_has_sign_info() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserInfo::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserInfo::clear_sign_info() {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_->clear();
  }
  clear_has_sign_info();
}
inline const ::std::string& UserInfo::sign_info() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.sign_info)
  return *sign_info_;
}
inline void UserInfo::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.sign_info)
}
inline void UserInfo::set_sign_info(const char* value) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.sign_info)
}
inline void UserInfo::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  sign_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.sign_info)
}
inline ::std::string* UserInfo::mutable_sign_info() {
  set_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.sign_info)
  return sign_info_;
}
inline ::std::string* UserInfo::release_sign_info() {
  clear_has_sign_info();
  if (sign_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_info_;
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_info_;
  }
  if (sign_info) {
    set_has_sign_info();
    sign_info_ = sign_info;
  } else {
    clear_has_sign_info();
    sign_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.sign_info)
}

// -------------------------------------------------------------------

// RecentContactInfo

// required uint32 company_id = 1;
inline bool RecentContactInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecentContactInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecentContactInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecentContactInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 RecentContactInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.company_id)
  return company_id_;
}
inline void RecentContactInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.company_id)
}

// required uint32 contact_id = 2;
inline bool RecentContactInfo::has_contact_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecentContactInfo::set_has_contact_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecentContactInfo::clear_has_contact_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecentContactInfo::clear_contact_id() {
  contact_id_ = 0u;
  clear_has_contact_id();
}
inline ::google::protobuf::uint32 RecentContactInfo::contact_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.contact_id)
  return contact_id_;
}
inline void RecentContactInfo::set_contact_id(::google::protobuf::uint32 value) {
  set_has_contact_id();
  contact_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.contact_id)
}

// required .IM.BaseDefine.SessionType session_type = 3;
inline bool RecentContactInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecentContactInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecentContactInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecentContactInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType RecentContactInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void RecentContactInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.session_type)
}

// required uint64 contact_info_update_time = 4;
inline bool RecentContactInfo::has_contact_info_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecentContactInfo::set_has_contact_info_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecentContactInfo::clear_has_contact_info_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecentContactInfo::clear_contact_info_update_time() {
  contact_info_update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_contact_info_update_time();
}
inline ::google::protobuf::uint64 RecentContactInfo::contact_info_update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.contact_info_update_time)
  return contact_info_update_time_;
}
inline void RecentContactInfo::set_contact_info_update_time(::google::protobuf::uint64 value) {
  set_has_contact_info_update_time();
  contact_info_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.contact_info_update_time)
}

// required string contact_name = 5;
inline bool RecentContactInfo::has_contact_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecentContactInfo::set_has_contact_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecentContactInfo::clear_has_contact_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecentContactInfo::clear_contact_name() {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_->clear();
  }
  clear_has_contact_name();
}
inline const ::std::string& RecentContactInfo::contact_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.contact_name)
  return *contact_name_;
}
inline void RecentContactInfo::set_contact_name(const ::std::string& value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.contact_name)
}
inline void RecentContactInfo::set_contact_name(const char* value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.RecentContactInfo.contact_name)
}
inline void RecentContactInfo::set_contact_name(const char* value, size_t size) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.RecentContactInfo.contact_name)
}
inline ::std::string* RecentContactInfo::mutable_contact_name() {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.RecentContactInfo.contact_name)
  return contact_name_;
}
inline ::std::string* RecentContactInfo::release_contact_name() {
  clear_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_name_;
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecentContactInfo::set_allocated_contact_name(::std::string* contact_name) {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_name_;
  }
  if (contact_name) {
    set_has_contact_name();
    contact_name_ = contact_name;
  } else {
    clear_has_contact_name();
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.RecentContactInfo.contact_name)
}

// required string contact_remark = 6;
inline bool RecentContactInfo::has_contact_remark() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecentContactInfo::set_has_contact_remark() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecentContactInfo::clear_has_contact_remark() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecentContactInfo::clear_contact_remark() {
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_->clear();
  }
  clear_has_contact_remark();
}
inline const ::std::string& RecentContactInfo::contact_remark() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.contact_remark)
  return *contact_remark_;
}
inline void RecentContactInfo::set_contact_remark(const ::std::string& value) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.contact_remark)
}
inline void RecentContactInfo::set_contact_remark(const char* value) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.RecentContactInfo.contact_remark)
}
inline void RecentContactInfo::set_contact_remark(const char* value, size_t size) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.RecentContactInfo.contact_remark)
}
inline ::std::string* RecentContactInfo::mutable_contact_remark() {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.RecentContactInfo.contact_remark)
  return contact_remark_;
}
inline ::std::string* RecentContactInfo::release_contact_remark() {
  clear_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_remark_;
    contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecentContactInfo::set_allocated_contact_remark(::std::string* contact_remark) {
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_remark_;
  }
  if (contact_remark) {
    set_has_contact_remark();
    contact_remark_ = contact_remark;
  } else {
    clear_has_contact_remark();
    contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.RecentContactInfo.contact_remark)
}

// required uint32 user_gender = 7;
inline bool RecentContactInfo::has_user_gender() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecentContactInfo::set_has_user_gender() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecentContactInfo::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecentContactInfo::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 RecentContactInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.user_gender)
  return user_gender_;
}
inline void RecentContactInfo::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.user_gender)
}

// required bool is_fixtop = 8;
inline bool RecentContactInfo::has_is_fixtop() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecentContactInfo::set_has_is_fixtop() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecentContactInfo::clear_has_is_fixtop() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecentContactInfo::clear_is_fixtop() {
  is_fixtop_ = false;
  clear_has_is_fixtop();
}
inline bool RecentContactInfo::is_fixtop() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.is_fixtop)
  return is_fixtop_;
}
inline void RecentContactInfo::set_is_fixtop(bool value) {
  set_has_is_fixtop();
  is_fixtop_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.is_fixtop)
}

// required uint32 top_order = 9;
inline bool RecentContactInfo::has_top_order() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RecentContactInfo::set_has_top_order() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RecentContactInfo::clear_has_top_order() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RecentContactInfo::clear_top_order() {
  top_order_ = 0u;
  clear_has_top_order();
}
inline ::google::protobuf::uint32 RecentContactInfo::top_order() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentContactInfo.top_order)
  return top_order_;
}
inline void RecentContactInfo::set_top_order(::google::protobuf::uint32 value) {
  set_has_top_order();
  top_order_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentContactInfo.top_order)
}

// -------------------------------------------------------------------

// RecentFixTop

// required uint32 company_id = 1;
inline bool RecentFixTop::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecentFixTop::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecentFixTop::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecentFixTop::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 RecentFixTop::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.company_id)
  return company_id_;
}
inline void RecentFixTop::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.company_id)
}

// required uint32 user_id = 2;
inline bool RecentFixTop::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecentFixTop::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecentFixTop::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecentFixTop::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 RecentFixTop::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.user_id)
  return user_id_;
}
inline void RecentFixTop::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.user_id)
}

// required uint64 update_time = 3;
inline bool RecentFixTop::has_update_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecentFixTop::set_has_update_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecentFixTop::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecentFixTop::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 RecentFixTop::update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.update_time)
  return update_time_;
}
inline void RecentFixTop::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.update_time)
}

// required string contact_remark = 4;
inline bool RecentFixTop::has_contact_remark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecentFixTop::set_has_contact_remark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecentFixTop::clear_has_contact_remark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecentFixTop::clear_contact_remark() {
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_->clear();
  }
  clear_has_contact_remark();
}
inline const ::std::string& RecentFixTop::contact_remark() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.contact_remark)
  return *contact_remark_;
}
inline void RecentFixTop::set_contact_remark(const ::std::string& value) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.contact_remark)
}
inline void RecentFixTop::set_contact_remark(const char* value) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.RecentFixTop.contact_remark)
}
inline void RecentFixTop::set_contact_remark(const char* value, size_t size) {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  contact_remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.RecentFixTop.contact_remark)
}
inline ::std::string* RecentFixTop::mutable_contact_remark() {
  set_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.RecentFixTop.contact_remark)
  return contact_remark_;
}
inline ::std::string* RecentFixTop::release_contact_remark() {
  clear_has_contact_remark();
  if (contact_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_remark_;
    contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecentFixTop::set_allocated_contact_remark(::std::string* contact_remark) {
  if (contact_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_remark_;
  }
  if (contact_remark) {
    set_has_contact_remark();
    contact_remark_ = contact_remark;
  } else {
    clear_has_contact_remark();
    contact_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.RecentFixTop.contact_remark)
}

// required uint32 user_gender = 5;
inline bool RecentFixTop::has_user_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecentFixTop::set_has_user_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecentFixTop::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecentFixTop::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 RecentFixTop::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.user_gender)
  return user_gender_;
}
inline void RecentFixTop::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.user_gender)
}

// required uint32 top_order = 6;
inline bool RecentFixTop::has_top_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecentFixTop::set_has_top_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecentFixTop::clear_has_top_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecentFixTop::clear_top_order() {
  top_order_ = 0u;
  clear_has_top_order();
}
inline ::google::protobuf::uint32 RecentFixTop::top_order() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.RecentFixTop.top_order)
  return top_order_;
}
inline void RecentFixTop::set_top_order(::google::protobuf::uint32 value) {
  set_has_top_order();
  top_order_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.RecentFixTop.top_order)
}

// -------------------------------------------------------------------

// FrequentContactInfo

// required uint32 company_id = 1;
inline bool FrequentContactInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrequentContactInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrequentContactInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrequentContactInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 FrequentContactInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.company_id)
  return company_id_;
}
inline void FrequentContactInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.company_id)
}

// required uint32 contact_id = 2;
inline bool FrequentContactInfo::has_contact_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrequentContactInfo::set_has_contact_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrequentContactInfo::clear_has_contact_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrequentContactInfo::clear_contact_id() {
  contact_id_ = 0u;
  clear_has_contact_id();
}
inline ::google::protobuf::uint32 FrequentContactInfo::contact_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.contact_id)
  return contact_id_;
}
inline void FrequentContactInfo::set_contact_id(::google::protobuf::uint32 value) {
  set_has_contact_id();
  contact_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.contact_id)
}

// required string contact_name = 3;
inline bool FrequentContactInfo::has_contact_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrequentContactInfo::set_has_contact_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrequentContactInfo::clear_has_contact_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrequentContactInfo::clear_contact_name() {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_->clear();
  }
  clear_has_contact_name();
}
inline const ::std::string& FrequentContactInfo::contact_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.contact_name)
  return *contact_name_;
}
inline void FrequentContactInfo::set_contact_name(const ::std::string& value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.contact_name)
}
inline void FrequentContactInfo::set_contact_name(const char* value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.FrequentContactInfo.contact_name)
}
inline void FrequentContactInfo::set_contact_name(const char* value, size_t size) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.FrequentContactInfo.contact_name)
}
inline ::std::string* FrequentContactInfo::mutable_contact_name() {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.FrequentContactInfo.contact_name)
  return contact_name_;
}
inline ::std::string* FrequentContactInfo::release_contact_name() {
  clear_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_name_;
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrequentContactInfo::set_allocated_contact_name(::std::string* contact_name) {
  if (contact_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_name_;
  }
  if (contact_name) {
    set_has_contact_name();
    contact_name_ = contact_name;
  } else {
    clear_has_contact_name();
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.FrequentContactInfo.contact_name)
}

// required string contact_nick_name = 4;
inline bool FrequentContactInfo::has_contact_nick_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrequentContactInfo::set_has_contact_nick_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrequentContactInfo::clear_has_contact_nick_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrequentContactInfo::clear_contact_nick_name() {
  if (contact_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_nick_name_->clear();
  }
  clear_has_contact_nick_name();
}
inline const ::std::string& FrequentContactInfo::contact_nick_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
  return *contact_nick_name_;
}
inline void FrequentContactInfo::set_contact_nick_name(const ::std::string& value) {
  set_has_contact_nick_name();
  if (contact_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_nick_name_ = new ::std::string;
  }
  contact_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
}
inline void FrequentContactInfo::set_contact_nick_name(const char* value) {
  set_has_contact_nick_name();
  if (contact_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_nick_name_ = new ::std::string;
  }
  contact_nick_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
}
inline void FrequentContactInfo::set_contact_nick_name(const char* value, size_t size) {
  set_has_contact_nick_name();
  if (contact_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_nick_name_ = new ::std::string;
  }
  contact_nick_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
}
inline ::std::string* FrequentContactInfo::mutable_contact_nick_name() {
  set_has_contact_nick_name();
  if (contact_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    contact_nick_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
  return contact_nick_name_;
}
inline ::std::string* FrequentContactInfo::release_contact_nick_name() {
  clear_has_contact_nick_name();
  if (contact_nick_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = contact_nick_name_;
    contact_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrequentContactInfo::set_allocated_contact_nick_name(::std::string* contact_nick_name) {
  if (contact_nick_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete contact_nick_name_;
  }
  if (contact_nick_name) {
    set_has_contact_nick_name();
    contact_nick_name_ = contact_nick_name;
  } else {
    clear_has_contact_nick_name();
    contact_nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.FrequentContactInfo.contact_nick_name)
}

// required string avatar_url = 5;
inline bool FrequentContactInfo::has_avatar_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrequentContactInfo::set_has_avatar_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrequentContactInfo::clear_has_avatar_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrequentContactInfo::clear_avatar_url() {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_->clear();
  }
  clear_has_avatar_url();
}
inline const ::std::string& FrequentContactInfo::avatar_url() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.avatar_url)
  return *avatar_url_;
}
inline void FrequentContactInfo::set_avatar_url(const ::std::string& value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.avatar_url)
}
inline void FrequentContactInfo::set_avatar_url(const char* value) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.FrequentContactInfo.avatar_url)
}
inline void FrequentContactInfo::set_avatar_url(const char* value, size_t size) {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  avatar_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.FrequentContactInfo.avatar_url)
}
inline ::std::string* FrequentContactInfo::mutable_avatar_url() {
  set_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.FrequentContactInfo.avatar_url)
  return avatar_url_;
}
inline ::std::string* FrequentContactInfo::release_avatar_url() {
  clear_has_avatar_url();
  if (avatar_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_url_;
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FrequentContactInfo::set_allocated_avatar_url(::std::string* avatar_url) {
  if (avatar_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_url_;
  }
  if (avatar_url) {
    set_has_avatar_url();
    avatar_url_ = avatar_url;
  } else {
    clear_has_avatar_url();
    avatar_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.FrequentContactInfo.avatar_url)
}

// required uint32 user_gender = 6;
inline bool FrequentContactInfo::has_user_gender() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FrequentContactInfo::set_has_user_gender() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FrequentContactInfo::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FrequentContactInfo::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 FrequentContactInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.user_gender)
  return user_gender_;
}
inline void FrequentContactInfo::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.user_gender)
}

// required uint64 last_update_time = 7;
inline bool FrequentContactInfo::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FrequentContactInfo::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FrequentContactInfo::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FrequentContactInfo::clear_last_update_time() {
  last_update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_update_time();
}
inline ::google::protobuf::uint64 FrequentContactInfo::last_update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.last_update_time)
  return last_update_time_;
}
inline void FrequentContactInfo::set_last_update_time(::google::protobuf::uint64 value) {
  set_has_last_update_time();
  last_update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.last_update_time)
}

// required bool is_delete = 8;
inline bool FrequentContactInfo::has_is_delete() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FrequentContactInfo::set_has_is_delete() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FrequentContactInfo::clear_has_is_delete() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FrequentContactInfo::clear_is_delete() {
  is_delete_ = false;
  clear_has_is_delete();
}
inline bool FrequentContactInfo::is_delete() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.FrequentContactInfo.is_delete)
  return is_delete_;
}
inline void FrequentContactInfo::set_is_delete(bool value) {
  set_has_is_delete();
  is_delete_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.FrequentContactInfo.is_delete)
}

// -------------------------------------------------------------------

// UserStat

// required uint32 company_id = 1;
inline bool UserStat::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStat::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStat::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStat::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 UserStat::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.company_id)
  return company_id_;
}
inline void UserStat::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.company_id)
}

// required uint32 user_id = 2;
inline bool UserStat::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStat::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStat::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.user_id)
  return user_id_;
}
inline void UserStat::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.user_id)
}

// required .IM.BaseDefine.UserStatType status = 3;
inline bool UserStat::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStat::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStat::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::IM::BaseDefine::UserStatType UserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.status)
  return static_cast< ::IM::BaseDefine::UserStatType >(status_);
}
inline void UserStat::set_status(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.status)
}

// optional string custom_status = 20;
inline bool UserStat::has_custom_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStat::set_has_custom_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStat::clear_has_custom_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStat::clear_custom_status() {
  if (custom_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_status_->clear();
  }
  clear_has_custom_status();
}
inline const ::std::string& UserStat::custom_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.custom_status)
  return *custom_status_;
}
inline void UserStat::set_custom_status(const ::std::string& value) {
  set_has_custom_status();
  if (custom_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_status_ = new ::std::string;
  }
  custom_status_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.custom_status)
}
inline void UserStat::set_custom_status(const char* value) {
  set_has_custom_status();
  if (custom_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_status_ = new ::std::string;
  }
  custom_status_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserStat.custom_status)
}
inline void UserStat::set_custom_status(const char* value, size_t size) {
  set_has_custom_status();
  if (custom_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_status_ = new ::std::string;
  }
  custom_status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserStat.custom_status)
}
inline ::std::string* UserStat::mutable_custom_status() {
  set_has_custom_status();
  if (custom_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserStat.custom_status)
  return custom_status_;
}
inline ::std::string* UserStat::release_custom_status() {
  clear_has_custom_status();
  if (custom_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = custom_status_;
    custom_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserStat::set_allocated_custom_status(::std::string* custom_status) {
  if (custom_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete custom_status_;
  }
  if (custom_status) {
    set_has_custom_status();
    custom_status_ = custom_status;
  } else {
    clear_has_custom_status();
    custom_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserStat.custom_status)
}

// -------------------------------------------------------------------

// UserIdItem

// required uint32 company_id = 1;
inline bool UserIdItem::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserIdItem::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserIdItem::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserIdItem::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 UserIdItem::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserIdItem.company_id)
  return company_id_;
}
inline void UserIdItem::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserIdItem.company_id)
}

// required uint32 user_id = 2;
inline bool UserIdItem::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserIdItem::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserIdItem::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserIdItem::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserIdItem::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserIdItem.user_id)
  return user_id_;
}
inline void UserIdItem::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserIdItem.user_id)
}

// -------------------------------------------------------------------

// ServerUserStat

// required uint32 company_id = 1;
inline bool ServerUserStat::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUserStat::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUserStat::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUserStat::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 ServerUserStat::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.company_id)
  return company_id_;
}
inline void ServerUserStat::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.company_id)
}

// required uint32 user_id = 2;
inline bool ServerUserStat::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerUserStat::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerUserStat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerUserStat::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerUserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.user_id)
  return user_id_;
}
inline void ServerUserStat::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.user_id)
}

// required .IM.BaseDefine.UserStatType status = 3;
inline bool ServerUserStat::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerUserStat::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerUserStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerUserStat::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::IM::BaseDefine::UserStatType ServerUserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.status)
  return static_cast< ::IM::BaseDefine::UserStatType >(status_);
}
inline void ServerUserStat::set_status(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.status)
}

// required .IM.BaseDefine.ClientType client_type = 4;
inline bool ServerUserStat::has_client_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerUserStat::set_has_client_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerUserStat::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerUserStat::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::IM::BaseDefine::ClientType ServerUserStat::client_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ServerUserStat.client_type)
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
inline void ServerUserStat::set_client_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ServerUserStat.client_type)
}

// -------------------------------------------------------------------

// MsgFont

// required string font_name = 1;
inline bool MsgFont::has_font_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgFont::set_has_font_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgFont::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgFont::clear_font_name() {
  if (font_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_name_->clear();
  }
  clear_has_font_name();
}
inline const ::std::string& MsgFont::font_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgFont.font_name)
  return *font_name_;
}
inline void MsgFont::set_font_name(const ::std::string& value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgFont.font_name)
}
inline void MsgFont::set_font_name(const char* value) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.MsgFont.font_name)
}
inline void MsgFont::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.MsgFont.font_name)
}
inline ::std::string* MsgFont::mutable_font_name() {
  set_has_font_name();
  if (font_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgFont.font_name)
  return font_name_;
}
inline ::std::string* MsgFont::release_font_name() {
  clear_has_font_name();
  if (font_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = font_name_;
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgFont::set_allocated_font_name(::std::string* font_name) {
  if (font_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete font_name_;
  }
  if (font_name) {
    set_has_font_name();
    font_name_ = font_name;
  } else {
    clear_has_font_name();
    font_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgFont.font_name)
}

// required uint32 font_size = 2;
inline bool MsgFont::has_font_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgFont::set_has_font_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgFont::clear_has_font_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgFont::clear_font_size() {
  font_size_ = 0u;
  clear_has_font_size();
}
inline ::google::protobuf::uint32 MsgFont::font_size() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgFont.font_size)
  return font_size_;
}
inline void MsgFont::set_font_size(::google::protobuf::uint32 value) {
  set_has_font_size();
  font_size_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgFont.font_size)
}

// required uint32 font_color = 3;
inline bool MsgFont::has_font_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgFont::set_has_font_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgFont::clear_has_font_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgFont::clear_font_color() {
  font_color_ = 0u;
  clear_has_font_color();
}
inline ::google::protobuf::uint32 MsgFont::font_color() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgFont.font_color)
  return font_color_;
}
inline void MsgFont::set_font_color(::google::protobuf::uint32 value) {
  set_has_font_color();
  font_color_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgFont.font_color)
}

// required uint32 font_style = 4;
inline bool MsgFont::has_font_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgFont::set_has_font_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgFont::clear_has_font_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgFont::clear_font_style() {
  font_style_ = 0u;
  clear_has_font_style();
}
inline ::google::protobuf::uint32 MsgFont::font_style() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgFont.font_style)
  return font_style_;
}
inline void MsgFont::set_font_style(::google::protobuf::uint32 value) {
  set_has_font_style();
  font_style_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgFont.font_style)
}

// -------------------------------------------------------------------

// MsgItem

// required .IM.BaseDefine.MsgType msg_type = 1;
inline bool MsgItem::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgItem::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgItem::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgItem::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::IM::BaseDefine::MsgType MsgItem::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgItem.msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(msg_type_);
}
inline void MsgItem::set_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgItem.msg_type)
}

// required string msg_data = 2;
inline bool MsgItem::has_msg_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgItem::set_has_msg_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgItem::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgItem::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& MsgItem::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgItem.msg_data)
  return *msg_data_;
}
inline void MsgItem::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgItem.msg_data)
}
inline void MsgItem::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.MsgItem.msg_data)
}
inline void MsgItem::set_msg_data(const char* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.MsgItem.msg_data)
}
inline ::std::string* MsgItem::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgItem.msg_data)
  return msg_data_;
}
inline ::std::string* MsgItem::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgItem::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgItem.msg_data)
}

// -------------------------------------------------------------------

// MsgData

// required string msg_id = 1;
inline bool MsgData::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgData::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgData::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgData::clear_msg_id() {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_id_->clear();
  }
  clear_has_msg_id();
}
inline const ::std::string& MsgData::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.msg_id)
  return *msg_id_;
}
inline void MsgData::set_msg_id(const ::std::string& value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.msg_id)
}
inline void MsgData::set_msg_id(const char* value) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.MsgData.msg_id)
}
inline void MsgData::set_msg_id(const char* value, size_t size) {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_id_ = new ::std::string;
  }
  msg_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.MsgData.msg_id)
}
inline ::std::string* MsgData::mutable_msg_id() {
  set_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgData.msg_id)
  return msg_id_;
}
inline ::std::string* MsgData::release_msg_id() {
  clear_has_msg_id();
  if (msg_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_id_;
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgData::set_allocated_msg_id(::std::string* msg_id) {
  if (msg_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_id_;
  }
  if (msg_id) {
    set_has_msg_id();
    msg_id_ = msg_id;
  } else {
    clear_has_msg_id();
    msg_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgData.msg_id)
}

// required uint32 from_company_id = 2;
inline bool MsgData::has_from_company_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgData::set_has_from_company_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgData::clear_has_from_company_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgData::clear_from_company_id() {
  from_company_id_ = 0u;
  clear_has_from_company_id();
}
inline ::google::protobuf::uint32 MsgData::from_company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.from_company_id)
  return from_company_id_;
}
inline void MsgData::set_from_company_id(::google::protobuf::uint32 value) {
  set_has_from_company_id();
  from_company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.from_company_id)
}

// required uint32 from_user_id = 3;
inline bool MsgData::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgData::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgData::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgData::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 MsgData::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.from_user_id)
  return from_user_id_;
}
inline void MsgData::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.from_user_id)
}

// required uint32 to_company_id = 4;
inline bool MsgData::has_to_company_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgData::set_has_to_company_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgData::clear_has_to_company_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgData::clear_to_company_id() {
  to_company_id_ = 0u;
  clear_has_to_company_id();
}
inline ::google::protobuf::uint32 MsgData::to_company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.to_company_id)
  return to_company_id_;
}
inline void MsgData::set_to_company_id(::google::protobuf::uint32 value) {
  set_has_to_company_id();
  to_company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.to_company_id)
}

// required uint32 to_user_id = 5;
inline bool MsgData::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgData::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgData::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgData::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 MsgData::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.to_user_id)
  return to_user_id_;
}
inline void MsgData::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.to_user_id)
}

// required .IM.BaseDefine.SessionType session_type = 6;
inline bool MsgData::has_session_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgData::set_has_session_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgData::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgData::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType MsgData::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void MsgData::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.session_type)
}

// required uint64 create_time = 7;
inline bool MsgData::has_create_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgData::set_has_create_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgData::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgData::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 MsgData::create_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.create_time)
  return create_time_;
}
inline void MsgData::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.create_time)
}

// repeated .IM.BaseDefine.MsgItem msg_content = 8;
inline int MsgData::msg_content_size() const {
  return msg_content_.size();
}
inline void MsgData::clear_msg_content() {
  msg_content_.Clear();
}
inline const ::IM::BaseDefine::MsgItem& MsgData::msg_content(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.msg_content)
  return msg_content_.Get(index);
}
inline ::IM::BaseDefine::MsgItem* MsgData::mutable_msg_content(int index) {
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgData.msg_content)
  return msg_content_.Mutable(index);
}
inline ::IM::BaseDefine::MsgItem* MsgData::add_msg_content() {
  // @@protoc_insertion_point(field_add:IM.BaseDefine.MsgData.msg_content)
  return msg_content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::MsgItem >&
MsgData::msg_content() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.MsgData.msg_content)
  return msg_content_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::MsgItem >*
MsgData::mutable_msg_content() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.MsgData.msg_content)
  return &msg_content_;
}

// required .IM.BaseDefine.MsgFont msg_font = 9;
inline bool MsgData::has_msg_font() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgData::set_has_msg_font() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgData::clear_has_msg_font() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgData::clear_msg_font() {
  if (msg_font_ != NULL) msg_font_->::IM::BaseDefine::MsgFont::Clear();
  clear_has_msg_font();
}
inline const ::IM::BaseDefine::MsgFont& MsgData::msg_font() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.msg_font)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_font_ != NULL ? *msg_font_ : *default_instance().msg_font_;
#else
  return msg_font_ != NULL ? *msg_font_ : *default_instance_->msg_font_;
#endif
}
inline ::IM::BaseDefine::MsgFont* MsgData::mutable_msg_font() {
  set_has_msg_font();
  if (msg_font_ == NULL) msg_font_ = new ::IM::BaseDefine::MsgFont;
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgData.msg_font)
  return msg_font_;
}
inline ::IM::BaseDefine::MsgFont* MsgData::release_msg_font() {
  clear_has_msg_font();
  ::IM::BaseDefine::MsgFont* temp = msg_font_;
  msg_font_ = NULL;
  return temp;
}
inline void MsgData::set_allocated_msg_font(::IM::BaseDefine::MsgFont* msg_font) {
  delete msg_font_;
  msg_font_ = msg_font;
  if (msg_font) {
    set_has_msg_font();
  } else {
    clear_has_msg_font();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgData.msg_font)
}

// required uint32 msg_status = 10;
inline bool MsgData::has_msg_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgData::set_has_msg_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgData::clear_has_msg_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgData::clear_msg_status() {
  msg_status_ = 0u;
  clear_has_msg_status();
}
inline ::google::protobuf::uint32 MsgData::msg_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.msg_status)
  return msg_status_;
}
inline void MsgData::set_msg_status(::google::protobuf::uint32 value) {
  set_has_msg_status();
  msg_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.msg_status)
}

// optional .IM.BaseDefine.MsgProperty msg_property = 11;
inline bool MsgData::has_msg_property() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgData::set_has_msg_property() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgData::clear_has_msg_property() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgData::clear_msg_property() {
  msg_property_ = 1;
  clear_has_msg_property();
}
inline ::IM::BaseDefine::MsgProperty MsgData::msg_property() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.msg_property)
  return static_cast< ::IM::BaseDefine::MsgProperty >(msg_property_);
}
inline void MsgData::set_msg_property(::IM::BaseDefine::MsgProperty value) {
  assert(::IM::BaseDefine::MsgProperty_IsValid(value));
  set_has_msg_property();
  msg_property_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgData.msg_property)
}

// repeated .IM.BaseDefine.UserIdItem force_push_ids_list = 15;
inline int MsgData::force_push_ids_list_size() const {
  return force_push_ids_list_.size();
}
inline void MsgData::clear_force_push_ids_list() {
  force_push_ids_list_.Clear();
}
inline const ::IM::BaseDefine::UserIdItem& MsgData::force_push_ids_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgData.force_push_ids_list)
  return force_push_ids_list_.Get(index);
}
inline ::IM::BaseDefine::UserIdItem* MsgData::mutable_force_push_ids_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgData.force_push_ids_list)
  return force_push_ids_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserIdItem* MsgData::add_force_push_ids_list() {
  // @@protoc_insertion_point(field_add:IM.BaseDefine.MsgData.force_push_ids_list)
  return force_push_ids_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserIdItem >&
MsgData::force_push_ids_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.MsgData.force_push_ids_list)
  return force_push_ids_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserIdItem >*
MsgData::mutable_force_push_ids_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.MsgData.force_push_ids_list)
  return &force_push_ids_list_;
}

// -------------------------------------------------------------------

// OfflineMsgCntInfo

// required uint32 msg_cnt = 1;
inline bool OfflineMsgCntInfo::has_msg_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineMsgCntInfo::set_has_msg_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineMsgCntInfo::clear_has_msg_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineMsgCntInfo::clear_msg_cnt() {
  msg_cnt_ = 0u;
  clear_has_msg_cnt();
}
inline ::google::protobuf::uint32 OfflineMsgCntInfo::msg_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineMsgCntInfo.msg_cnt)
  return msg_cnt_;
}
inline void OfflineMsgCntInfo::set_msg_cnt(::google::protobuf::uint32 value) {
  set_has_msg_cnt();
  msg_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineMsgCntInfo.msg_cnt)
}

// required .IM.BaseDefine.MsgData lastest_msg_data = 2;
inline bool OfflineMsgCntInfo::has_lastest_msg_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineMsgCntInfo::set_has_lastest_msg_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineMsgCntInfo::clear_has_lastest_msg_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineMsgCntInfo::clear_lastest_msg_data() {
  if (lastest_msg_data_ != NULL) lastest_msg_data_->::IM::BaseDefine::MsgData::Clear();
  clear_has_lastest_msg_data();
}
inline const ::IM::BaseDefine::MsgData& OfflineMsgCntInfo::lastest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineMsgCntInfo.lastest_msg_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return lastest_msg_data_ != NULL ? *lastest_msg_data_ : *default_instance().lastest_msg_data_;
#else
  return lastest_msg_data_ != NULL ? *lastest_msg_data_ : *default_instance_->lastest_msg_data_;
#endif
}
inline ::IM::BaseDefine::MsgData* OfflineMsgCntInfo::mutable_lastest_msg_data() {
  set_has_lastest_msg_data();
  if (lastest_msg_data_ == NULL) lastest_msg_data_ = new ::IM::BaseDefine::MsgData;
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineMsgCntInfo.lastest_msg_data)
  return lastest_msg_data_;
}
inline ::IM::BaseDefine::MsgData* OfflineMsgCntInfo::release_lastest_msg_data() {
  clear_has_lastest_msg_data();
  ::IM::BaseDefine::MsgData* temp = lastest_msg_data_;
  lastest_msg_data_ = NULL;
  return temp;
}
inline void OfflineMsgCntInfo::set_allocated_lastest_msg_data(::IM::BaseDefine::MsgData* lastest_msg_data) {
  delete lastest_msg_data_;
  lastest_msg_data_ = lastest_msg_data;
  if (lastest_msg_data) {
    set_has_lastest_msg_data();
  } else {
    clear_has_lastest_msg_data();
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineMsgCntInfo.lastest_msg_data)
}

// -------------------------------------------------------------------

// GroupListItem

// required uint32 company_id = 1;
inline bool GroupListItem::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupListItem::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupListItem::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupListItem::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 GroupListItem::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupListItem.company_id)
  return company_id_;
}
inline void GroupListItem::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupListItem.company_id)
}

// required uint32 group_id = 2;
inline bool GroupListItem::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupListItem::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupListItem::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupListItem::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupListItem::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupListItem.group_id)
  return group_id_;
}
inline void GroupListItem::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupListItem.group_id)
}

// required .IM.BaseDefine.GroupType group_type = 3;
inline bool GroupListItem::has_group_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupListItem::set_has_group_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupListItem::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupListItem::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::IM::BaseDefine::GroupType GroupListItem::group_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupListItem.group_type)
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline void GroupListItem::set_group_type(::IM::BaseDefine::GroupType value) {
  assert(::IM::BaseDefine::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupListItem.group_type)
}

// required uint64 update_time = 4;
inline bool GroupListItem::has_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupListItem::set_has_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupListItem::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupListItem::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 GroupListItem::update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupListItem.update_time)
  return update_time_;
}
inline void GroupListItem::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupListItem.update_time)
}

// -------------------------------------------------------------------

// GroupMemberItem

// required uint32 company_id = 1;
inline bool GroupMemberItem::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberItem::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberItem::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberItem::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 GroupMemberItem::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberItem.company_id)
  return company_id_;
}
inline void GroupMemberItem::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberItem.company_id)
}

// required uint32 member_id = 2;
inline bool GroupMemberItem::has_member_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberItem::set_has_member_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberItem::clear_has_member_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberItem::clear_member_id() {
  member_id_ = 0u;
  clear_has_member_id();
}
inline ::google::protobuf::uint32 GroupMemberItem::member_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberItem.member_id)
  return member_id_;
}
inline void GroupMemberItem::set_member_id(::google::protobuf::uint32 value) {
  set_has_member_id();
  member_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberItem.member_id)
}

// required string member_name = 3;
inline bool GroupMemberItem::has_member_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberItem::set_has_member_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberItem::clear_has_member_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberItem::clear_member_name() {
  if (member_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    member_name_->clear();
  }
  clear_has_member_name();
}
inline const ::std::string& GroupMemberItem::member_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberItem.member_name)
  return *member_name_;
}
inline void GroupMemberItem::set_member_name(const ::std::string& value) {
  set_has_member_name();
  if (member_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    member_name_ = new ::std::string;
  }
  member_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberItem.member_name)
}
inline void GroupMemberItem::set_member_name(const char* value) {
  set_has_member_name();
  if (member_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    member_name_ = new ::std::string;
  }
  member_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupMemberItem.member_name)
}
inline void GroupMemberItem::set_member_name(const char* value, size_t size) {
  set_has_member_name();
  if (member_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    member_name_ = new ::std::string;
  }
  member_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupMemberItem.member_name)
}
inline ::std::string* GroupMemberItem::mutable_member_name() {
  set_has_member_name();
  if (member_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    member_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupMemberItem.member_name)
  return member_name_;
}
inline ::std::string* GroupMemberItem::release_member_name() {
  clear_has_member_name();
  if (member_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = member_name_;
    member_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupMemberItem::set_allocated_member_name(::std::string* member_name) {
  if (member_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete member_name_;
  }
  if (member_name) {
    set_has_member_name();
    member_name_ = member_name;
  } else {
    clear_has_member_name();
    member_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupMemberItem.member_name)
}

// required uint32 member_role = 4;
inline bool GroupMemberItem::has_member_role() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberItem::set_has_member_role() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberItem::clear_has_member_role() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberItem::clear_member_role() {
  member_role_ = 0u;
  clear_has_member_role();
}
inline ::google::protobuf::uint32 GroupMemberItem::member_role() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberItem.member_role)
  return member_role_;
}
inline void GroupMemberItem::set_member_role(::google::protobuf::uint32 value) {
  set_has_member_role();
  member_role_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberItem.member_role)
}

// required bool is_delete = 5;
inline bool GroupMemberItem::has_is_delete() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberItem::set_has_is_delete() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberItem::clear_has_is_delete() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberItem::clear_is_delete() {
  is_delete_ = false;
  clear_has_is_delete();
}
inline bool GroupMemberItem::is_delete() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupMemberItem.is_delete)
  return is_delete_;
}
inline void GroupMemberItem::set_is_delete(bool value) {
  set_has_is_delete();
  is_delete_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupMemberItem.is_delete)
}

// -------------------------------------------------------------------

// GroupInfo

// required uint32 company_id = 1;
inline bool GroupInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 GroupInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.company_id)
  return company_id_;
}
inline void GroupInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.company_id)
}

// required uint32 group_id = 2;
inline bool GroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_id)
  return group_id_;
}
inline void GroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_id)
}

// required uint64 update_time = 3;
inline bool GroupInfo::has_update_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_update_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 GroupInfo::update_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.update_time)
  return update_time_;
}
inline void GroupInfo::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.update_time)
}

// required string group_name = 4;
inline bool GroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_name)
  return *group_name_;
}
inline void GroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_name)
}
inline ::std::string* GroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_name)
  return group_name_;
}
inline ::std::string* GroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_name)
}

// optional string group_avatar = 5;
inline bool GroupInfo::has_group_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_group_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_group_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_group_avatar() {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_->clear();
  }
  clear_has_group_avatar();
}
inline const ::std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_avatar)
  return *group_avatar_;
}
inline void GroupInfo::set_group_avatar(const ::std::string& value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value, size_t size) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_avatar)
}
inline ::std::string* GroupInfo::mutable_group_avatar() {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_avatar)
  return group_avatar_;
}
inline ::std::string* GroupInfo::release_group_avatar() {
  clear_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_avatar_;
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_avatar(::std::string* group_avatar) {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  if (group_avatar) {
    set_has_group_avatar();
    group_avatar_ = group_avatar;
  } else {
    clear_has_group_avatar();
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_avatar)
}

// required uint32 group_creator_id = 6;
inline bool GroupInfo::has_group_creator_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_group_creator_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_group_creator_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_group_creator_id() {
  group_creator_id_ = 0u;
  clear_has_group_creator_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_creator_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_creator_id)
  return group_creator_id_;
}
inline void GroupInfo::set_group_creator_id(::google::protobuf::uint32 value) {
  set_has_group_creator_id();
  group_creator_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_creator_id)
}

// required .IM.BaseDefine.GroupType group_type = 7;
inline bool GroupInfo::has_group_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_group_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::IM::BaseDefine::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_type)
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline void GroupInfo::set_group_type(::IM::BaseDefine::GroupType value) {
  assert(::IM::BaseDefine::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_type)
}

// optional uint32 shield_status = 8;
inline bool GroupInfo::has_shield_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupInfo::set_has_shield_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupInfo::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupInfo::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.shield_status)
  return shield_status_;
}
inline void GroupInfo::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.shield_status)
}

// required uint32 group_member_count = 9;
inline bool GroupInfo::has_group_member_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupInfo::set_has_group_member_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupInfo::clear_has_group_member_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupInfo::clear_group_member_count() {
  group_member_count_ = 0u;
  clear_has_group_member_count();
}
inline ::google::protobuf::uint32 GroupInfo::group_member_count() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_member_count)
  return group_member_count_;
}
inline void GroupInfo::set_group_member_count(::google::protobuf::uint32 value) {
  set_has_group_member_count();
  group_member_count_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_member_count)
}

// optional bool is_delete = 10;
inline bool GroupInfo::has_is_delete() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupInfo::set_has_is_delete() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupInfo::clear_has_is_delete() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupInfo::clear_is_delete() {
  is_delete_ = false;
  clear_has_is_delete();
}
inline bool GroupInfo::is_delete() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.is_delete)
  return is_delete_;
}
inline void GroupInfo::set_is_delete(bool value) {
  set_has_is_delete();
  is_delete_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.is_delete)
}

// optional uint32 fixtop_priority = 11;
inline bool GroupInfo::has_fixtop_priority() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupInfo::set_has_fixtop_priority() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupInfo::clear_has_fixtop_priority() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupInfo::clear_fixtop_priority() {
  fixtop_priority_ = 0u;
  clear_has_fixtop_priority();
}
inline ::google::protobuf::uint32 GroupInfo::fixtop_priority() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.fixtop_priority)
  return fixtop_priority_;
}
inline void GroupInfo::set_fixtop_priority(::google::protobuf::uint32 value) {
  set_has_fixtop_priority();
  fixtop_priority_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.fixtop_priority)
}

// optional uint32 show = 12;
inline bool GroupInfo::has_show() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupInfo::set_has_show() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupInfo::clear_has_show() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupInfo::clear_show() {
  show_ = 0u;
  clear_has_show();
}
inline ::google::protobuf::uint32 GroupInfo::show() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.show)
  return show_;
}
inline void GroupInfo::set_show(::google::protobuf::uint32 value) {
  set_has_show();
  show_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.show)
}

// optional string topic = 13;
inline bool GroupInfo::has_topic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GroupInfo::set_has_topic() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GroupInfo::clear_has_topic() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GroupInfo::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GroupInfo::topic() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.topic)
  return *topic_;
}
inline void GroupInfo::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.topic)
}
inline void GroupInfo::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.topic)
}
inline void GroupInfo::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.topic)
}
inline ::std::string* GroupInfo::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.topic)
  return topic_;
}
inline ::std::string* GroupInfo::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.topic)
}

// optional bool not_disturb = 14;
inline bool GroupInfo::has_not_disturb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GroupInfo::set_has_not_disturb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GroupInfo::clear_has_not_disturb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GroupInfo::clear_not_disturb() {
  not_disturb_ = false;
  clear_has_not_disturb();
}
inline bool GroupInfo::not_disturb() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.not_disturb)
  return not_disturb_;
}
inline void GroupInfo::set_not_disturb(bool value) {
  set_has_not_disturb();
  not_disturb_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.not_disturb)
}

// -------------------------------------------------------------------

// UserTokenInfo

// required uint32 company_id = 1;
inline bool UserTokenInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 UserTokenInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.company_id)
  return company_id_;
}
inline void UserTokenInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.company_id)
}

// required uint32 user_id = 2;
inline bool UserTokenInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTokenInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTokenInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTokenInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_id)
  return user_id_;
}
inline void UserTokenInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_id)
}

// required .IM.BaseDefine.ClientType user_type = 3;
inline bool UserTokenInfo::has_user_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTokenInfo::set_has_user_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTokenInfo::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTokenInfo::clear_user_type() {
  user_type_ = 1;
  clear_has_user_type();
}
inline ::IM::BaseDefine::ClientType UserTokenInfo::user_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_type)
  return static_cast< ::IM::BaseDefine::ClientType >(user_type_);
}
inline void UserTokenInfo::set_user_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_user_type();
  user_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_type)
}

// required string token = 4;
inline bool UserTokenInfo::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTokenInfo::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTokenInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTokenInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.token)
  return *token_;
}
inline void UserTokenInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserTokenInfo.token)
}
inline ::std::string* UserTokenInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserTokenInfo.token)
  return token_;
}
inline ::std::string* UserTokenInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserTokenInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserTokenInfo.token)
}

// required uint32 push_count = 5;
inline bool UserTokenInfo::has_push_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTokenInfo::set_has_push_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTokenInfo::clear_has_push_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTokenInfo::clear_push_count() {
  push_count_ = 0u;
  clear_has_push_count();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_count)
  return push_count_;
}
inline void UserTokenInfo::set_push_count(::google::protobuf::uint32 value) {
  set_has_push_count();
  push_count_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_count)
}

// required uint32 push_type = 6;
inline bool UserTokenInfo::has_push_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTokenInfo::set_has_push_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTokenInfo::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTokenInfo::clear_push_type() {
  push_type_ = 0u;
  clear_has_push_type();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_type)
  return push_type_;
}
inline void UserTokenInfo::set_push_type(::google::protobuf::uint32 value) {
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_type)
}

// -------------------------------------------------------------------

// PushResult

// required string user_token = 1;
inline bool PushResult::has_user_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushResult::set_has_user_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushResult::clear_has_user_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushResult::clear_user_token() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_->clear();
  }
  clear_has_user_token();
}
inline const ::std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.user_token)
  return *user_token_;
}
inline void PushResult::set_user_token(const ::std::string& value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value, size_t size) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.PushResult.user_token)
}
inline ::std::string* PushResult::mutable_user_token() {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.PushResult.user_token)
  return user_token_;
}
inline ::std::string* PushResult::release_user_token() {
  clear_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_token_;
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushResult::set_allocated_user_token(::std::string* user_token) {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  if (user_token) {
    set_has_user_token();
    user_token_ = user_token;
  } else {
    clear_has_user_token();
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.PushResult.user_token)
}

// required uint32 result_code = 2;
inline bool PushResult::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushResult::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushResult::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushResult::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.result_code)
  return result_code_;
}
inline void PushResult::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// required uint32 company_id = 1;
inline bool ShieldStatus::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShieldStatus::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShieldStatus::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShieldStatus::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 ShieldStatus::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.company_id)
  return company_id_;
}
inline void ShieldStatus::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.company_id)
}

// required uint32 user_id = 2;
inline bool ShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.user_id)
  return user_id_;
}
inline void ShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.user_id)
}

// required uint32 group_id = 3;
inline bool ShieldStatus::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShieldStatus::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShieldStatus::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShieldStatus::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.group_id)
  return group_id_;
}
inline void ShieldStatus::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.group_id)
}

// required uint32 shield_status = 4;
inline bool ShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.shield_status)
  return shield_status_;
}
inline void ShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// required uint32 company_id = 1;
inline bool OfflineFileInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineFileInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineFileInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineFileInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 OfflineFileInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.company_id)
  return company_id_;
}
inline void OfflineFileInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.company_id)
}

// required uint32 from_user_id = 2;
inline bool OfflineFileInfo::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineFileInfo::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineFileInfo::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineFileInfo::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.from_user_id)
  return from_user_id_;
}
inline void OfflineFileInfo::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.from_user_id)
}

// required string task_id = 3;
inline bool OfflineFileInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineFileInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineFileInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineFileInfo::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.task_id)
  return *task_id_;
}
inline void OfflineFileInfo::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline ::std::string* OfflineFileInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.task_id)
  return task_id_;
}
inline ::std::string* OfflineFileInfo::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.task_id)
}

// required string file_name = 4;
inline bool OfflineFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfflineFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfflineFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfflineFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_name)
  return *file_name_;
}
inline void OfflineFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline ::std::string* OfflineFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.file_name)
  return file_name_;
}
inline ::std::string* OfflineFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.file_name)
}

// required uint32 file_size = 5;
inline bool OfflineFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OfflineFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OfflineFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OfflineFileInfo::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_size)
  return file_size_;
}
inline void OfflineFileInfo::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_size)
}

// -------------------------------------------------------------------

// PushShieldStatus

// required uint32 company_id = 1;
inline bool PushShieldStatus::has_company_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushShieldStatus::set_has_company_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushShieldStatus::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushShieldStatus::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 PushShieldStatus::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.company_id)
  return company_id_;
}
inline void PushShieldStatus::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.company_id)
}

// required uint32 user_id = 2;
inline bool PushShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 PushShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.user_id)
  return user_id_;
}
inline void PushShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.user_id)
}

// required uint32 shield_status = 3;
inline bool PushShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 PushShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushShieldStatus.shield_status)
  return shield_status_;
}
inline void PushShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// IMBuddyReqInfo

// required uint32 user_id = 1;
inline bool IMBuddyReqInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMBuddyReqInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMBuddyReqInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMBuddyReqInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMBuddyReqInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.user_id)
  return user_id_;
}
inline void IMBuddyReqInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.user_id)
}

// required uint32 company_id = 2;
inline bool IMBuddyReqInfo::has_company_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMBuddyReqInfo::set_has_company_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMBuddyReqInfo::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMBuddyReqInfo::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 IMBuddyReqInfo::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.company_id)
  return company_id_;
}
inline void IMBuddyReqInfo::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.company_id)
}

// required uint32 dest_user_id = 3;
inline bool IMBuddyReqInfo::has_dest_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMBuddyReqInfo::set_has_dest_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMBuddyReqInfo::clear_has_dest_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMBuddyReqInfo::clear_dest_user_id() {
  dest_user_id_ = 0u;
  clear_has_dest_user_id();
}
inline ::google::protobuf::uint32 IMBuddyReqInfo::dest_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.dest_user_id)
  return dest_user_id_;
}
inline void IMBuddyReqInfo::set_dest_user_id(::google::protobuf::uint32 value) {
  set_has_dest_user_id();
  dest_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.dest_user_id)
}

// required uint32 dest_company_id = 4;
inline bool IMBuddyReqInfo::has_dest_company_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMBuddyReqInfo::set_has_dest_company_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMBuddyReqInfo::clear_has_dest_company_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMBuddyReqInfo::clear_dest_company_id() {
  dest_company_id_ = 0u;
  clear_has_dest_company_id();
}
inline ::google::protobuf::uint32 IMBuddyReqInfo::dest_company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.dest_company_id)
  return dest_company_id_;
}
inline void IMBuddyReqInfo::set_dest_company_id(::google::protobuf::uint32 value) {
  set_has_dest_company_id();
  dest_company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.dest_company_id)
}

// required uint32 req_stat = 5;
inline bool IMBuddyReqInfo::has_req_stat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMBuddyReqInfo::set_has_req_stat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMBuddyReqInfo::clear_has_req_stat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMBuddyReqInfo::clear_req_stat() {
  req_stat_ = 0u;
  clear_has_req_stat();
}
inline ::google::protobuf::uint32 IMBuddyReqInfo::req_stat() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.req_stat)
  return req_stat_;
}
inline void IMBuddyReqInfo::set_req_stat(::google::protobuf::uint32 value) {
  set_has_req_stat();
  req_stat_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.req_stat)
}

// required uint64 req_time = 6;
inline bool IMBuddyReqInfo::has_req_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMBuddyReqInfo::set_has_req_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMBuddyReqInfo::clear_has_req_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMBuddyReqInfo::clear_req_time() {
  req_time_ = GOOGLE_ULONGLONG(0);
  clear_has_req_time();
}
inline ::google::protobuf::uint64 IMBuddyReqInfo::req_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.req_time)
  return req_time_;
}
inline void IMBuddyReqInfo::set_req_time(::google::protobuf::uint64 value) {
  set_has_req_time();
  req_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.req_time)
}

// required string remark = 7;
inline bool IMBuddyReqInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMBuddyReqInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMBuddyReqInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMBuddyReqInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& IMBuddyReqInfo::remark() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMBuddyReqInfo.remark)
  return *remark_;
}
inline void IMBuddyReqInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMBuddyReqInfo.remark)
}
inline void IMBuddyReqInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMBuddyReqInfo.remark)
}
inline void IMBuddyReqInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMBuddyReqInfo.remark)
}
inline ::std::string* IMBuddyReqInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMBuddyReqInfo.remark)
  return remark_;
}
inline ::std::string* IMBuddyReqInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMBuddyReqInfo::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMBuddyReqInfo.remark)
}

// -------------------------------------------------------------------

// IMSinglePullNotify

// required uint32 type = 1;
inline bool IMSinglePullNotify::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSinglePullNotify::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSinglePullNotify::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSinglePullNotify::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IMSinglePullNotify::type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMSinglePullNotify.type)
  return type_;
}
inline void IMSinglePullNotify::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMSinglePullNotify.type)
}

// -------------------------------------------------------------------

// IMGroupPullNotify

// required uint32 type = 1;
inline bool IMGroupPullNotify::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMGroupPullNotify::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMGroupPullNotify::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMGroupPullNotify::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IMGroupPullNotify::type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMGroupPullNotify.type)
  return type_;
}
inline void IMGroupPullNotify::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMGroupPullNotify.type)
}

// required uint32 company_id = 2;
inline bool IMGroupPullNotify::has_company_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGroupPullNotify::set_has_company_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGroupPullNotify::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGroupPullNotify::clear_company_id() {
  company_id_ = 0u;
  clear_has_company_id();
}
inline ::google::protobuf::uint32 IMGroupPullNotify::company_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMGroupPullNotify.company_id)
  return company_id_;
}
inline void IMGroupPullNotify::set_company_id(::google::protobuf::uint32 value) {
  set_has_company_id();
  company_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMGroupPullNotify.company_id)
}

// required uint32 group_id = 3;
inline bool IMGroupPullNotify::has_group_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMGroupPullNotify::set_has_group_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMGroupPullNotify::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMGroupPullNotify::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 IMGroupPullNotify::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMGroupPullNotify.group_id)
  return group_id_;
}
inline void IMGroupPullNotify::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMGroupPullNotify.group_id)
}

// -------------------------------------------------------------------

// IMUserAuthority

// required uint32 auth_id = 1;
inline bool IMUserAuthority::has_auth_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserAuthority::set_has_auth_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserAuthority::clear_has_auth_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserAuthority::clear_auth_id() {
  auth_id_ = 0u;
  clear_has_auth_id();
}
inline ::google::protobuf::uint32 IMUserAuthority::auth_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.auth_id)
  return auth_id_;
}
inline void IMUserAuthority::set_auth_id(::google::protobuf::uint32 value) {
  set_has_auth_id();
  auth_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.auth_id)
}

// required string auth_value = 2;
inline bool IMUserAuthority::has_auth_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserAuthority::set_has_auth_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserAuthority::clear_has_auth_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserAuthority::clear_auth_value() {
  if (auth_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_value_->clear();
  }
  clear_has_auth_value();
}
inline const ::std::string& IMUserAuthority::auth_value() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.auth_value)
  return *auth_value_;
}
inline void IMUserAuthority::set_auth_value(const ::std::string& value) {
  set_has_auth_value();
  if (auth_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_value_ = new ::std::string;
  }
  auth_value_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.auth_value)
}
inline void IMUserAuthority::set_auth_value(const char* value) {
  set_has_auth_value();
  if (auth_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_value_ = new ::std::string;
  }
  auth_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserAuthority.auth_value)
}
inline void IMUserAuthority::set_auth_value(const char* value, size_t size) {
  set_has_auth_value();
  if (auth_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_value_ = new ::std::string;
  }
  auth_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserAuthority.auth_value)
}
inline ::std::string* IMUserAuthority::mutable_auth_value() {
  set_has_auth_value();
  if (auth_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    auth_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserAuthority.auth_value)
  return auth_value_;
}
inline ::std::string* IMUserAuthority::release_auth_value() {
  clear_has_auth_value();
  if (auth_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = auth_value_;
    auth_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAuthority::set_allocated_auth_value(::std::string* auth_value) {
  if (auth_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete auth_value_;
  }
  if (auth_value) {
    set_has_auth_value();
    auth_value_ = auth_value;
  } else {
    clear_has_auth_value();
    auth_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserAuthority.auth_value)
}

// optional string ext_value1 = 3;
inline bool IMUserAuthority::has_ext_value1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUserAuthority::set_has_ext_value1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUserAuthority::clear_has_ext_value1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUserAuthority::clear_ext_value1() {
  if (ext_value1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value1_->clear();
  }
  clear_has_ext_value1();
}
inline const ::std::string& IMUserAuthority::ext_value1() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.ext_value1)
  return *ext_value1_;
}
inline void IMUserAuthority::set_ext_value1(const ::std::string& value) {
  set_has_ext_value1();
  if (ext_value1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value1_ = new ::std::string;
  }
  ext_value1_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.ext_value1)
}
inline void IMUserAuthority::set_ext_value1(const char* value) {
  set_has_ext_value1();
  if (ext_value1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value1_ = new ::std::string;
  }
  ext_value1_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserAuthority.ext_value1)
}
inline void IMUserAuthority::set_ext_value1(const char* value, size_t size) {
  set_has_ext_value1();
  if (ext_value1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value1_ = new ::std::string;
  }
  ext_value1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserAuthority.ext_value1)
}
inline ::std::string* IMUserAuthority::mutable_ext_value1() {
  set_has_ext_value1();
  if (ext_value1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserAuthority.ext_value1)
  return ext_value1_;
}
inline ::std::string* IMUserAuthority::release_ext_value1() {
  clear_has_ext_value1();
  if (ext_value1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ext_value1_;
    ext_value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAuthority::set_allocated_ext_value1(::std::string* ext_value1) {
  if (ext_value1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value1_;
  }
  if (ext_value1) {
    set_has_ext_value1();
    ext_value1_ = ext_value1;
  } else {
    clear_has_ext_value1();
    ext_value1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserAuthority.ext_value1)
}

// optional string ext_value2 = 4;
inline bool IMUserAuthority::has_ext_value2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUserAuthority::set_has_ext_value2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUserAuthority::clear_has_ext_value2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUserAuthority::clear_ext_value2() {
  if (ext_value2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value2_->clear();
  }
  clear_has_ext_value2();
}
inline const ::std::string& IMUserAuthority::ext_value2() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.ext_value2)
  return *ext_value2_;
}
inline void IMUserAuthority::set_ext_value2(const ::std::string& value) {
  set_has_ext_value2();
  if (ext_value2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value2_ = new ::std::string;
  }
  ext_value2_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.ext_value2)
}
inline void IMUserAuthority::set_ext_value2(const char* value) {
  set_has_ext_value2();
  if (ext_value2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value2_ = new ::std::string;
  }
  ext_value2_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserAuthority.ext_value2)
}
inline void IMUserAuthority::set_ext_value2(const char* value, size_t size) {
  set_has_ext_value2();
  if (ext_value2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value2_ = new ::std::string;
  }
  ext_value2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserAuthority.ext_value2)
}
inline ::std::string* IMUserAuthority::mutable_ext_value2() {
  set_has_ext_value2();
  if (ext_value2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserAuthority.ext_value2)
  return ext_value2_;
}
inline ::std::string* IMUserAuthority::release_ext_value2() {
  clear_has_ext_value2();
  if (ext_value2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ext_value2_;
    ext_value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAuthority::set_allocated_ext_value2(::std::string* ext_value2) {
  if (ext_value2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value2_;
  }
  if (ext_value2) {
    set_has_ext_value2();
    ext_value2_ = ext_value2;
  } else {
    clear_has_ext_value2();
    ext_value2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserAuthority.ext_value2)
}

// optional string ext_value3 = 5;
inline bool IMUserAuthority::has_ext_value3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUserAuthority::set_has_ext_value3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUserAuthority::clear_has_ext_value3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUserAuthority::clear_ext_value3() {
  if (ext_value3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value3_->clear();
  }
  clear_has_ext_value3();
}
inline const ::std::string& IMUserAuthority::ext_value3() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.ext_value3)
  return *ext_value3_;
}
inline void IMUserAuthority::set_ext_value3(const ::std::string& value) {
  set_has_ext_value3();
  if (ext_value3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value3_ = new ::std::string;
  }
  ext_value3_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.ext_value3)
}
inline void IMUserAuthority::set_ext_value3(const char* value) {
  set_has_ext_value3();
  if (ext_value3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value3_ = new ::std::string;
  }
  ext_value3_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserAuthority.ext_value3)
}
inline void IMUserAuthority::set_ext_value3(const char* value, size_t size) {
  set_has_ext_value3();
  if (ext_value3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value3_ = new ::std::string;
  }
  ext_value3_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserAuthority.ext_value3)
}
inline ::std::string* IMUserAuthority::mutable_ext_value3() {
  set_has_ext_value3();
  if (ext_value3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value3_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserAuthority.ext_value3)
  return ext_value3_;
}
inline ::std::string* IMUserAuthority::release_ext_value3() {
  clear_has_ext_value3();
  if (ext_value3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ext_value3_;
    ext_value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAuthority::set_allocated_ext_value3(::std::string* ext_value3) {
  if (ext_value3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value3_;
  }
  if (ext_value3) {
    set_has_ext_value3();
    ext_value3_ = ext_value3;
  } else {
    clear_has_ext_value3();
    ext_value3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserAuthority.ext_value3)
}

// optional string ext_value4 = 6;
inline bool IMUserAuthority::has_ext_value4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUserAuthority::set_has_ext_value4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUserAuthority::clear_has_ext_value4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUserAuthority::clear_ext_value4() {
  if (ext_value4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value4_->clear();
  }
  clear_has_ext_value4();
}
inline const ::std::string& IMUserAuthority::ext_value4() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserAuthority.ext_value4)
  return *ext_value4_;
}
inline void IMUserAuthority::set_ext_value4(const ::std::string& value) {
  set_has_ext_value4();
  if (ext_value4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value4_ = new ::std::string;
  }
  ext_value4_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserAuthority.ext_value4)
}
inline void IMUserAuthority::set_ext_value4(const char* value) {
  set_has_ext_value4();
  if (ext_value4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value4_ = new ::std::string;
  }
  ext_value4_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserAuthority.ext_value4)
}
inline void IMUserAuthority::set_ext_value4(const char* value, size_t size) {
  set_has_ext_value4();
  if (ext_value4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value4_ = new ::std::string;
  }
  ext_value4_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserAuthority.ext_value4)
}
inline ::std::string* IMUserAuthority::mutable_ext_value4() {
  set_has_ext_value4();
  if (ext_value4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ext_value4_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserAuthority.ext_value4)
  return ext_value4_;
}
inline ::std::string* IMUserAuthority::release_ext_value4() {
  clear_has_ext_value4();
  if (ext_value4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ext_value4_;
    ext_value4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserAuthority::set_allocated_ext_value4(::std::string* ext_value4) {
  if (ext_value4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ext_value4_;
  }
  if (ext_value4) {
    set_has_ext_value4();
    ext_value4_ = ext_value4;
  } else {
    clear_has_ext_value4();
    ext_value4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserAuthority.ext_value4)
}

// -------------------------------------------------------------------

// IMUserRole

// required uint32 role_id = 1;
inline bool IMUserRole::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUserRole::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUserRole::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUserRole::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 IMUserRole::role_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserRole.role_id)
  return role_id_;
}
inline void IMUserRole::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserRole.role_id)
}

// required string role_name = 2;
inline bool IMUserRole::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUserRole::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUserRole::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUserRole::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& IMUserRole::role_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserRole.role_name)
  return *role_name_;
}
inline void IMUserRole::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IMUserRole.role_name)
}
inline void IMUserRole::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IMUserRole.role_name)
}
inline void IMUserRole::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IMUserRole.role_name)
}
inline ::std::string* IMUserRole::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    role_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserRole.role_name)
  return role_name_;
}
inline ::std::string* IMUserRole::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMUserRole::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IMUserRole.role_name)
}

// repeated .IM.BaseDefine.IMUserAuthority authority = 3;
inline int IMUserRole::authority_size() const {
  return authority_.size();
}
inline void IMUserRole::clear_authority() {
  authority_.Clear();
}
inline const ::IM::BaseDefine::IMUserAuthority& IMUserRole::authority(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IMUserRole.authority)
  return authority_.Get(index);
}
inline ::IM::BaseDefine::IMUserAuthority* IMUserRole::mutable_authority(int index) {
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IMUserRole.authority)
  return authority_.Mutable(index);
}
inline ::IM::BaseDefine::IMUserAuthority* IMUserRole::add_authority() {
  // @@protoc_insertion_point(field_add:IM.BaseDefine.IMUserRole.authority)
  return authority_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IMUserAuthority >&
IMUserRole::authority() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.IMUserRole.authority)
  return authority_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IMUserAuthority >*
IMUserRole::mutable_authority() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.IMUserRole.authority)
  return &authority_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
